---
title: "[이산수학] 트리(Tree) : 09. 허프만 알고리즘"

categories:
    - Discrete Mathematics

comments: true
share: false
use_math: true
toc: true
toc_sticky: true
toc_label: "[이산수학] 09. 허프만 알고리즘"
classes: wide
date: 2024-02-14
last_modified_at: 2024-02-14
---

# 허프만 알고리즘

- 컴퓨터에서 문자 데이터를 표현할 때 7 비트의 ASCII코드를 사용한다.

- 컴퓨터에서 별다른 조치 없이 문자열을 저장한다면, 문자의 발생 빈도와 상관없이 각 문자는 언제다 동일한 길이의 비트를 사용한다.

- 그러므로 하나의 파일 내에서 문자 수만큼  비트 수가 늘어난다.

- 즉, 파일 안에 문자가 10개 있으면 70비트, 20개 있으면 140비트를 차지한다.

- 만약 문자의 발생 빈도에 따라 할당하는 비트 수를 조절한다면 차지하는 메모리 공간을 줄일 수 있지 않을까?

- 다시 말해 파일 내에서 발생 빈도가 높은 문자에 적은 비트를 할당, 발생 빈도가 낮은 문자에 많은 비트를 할당한다면 파일의 용량을 줄일 수 있을 것이다.

> 이렇게 파일 크기를 줄이는 방법을 데이터 압축(data compression)이라고 한다.

> 이번 절에서는 대표적인 데이터 압축 방법인 허프만 알고리즘을 살펴본다.

<br>

## 정의 : 허프만 알고리즘(Huffman algorithm)

> 발생 빈도가 높은 문자에서는 적은 비트를 할당하고 발생 빈도가 낮은 문자에는 많은 비트를 할당하는 알고리즘


1. 발생 빈도가 가장 낮은 두 문자를 선택하여 하나의 이진트리를 생성한다.

    1. 왼쪽 노드에 빈도 수가 낮은 문자를, 오른쪽 노드에 빈도 수가 높은 문자를 위치시킨다.

    2. 빈도 수가 같은 경우는 사전적으로 앞에 오는 문자를 왼쪽에 위치시킨다.

    3. 두 문자의 빈도 수의 합을 그 문자들의 부모노드로 한다.

2. 1번의 과정을 모든 문자가 하나의 이진트리로 묶일 때까지 반복한다.

3. 생성된 이진트리의 왼쪽 노드에서는 $0$, 오른쪽 노드에는 $1$ 을 부여한다.

4. 루트부터 해당 문자까지의 $0$ 또는 $1$ 을 순서대로 나열한다.

<br>

### 예시

<br>

- 다음 문자의 빈도 수 표를 허프만 알고리즘을 이용해 압축해보자.

<img src = "/assets/images/Math/dm/dm_example_28_01.png">

- 만약 문자들을 허프만 알고리즘을 통한 압축 없이 메모리에 저장하면 $(15 + 8 + 23 + 8 + 30 + 2 + 17 + 5 + 2) \times 7 = 770$ 비트가 필요할 것이다.

---

1. 빈도 수가 가장 낮은 문자는 $o$ 와 $z$ 이다.

    - 두 문자의 빈도 수가 같고 $o$ 가 $z$ 보다 사전적 순서가 앞이므로 $o$ 를 왼쪽 노드, $z$ 를 오른쪽 노드로 한다.

    <img src = "/assets/images/Math/dm/dm_example_28_02.png" width=500>
    <img src = "/assets/images/Math/dm/dm_example_28_03.png">

    <br>

2. 다음으로 빈도 수가 가장 낮은 문자는 1번에서 만든 $o/z$ 서브트리와 $u$ 이다.

    - $u$ 의 빈도 수가 $o/z$ 서브트리보다 높으므로 오른쪽 노드로 한다.

    <img src = "/assets/images/Math/dm/dm_example_28_04.png" width=500>
    <img src = "/assets/images/Math/dm/dm_example_28_05.png">

    <br>

3. 다음으로 빈도 수가 낮은 문자는 $e$ 와 $j$ 이다. 

    - 그러므로 2번에서 만든 $o/z/u$ 서브트리와 별도로 서브트리가 만들어진다.

    <img src = "/assets/images/Math/dm/dm_example_28_06.png" width=500>
    <img src = "/assets/images/Math/dm/dm_example_28_07.png">

    <br>

4. 다음으로 빈도 수가 낮은 문자는 $b$ 와 $o/z/u$ 서브트리이다.

    - $b$의 빈도 수가 $o/z/u$ 서브트리보다 높으므로 오른쪽 노드에 위치시킨다.

    <img src = "/assets/images/Math/dm/dm_example_28_08.png" width=500>
    <img src = "/assets/images/Math/dm/dm_example_28_09.png">

    <br>

5. 다음으로 빈도 수가 낮은 문자는 $s$ 와 $e/j$ 서브트리이다.

    - $e/j$ 서브트리의 빈도 수가 더 낮으므로 왼쪽 서브트리로 하고 $s$ 를 오른쪽 노드에 위치시킨다.

    <img src = "/assets/images/Math/dm/dm_example_28_10.png" width=500>
    <img src = "/assets/images/Math/dm/dm_example_28_11.png">

    <br>

6. 다음으로 빈도 수가 낮은 문자는 $g$ 와 $o/z/u/b$ 서브트리이다.

    - $g$ 의 빈도 수가 더 낮으므로 왼쪽 노드에 위치시키고 $o/z/u/b$ 서브트리는 오른쪽 서브트리로 한다.
    
    <img src = "/assets/images/Math/dm/dm_example_28_12.png" width=500>
    <img src = "/assets/images/Math/dm/dm_example_28_13.png">

    <br>

7. 다음으로 빈도 수가 낮은 문자는 $l$ 과 $e/j/s$ 서브트리이다.

    - $l$ 의 빈도 수가 더 낮으므로 $l$ 을 왼쪽 노드에 위치시키고, $e/j/s$ 서브트리를 오른쪽 서브트리로 한다.
    
    <img src = "/assets/images/Math/dm/dm_example_28_14.png" width=500>
    <img src = "/assets/images/Math/dm/dm_example_28_15.png">

    <br>

8. 이제 두 서브트리를 하나의 루트노드로 연결한다.
    
    <img src = "/assets/images/Math/dm/dm_example_28_16.png">

    <br>

9. 각 서브트리마다 왼쪽 노드를 $0$ 을, 오른쪽 노드는 $1$ 을 부여한다.

    <img src = "/assets/images/Math/dm/dm_example_28_17.png">

    <br>

10. 9번의 결과를 이용해 각 문자에 코드를 부여한다.

    - 이러한 원리로 각 문자에 부여된 코드를 허프만 코드라고 하고 결과는 다음과 같다.

    <img src = "/assets/images/Math/dm/dm_example_28_18.png">

    <br>

- 앞에서 압축 전에 주어진 빈도 수대로 메모리에 저장하면 $770$ 비트를 차지하는 것을 확인했다.

- 허프만 알고리즘을 이용해 구한 허프만 코드로 저장할 때 치지하는 메모리 공간은 거의 반으로 줄어든다.

    <img src = "/assets/images/Math/dm/dm_example_28_19.png">

    <br>

- 그러면 위에서 구한 허프만 코드를 이용해 문자열 $jguejozglbszesu$ 를 코드로 작성해보면 다음과 같다.

    - $1101000101110011010100001000100100111110100111001110101$

    <br>
    
- 또한 허프만 코드만 주어질 경우 어떤 문자열로 구성되는지도 허프만 코드표를 참고하며 문자를 찾을 수 있다.

