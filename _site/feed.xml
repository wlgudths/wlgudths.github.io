<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.9.3">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2024-08-29T13:31:43+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">느려도 괜찮아</title><author><name>지지형</name></author><entry><title type="html">Test</title><link href="http://localhost:4000/ai-tech/AITECH_01/" rel="alternate" type="text/html" title="Test" /><published>2024-08-29T00:00:00+09:00</published><updated>2024-08-29T00:00:00+09:00</updated><id>http://localhost:4000/ai-tech/AITECH_01</id><content type="html" xml:base="http://localhost:4000/ai-tech/AITECH_01/"><![CDATA[<p>테스트</p>]]></content><author><name>지지형</name></author><category term="AI-Tech" /><summary type="html"><![CDATA[테스트]]></summary></entry><entry><title type="html">[선형대수] 3강</title><link href="http://localhost:4000/linear%20algebra/LA_03/" rel="alternate" type="text/html" title="[선형대수] 3강" /><published>2024-08-28T00:00:00+09:00</published><updated>2024-08-28T00:00:00+09:00</updated><id>http://localhost:4000/linear%20algebra/LA_03</id><content type="html" xml:base="http://localhost:4000/linear%20algebra/LA_03/"><![CDATA[<h1 id="전치transpose">전치(Transpose)</h1>

<ul>
  <li>전치의 개념은 이전에 정리했던 <a href="https://wlgudths.github.io/discrete%20mathematics/DM-08/#%EC%A0%84%EC%B9%98%ED%96%89%EB%A0%AC-transpose-matrix--at">행렬의 종류</a>에서 볼 수 있습니다.</li>
</ul>

<p><br /></p>

<h2 id="전치행렬의-성질">전치행렬의 성질</h2>

<p><img src="/assets/images/Math/la/la_17.png" width="300" height="300" /></p>]]></content><author><name>지지형</name></author><category term="Linear Algebra" /><summary type="html"><![CDATA[전치(Transpose)]]></summary></entry><entry><title type="html">[선형대수] 2강</title><link href="http://localhost:4000/linear%20algebra/LA_02/" rel="alternate" type="text/html" title="[선형대수] 2강" /><published>2024-08-28T00:00:00+09:00</published><updated>2024-08-28T00:00:00+09:00</updated><id>http://localhost:4000/linear%20algebra/LA_02</id><content type="html" xml:base="http://localhost:4000/linear%20algebra/LA_02/"><![CDATA[<h1 id="벡터란">벡터란?</h1>

<ul>
  <li>
    <p>크기와 방향을 가진 양으로 정의할 수 있습니다.</p>
  </li>
  <li>
    <p>좌표평면의 예시</p>

    <p><img src="/assets/images/Math/la/la_11.png" width="300" height="300" /></p>
  </li>
</ul>

<p><br /></p>

<h2 id="벡터의-크기와-방향">벡터의 크기와 방향</h2>

<p><img src="/assets/images/Math/la/la_12.png" width="400" height="400" /></p>

<p><br /></p>

<ul>
  <li>
    <p>$x, y$ 를 보면 무엇인가 떠오르지 않나요?</p>

    <ul>
      <li>
        <p>벡터의 크기는 피타고라스의 정리를 이용하여 구할 수 있습니다.</p>
      </li>
      <li>
        <p>크기 $= \sqrt{x^{2} + y^{2}}$</p>
      </li>
    </ul>
  </li>
</ul>

<p><br /></p>

<ul>
  <li>
    <p>좌표평면을 보시면 초록색 $\theta$(각도)가 있습니다.</p>
  </li>
  <li>
    <p>저희는 각도를 이용하여 방향을 구할 수도 있습니다.</p>
  </li>
  <li>
    <p>즉, 벡터가 $x$축과 이루는 각도 $\theta$는 삼각함수를 사용하여 구할 수 있습니다.</p>

    <p><img src="/assets/images/Math/la/la_12.png" width="300" height="200" /></p>

    <ul>
      <li>$tan$ 활용 $\rightarrow$ $\theta$에 대하여 식 정리</li>
    </ul>

    <p><img src="/assets/images/Math/la/la_13.png" width="300" height="200" /></p>
  </li>
</ul>

<p><br /></p>

<h2 id="벡터의-덧셈-뺄셈-스칼라배">벡터의 덧셈, 뺄셈, 스칼라배</h2>

<blockquote>
  <p>각 요소를 덧셈, 뺄셈, 스칼라배를 해주면 된다.</p>
</blockquote>

<h3 id="시각화-덧셈">시각화 (덧셈)</h3>

<p><img src="/assets/images/Math/la/la_14.png" width="300" height="300" /></p>

<p><img src="/assets/images/Math/la/la_15.png" width="300" height="300" /></p>

<p><br /></p>

<h3 id="중요한-사실">중요한 사실</h3>

<blockquote>
  <p>벡터의 연산을 활용하여 2차원 평면에 놓이는 벡터를 다 표현할 수 있다.</p>
</blockquote>

<p><img src="/assets/images/Math/la/la_16.png" width="300" height="200" /></p>]]></content><author><name>지지형</name></author><category term="Linear Algebra" /><summary type="html"><![CDATA[벡터란?]]></summary></entry><entry><title type="html">[선형대수] 4강</title><link href="http://localhost:4000/linear%20algebra/LA_04/" rel="alternate" type="text/html" title="[선형대수] 4강" /><published>2024-08-28T00:00:00+09:00</published><updated>2024-08-28T00:00:00+09:00</updated><id>http://localhost:4000/linear%20algebra/LA_04</id><content type="html" xml:base="http://localhost:4000/linear%20algebra/LA_04/"><![CDATA[<h1 id="내적-dot-product">내적 (Dot Product)</h1>

<ul>
  <li>벡터 표기를 대문자로 하였지만, 소문자 볼드체로 생각하시면 되겠습니다. 😭</li>
</ul>

<h2 id="inner-product-dot-product">Inner Product, Dot Product</h2>

<ul>
  <li>
    <p>Inner Product가 더 일반적인 개념입니다.</p>
  </li>
  <li>
    <p>Dot Product는 Scalar Product, 점곱이라고 불립니다.</p>
  </li>
  <li>
    <p>일반적으로 유클리드 공간에서 실수 벡터의 내적을 지칭합니다.</p>
  </li>
</ul>

<p><img src="/assets/images/Math/la/la_25.png" width="300" height="300" /></p>

<p><br /></p>

<h3 id="whats-내적">What’s 내적</h3>

<ul>
  <li>
    <p>두 벡터가 얼마나 닮았나!?</p>
  </li>
  <li>
    <p>다시 말해, $B$ 벡터가 $A$ 벡터의 방향이 얼마나 유사한가? 를 알아보는 것입니다.</p>
  </li>
</ul>

<p><img src="/assets/images/Math/la/la_19.png" width="300" height="300" /></p>

<p><br /></p>

<h3 id="내적은-어떻게-구할-수-있을까">내적은 어떻게 구할 수 있을까?</h3>

<ul>
  <li>각 요소를 곱하고 더해주면 됩니다.</li>
</ul>

<p><img src="/assets/images/Math/la/la_20.png" width="300" height="300" /> <img src="/assets/images/Math/la/la_21.png" width="300" height="300" /></p>

<p><br /></p>

<ul>
  <li>
    <p>해당 식을 일반화 시키면 다음과 같이 표현할 수 있습니다.</p>

    <ul>
      <li>$AB = \sum_{k=1}^{n}{A_{k}B_{k}}$</li>
    </ul>
  </li>
  <li>
    <p>또한 내적은 이렇게 표현할 수도 있습니다.</p>

    <ul>
      <li>
        <p>$||A||||B||\cos{\theta}$</p>
      </li>
      <li>
        <p>$||A||$ : 절대값과 구분 짓는 벡터의 크기 표기법</p>
      </li>
    </ul>
  </li>
</ul>

<p><br /></p>

<h3 id="내적은-정사영이다">내적은 정사영이다</h3>

<p><img src="/assets/images/Math/la/la_22.png" width="300" height="300" /></p>

<p><img src="/assets/images/Math/la/la_23.png" width="300" height="300" /></p>

<p><br /></p>

<h2 id="코사인-유사도">코사인 유사도</h2>

<blockquote>
  <p>서로 다른 벡터가 얼마나 비슷한 방향을 가르키고 있는지 가늠하는 지표로 활용됩니다.</p>
</blockquote>

<p><img src="/assets/images/Math/la/la_24.png" width="300" height="300" /></p>

<p><br /></p>

<ul>
  <li>$\theta$를 구하려면 $arccos(x)$ 함수(아크코사인)를 사용하면 됩니다.</li>
</ul>

<p><br /></p>

<table>
  <thead>
    <tr>
      <th>$\theta$</th>
      <th>벡터 $A$ 와 $B$의 관계</th>
      <th>내적 값</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>$0$도</td>
      <td>두 벡터의 방향이 완전히 일치</td>
      <td>최댓값</td>
    </tr>
    <tr>
      <td>$90$도</td>
      <td>두 벡터가 직교인 상태</td>
      <td>$0$</td>
    </tr>
    <tr>
      <td>$180$도</td>
      <td>두 벡터의 방향이 완전히 반대인 상태</td>
      <td>최솟값</td>
    </tr>
  </tbody>
</table>

<p><br /></p>

<h3 id="시각화">시각화</h3>

<ul>
  <li>
    <p>$0$도</p>

    <p><img src="/assets/images/Math/la/la_26.png" width="300" height="300" /></p>
  </li>
  <li>
    <p>$90$도</p>

    <p><img src="/assets/images/Math/la/la_27.png" width="300" height="300" /></p>
  </li>
  <li>
    <p>$180$도</p>

    <p><img src="/assets/images/Math/la/la_28.png" width="300" height="300" /></p>
  </li>
</ul>

<p><br /></p>

<h1 id="결론">결론</h1>

<ul>
  <li>
    <p>벡터는 방향과 크기를 가진 양으로 정의할 수 있습니다.</p>
  </li>
  <li>
    <p>내적의 결과로 나오는 스칼라 값은 두 벡터의 방향과 크기에 대한 정보를 종합적으로 나타냅니다.</p>
  </li>
</ul>]]></content><author><name>지지형</name></author><category term="Linear Algebra" /><summary type="html"><![CDATA[내적 (Dot Product)]]></summary></entry><entry><title type="html">[백준] 2164 : 카드2 (파이썬)</title><link href="http://localhost:4000/boj/BOJ-2164/" rel="alternate" type="text/html" title="[백준] 2164 : 카드2 (파이썬)" /><published>2024-08-26T00:00:00+09:00</published><updated>2024-08-26T00:00:00+09:00</updated><id>http://localhost:4000/boj/BOJ-2164</id><content type="html" xml:base="http://localhost:4000/boj/BOJ-2164/"><![CDATA[<h1 id="-난이도">🔎 난이도</h1>
<blockquote>
  <p>⚪️ <strong>실버 4</strong></p>
</blockquote>

<h1 id="️-문제">✏️ 문제</h1>
<blockquote>
  <p><a href="https://www.acmicpc.net/problem/2164">https://www.acmicpc.net/problem/2164</a></p>
</blockquote>

<p><img src="/assets/images/Coding_test/Boj/BOJ_2164_1.png" />
<br /></p>

<h1 id="-예제-입력-및-출력">🤖 예제 입력 및 출력</h1>

<p><img src="/assets/images/Coding_test/Boj/BOJ_2164_2.png" /></p>

<p><br /></p>

<h1 id="-알고리즘-분류">📑 알고리즘 분류</h1>

<ul>
  <li>자료 구조</li>
  <li>큐</li>
</ul>

<p><br /></p>

<h1 id="-풀이">🧐 풀이</h1>

<ul>
  <li>
    <p>문제에서 주어진 조건을 <strong>deque</strong>를 활용하여 착실하게 풀었다.</p>

    <ol>
      <li>
        <p>먼저 $q$ 에 range 함수를 이용해 $1$ 부터 $N$ 까지의 숫자를 초기화했습니다.</p>
      </li>
      <li>
        <p>q에 요소가 하나 남을 때까지 반복하며 조건을 수행했습니다.</p>
      </li>
      <li>
        <p>popleft 를 이용하여 맨 위 숫자 카드를 버립니다.</p>
      </li>
      <li>
        <p>다음 append와 popleft 를 이용하여 다음 맨 위의 카드를 제일 아래로 옮깁니다.</p>
      </li>
    </ol>
  </li>
  <li>
    <p>시간복잡도 : $O(N)$</p>
  </li>
</ul>

<p><br /></p>

<h1 id="-내-풀이">📝 내 풀이</h1>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">deque</span>

<span class="n">n</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">input</span><span class="p">())</span>

<span class="n">q</span> <span class="o">=</span> <span class="n">deque</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>

<span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">q</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
    <span class="c1"># 맨 위의 카드 버리기
</span>    <span class="n">q</span><span class="p">.</span><span class="n">popleft</span><span class="p">()</span>
    <span class="c1"># 제일 위에 있는 카드 아래로 옮기기
</span>    <span class="n">q</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">q</span><span class="p">.</span><span class="n">popleft</span><span class="p">())</span>

<span class="k">print</span><span class="p">(</span><span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
</code></pre></div></div>

<p><br /></p>

<h1 id="-다른-사람-풀이">😳 다른 사람 풀이</h1>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># O(logn)
</span><span class="n">n</span><span class="p">,</span> <span class="n">m</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">input</span><span class="p">()),</span> <span class="mi">1</span>
<span class="k">while</span> <span class="n">m</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">:</span>  
    <span class="n">m</span> <span class="o">*=</span> <span class="mi">2</span>
<span class="k">print</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">n</span> <span class="o">-</span> <span class="n">m</span><span class="p">)</span>
</code></pre></div></div>

<ul>
  <li>
    <p>문제의 패턴을 분석하여 최적화된 방식으로 해결했다.</p>
  </li>
  <li>
    <p>2의 거듭제곱을 활용하여 시간복잡도가 $O(logN)$ 으로 줄일 수 있다.</p>
  </li>
</ul>]]></content><author><name>지지형</name></author><category term="BOJ" /><summary type="html"><![CDATA[🔎 난이도 ⚪️ 실버 4]]></summary></entry><entry><title type="html">[백준] 11404 : 플로이드 (파이썬)</title><link href="http://localhost:4000/boj/BOJ-11404/" rel="alternate" type="text/html" title="[백준] 11404 : 플로이드 (파이썬)" /><published>2024-08-26T00:00:00+09:00</published><updated>2024-08-26T00:00:00+09:00</updated><id>http://localhost:4000/boj/BOJ-11404</id><content type="html" xml:base="http://localhost:4000/boj/BOJ-11404/"><![CDATA[<h1 id="-난이도">🔎 난이도</h1>
<blockquote>
  <p>🟡 <strong>골드 4</strong></p>
</blockquote>

<h1 id="️-문제">✏️ 문제</h1>
<blockquote>
  <p><a href="https://www.acmicpc.net/problem/11404">https://www.acmicpc.net/problem/11404</a></p>
</blockquote>

<p><img src="/assets/images/Coding_test/Boj/BOJ_11404_1.png" />
<br /></p>

<h1 id="-예제-입력-및-출력">🤖 예제 입력 및 출력</h1>

<p><img src="/assets/images/Coding_test/Boj/BOJ_11404_2.png" /></p>

<p><br /></p>

<h1 id="-알고리즘-분류">📑 알고리즘 분류</h1>

<ul>
  <li>그래프 이론</li>
  <li>최단 경로</li>
  <li>프로이드-워셜</li>
</ul>

<p><br /></p>

<h1 id="-풀이">🧐 풀이</h1>

<ul>
  <li><span style="background-color:#fff5b1"> 이것이 코딩테스트다 with 파이썬 </span> 책을 참고하여 문제를 풀었습니다.</li>
</ul>

<h2 id="입력">입력</h2>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># 무한을 의미하는 값으로 10억을 설정
</span><span class="n">INF</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="mf">1e9</span><span class="p">)</span>

<span class="c1"># 노드의 개수(도시) 및 간선의 개수(버스)를 입력받기
</span><span class="n">n</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">input</span><span class="p">())</span>
<span class="n">m</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">input</span><span class="p">())</span>
</code></pre></div></div>

<ul>
  <li>버스 비용 $c$ 와 비교할 무한대 값입니다.
    <ul>
      <li>비용 ($c$) 의 최대값이 $100,000$ 이므로 $100,000$ 보다 큰 수로만 설정하면 됩니다.</li>
    </ul>
  </li>
  <li>다음 도시의 개수와 버스의 개수 입력을 받습니다.</li>
</ul>

<h2 id="그래프-초기화">그래프 초기화</h2>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># 2차원 리스트(그래프 표현)를 만들고, 모든 값을 무한으로 초기화
</span><span class="n">graph</span> <span class="o">=</span> <span class="p">[[</span><span class="n">INF</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span>

<span class="c1"># 자기 자신에서 자기 자신으로 가는 비용은 0으로 초기화
</span><span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">row</span> <span class="o">==</span> <span class="n">col</span><span class="p">:</span> <span class="n">graph</span><span class="p">[</span><span class="n">row</span><span class="p">][</span><span class="n">col</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

<span class="c1"># 각 간선에 대한 정보를 입력받아, 그 값으로 초기화
</span><span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">m</span><span class="p">):</span>
    <span class="c1"># A도시에서 B도시로 가는 비용 C라고 설정
</span>    <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">input</span><span class="p">().</span><span class="n">split</span><span class="p">())</span>
    <span class="c1"># 시작 도시와 도착 도시를 연결하는 노선은 하나가 아닐 수 있다.
</span>    <span class="n">graph</span><span class="p">[</span><span class="n">a</span><span class="p">][</span><span class="n">b</span><span class="p">]</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">graph</span><span class="p">[</span><span class="n">a</span><span class="p">][</span><span class="n">b</span><span class="p">],</span> <span class="n">c</span><span class="p">)</span> <span class="c1"># 비용이 더 낮은 것을 선택
</span></code></pre></div></div>

<ul>
  <li>
    <p>모든 도시의 쌍 (A, B) 에 대해서 2차원 리스트로 만들고, 모든 값을 무한으로 초기화합니다.</p>

    <p><img src="/assets/images/Coding_test/Boj/BOJ_11404_3.png" width="400" height="400" /></p>
  </li>
  <li>
    <p>같은 도시 $A \rightarrow A$ 로 가는 비용은 $0$ 으로 초기화합니다.</p>

    <p><img src="/assets/images/Coding_test/Boj/BOJ_11404_4.png" width="400" height="400" /></p>
  </li>
  <li>각 간선 ($A \rightarrow B$) 에 대한 정보를 입력받아, 그 값(비용)으로 초기화합니다.
    <ul>
      <li>A : a(row) , B : b(col), 비용 : c 으로 설정</li>
    </ul>
  </li>
  <li>그리고 시작 도시와 도착 도시를 연결하는 노선이 하나가 아닐 수 있기에 더 적은 비용을 선택합니다.
    <ul>
      <li>도시 $1$ 에서 도시 $4$ 로 가는 비용 $1, 2$ 가 존재하여 비용 $1$ 를 선택</li>
    </ul>

    <p><img src="/assets/images/Coding_test/Boj/BOJ_11404_5.png" width="400" height="400" /></p>
  </li>
</ul>

<h2 id="플로이드-워셜-알고리즘-수행">플로이드-워셜 알고리즘 수행</h2>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># 플로이드 워셜 알고리즘 수행
</span><span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">graph</span><span class="p">[</span><span class="n">a</span><span class="p">][</span><span class="n">b</span><span class="p">]</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">graph</span><span class="p">[</span><span class="n">a</span><span class="p">][</span><span class="n">b</span><span class="p">],</span> <span class="n">graph</span><span class="p">[</span><span class="n">a</span><span class="p">][</span><span class="n">k</span><span class="p">]</span> <span class="o">+</span> <span class="n">graph</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">b</span><span class="p">])</span>
</code></pre></div></div>

<ul>
  <li>
    <p>해당 코드는 목적지는 같지만, 직통 버스와 환승 버스 중 더 비용이 적은(빠른) 것을 선택한다.</p>

    <p><img src="/assets/images/Coding_test/Boj/BOJ_11404_6.png" width="400" height="400" /></p>

    <ul>
      <li>위 그래프와 같이 1번 도시는 3번에서 환승해서 5번 도시로 가는 것이 비용이 더 적다.</li>
    </ul>

    <p><img src="/assets/images/Coding_test/Boj/BOJ_11404_7.png" width="400" height="400" /></p>
  </li>
  <li>
    <p>3중 반복문을 돌며 직통 버스와 환승 버스(k)를 비교하며 더 적은 비용으로 업데이트한다.</p>
  </li>
</ul>

<h2 id="출력">출력</h2>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># 결과물 출력
</span><span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
    
        <span class="c1"># 만약 갈 수 없는 경우(무한인 경우) 0을 출력
</span>        <span class="k">if</span> <span class="n">graph</span><span class="p">[</span><span class="n">row</span><span class="p">][</span><span class="n">col</span><span class="p">]</span> <span class="o">==</span> <span class="n">INF</span><span class="p">:</span>
            <span class="k">print</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s">" "</span><span class="p">)</span>
        <span class="c1"># 갈 수 있는 경우 비용 출력
</span>        <span class="k">else</span><span class="p">:</span>
            <span class="k">print</span><span class="p">(</span><span class="n">graph</span><span class="p">[</span><span class="n">row</span><span class="p">][</span><span class="n">col</span><span class="p">],</span> <span class="n">end</span><span class="o">=</span><span class="s">" "</span><span class="p">)</span>
    
    <span class="c1"># 행마다 출력
</span>    <span class="k">print</span><span class="p">()</span>
</code></pre></div></div>

<ul>
  <li>
    <p>i에서 j로 갈 수 없는 경우, 즉 해당 도시로 가는 버스가 없는 경우 그 값은 INF 다.</p>
  </li>
  <li>
    <p>문제의 요구대로 그 자리에는 0을 출력하고, 행(row) 마다 print()를 하며 줄 바꿈을 수행한다.</p>
  </li>
</ul>

<p><br /></p>

<h1 id="-전체-코드">📝 전체 코드</h1>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># 무한을 의미하는 값으로 10억을 설정
</span><span class="n">INF</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="mf">1e9</span><span class="p">)</span>

<span class="c1"># 노드의 개수(도시) 및 간선의 개수(버스)를 입력받기
</span><span class="n">n</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">input</span><span class="p">())</span>
<span class="n">m</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">input</span><span class="p">())</span>

<span class="c1"># 2차원 리스트(그래프 표현)를 만들고, 모든 값을 무한으로 초기화
</span><span class="n">graph</span> <span class="o">=</span> <span class="p">[[</span><span class="n">INF</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span>

<span class="c1"># 자기 자신에서 자기 자신으로 가는 비용은 0으로 초기화
</span><span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">row</span> <span class="o">==</span> <span class="n">col</span><span class="p">:</span> <span class="n">graph</span><span class="p">[</span><span class="n">row</span><span class="p">][</span><span class="n">col</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

<span class="c1"># 각 간선에 대한 정보를 입력받아, 그 값으로 초기화
</span><span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">m</span><span class="p">):</span>
    <span class="c1"># A도시에서 B도시로 가는 비용 C라고 설정
</span>    <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">input</span><span class="p">().</span><span class="n">split</span><span class="p">())</span>
    <span class="c1"># 시작 도시와 도착 도시를 연결하는 노선은 하나가 아닐 수 있다.
</span>    <span class="n">graph</span><span class="p">[</span><span class="n">a</span><span class="p">][</span><span class="n">b</span><span class="p">]</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">graph</span><span class="p">[</span><span class="n">a</span><span class="p">][</span><span class="n">b</span><span class="p">],</span> <span class="n">c</span><span class="p">)</span> <span class="c1"># 비용이 더 낮은 것을 선택
</span>
<span class="c1"># 플로이드 워셜 알고리즘 수행
</span><span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">graph</span><span class="p">[</span><span class="n">a</span><span class="p">][</span><span class="n">b</span><span class="p">]</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">graph</span><span class="p">[</span><span class="n">a</span><span class="p">][</span><span class="n">b</span><span class="p">],</span> <span class="n">graph</span><span class="p">[</span><span class="n">a</span><span class="p">][</span><span class="n">k</span><span class="p">]</span> <span class="o">+</span> <span class="n">graph</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">b</span><span class="p">])</span>

<span class="c1"># 결과물 출력
</span><span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
    
        <span class="c1"># 만약 갈 수 없는 경우(무한인 경우) 0을 출력
</span>        <span class="k">if</span> <span class="n">graph</span><span class="p">[</span><span class="n">row</span><span class="p">][</span><span class="n">col</span><span class="p">]</span> <span class="o">==</span> <span class="n">INF</span><span class="p">:</span>
            <span class="k">print</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s">" "</span><span class="p">)</span>
        <span class="c1"># 갈 수 있는 경우 비용 출력
</span>        <span class="k">else</span><span class="p">:</span>
            <span class="k">print</span><span class="p">(</span><span class="n">graph</span><span class="p">[</span><span class="n">row</span><span class="p">][</span><span class="n">col</span><span class="p">],</span> <span class="n">end</span><span class="o">=</span><span class="s">" "</span><span class="p">)</span>
    
    <span class="c1"># 행마다 출력
</span>    <span class="k">print</span><span class="p">()</span>
</code></pre></div></div>

<p><br /></p>

<h1 id="-리뷰">😳 리뷰</h1>

<ul>
  <li>
    <p>$O(N^3)$ 으로 $N$ 이 $500$ 정도 되었으면 시간 제한이 되었을 것이다.</p>
  </li>
  <li>
    <p>점화식 : $D_{ab} = min(D_{ab}, D_{ak} + D_{kb})$</p>
  </li>
  <li>
    <p>해당 문제는 플로이드 워셜 알고리즘으로 풀 수 있었지만, 다익스트라 알고리즘으로도 풀어봐야겠다.</p>
  </li>
</ul>]]></content><author><name>지지형</name></author><category term="BOJ" /><summary type="html"><![CDATA[🔎 난이도 🟡 골드 4]]></summary></entry><entry><title type="html">[선형대수] 1강</title><link href="http://localhost:4000/linear%20algebra/LA_01/" rel="alternate" type="text/html" title="[선형대수] 1강" /><published>2024-08-24T00:00:00+09:00</published><updated>2024-08-24T00:00:00+09:00</updated><id>http://localhost:4000/linear%20algebra/LA_01</id><content type="html" xml:base="http://localhost:4000/linear%20algebra/LA_01/"><![CDATA[<p><a href="https://www.youtube.com/watch?v=7vV2SF8DyQE&amp;list=PL_iJu012NOxdZDxoGsYidMf2_bERIQaP0&amp;index=1">유튜브 링크</a></p>

<h1 id="선형대수학">선형대수학</h1>

<blockquote>
  <p>벡터 공간, 벡터, 선형 변환, 행렬, 연립 선형 방정식 등을 연구하는 대수학의 한 분야이다.</p>
  <ul>
    <li><a href="https://ko.wikipedia.org/wiki/%EC%84%A0%ED%98%95%EB%8C%80%EC%88%98%ED%95%99">출처 : 위키피디아</a></li>
  </ul>
</blockquote>

<p><br /></p>

<ul>
  <li>
    <p>선형대수학에서는 행렬과 벡터를 사용하여 선형 방정식을 해결합니다.</p>
  </li>
  <li>
    <p>결론적으로는 연립일차방정식을 푸는 것을 목표로 합니다.</p>

    <p><img src="/assets/images/Math/la/la_01.png" width="300" height="300" /></p>
  </li>
</ul>

<p><br /></p>

<ul>
  <li>
    <p>위 방정식을 행렬과 벡터로 표기하면 다음과 같습니다.</p>

    <p><img src="/assets/images/Math/la/la_02.png" width="300" height="300" /></p>
  </li>
</ul>

<p><br /></p>

<h2 id="행렬과-벡터의-성분-내부-표기-방법">행렬과 벡터의 성분, 내부 표기 방법</h2>

<h3 id="행렬">행렬</h3>

<ul>
  <li>
    <p>먼저 Matrix를 살펴보면 행렬은 행과 열, $(2 \times 2)$ 로 구성됩니다.</p>

    <p><img src="/assets/images/Math/la/la_03.png" width="300" height="300" /></p>

    <ul>
      <li>
        <p>행 : Row</p>
      </li>
      <li>
        <p>열 : Column</p>
      </li>
    </ul>
  </li>
  <li>
    <p>행렬의 구성요소는 다음과 같습니다.</p>

    <p><img src="/assets/images/Math/la/la_04.png" width="300" height="300" /></p>
  </li>
  <li>
    <p><a href="https://wlgudths.github.io/discrete%20mathematics/DM-06/#%ED%96%89%EB%A0%AC%EC%9D%98-%ED%91%9C%ED%98%84">행렬의 표현</a></p>
  </li>
</ul>

<h3 id="벡터">벡터</h3>

<ul>
  <li>
    <p>가로로 쌓여있는 경우 행 벡터를 나타내고, 세로로 쌓여있는 경우 열 벡터라고 합니다.</p>

    <p><img src="/assets/images/Math/la/la_05.png" width="300" height="300" /> <img src="/assets/images/Math/la/la_06.png" width="300" height="300" /></p>
  </li>
</ul>

<p><br /></p>

<h2 id="행렬과-벡터의-곱셈">행렬과 벡터의 곱셈</h2>

<ul>
  <li>
    <p>우리는 행렬과 벡터로 표기한 연립일차방정식으로도 복귀할 수 있어야 한다.</p>
  </li>
  <li>
    <p>사실 행렬과 벡터 사이에는 점 하나가 숨어있다.</p>
  </li>
</ul>

<p><img src="/assets/images/Math/la/la_07.png" width="300" height="300" /></p>

<ul>
  <li>
    <p>행렬과 벡터의 곱셈을 통해 우리는 원래 식으로 돌아갈 수 있다.</p>

    <p><img src="/assets/images/Math/la/la_08.png" width="300" height="300" /> <img src="/assets/images/Math/la/la_09.png" width="300" height="300" /></p>

    <p><img src="/assets/images/Math/la/la_10.png" width="300" height="300" /></p>
  </li>
  <li>
    <p><a href="https://wlgudths.github.io/discrete%20mathematics/DM-07/">행렬의 연산</a></p>
  </li>
</ul>]]></content><author><name>지지형</name></author><category term="Linear Algebra" /><summary type="html"><![CDATA[유튜브 링크]]></summary></entry><entry><title type="html">[이산수학] 순열, 조합, 확률 : 05. 조합</title><link href="http://localhost:4000/discrete%20mathematics/DM-36/" rel="alternate" type="text/html" title="[이산수학] 순열, 조합, 확률 : 05. 조합" /><published>2024-02-26T00:00:00+09:00</published><updated>2024-02-26T00:00:00+09:00</updated><id>http://localhost:4000/discrete%20mathematics/DM-36</id><content type="html" xml:base="http://localhost:4000/discrete%20mathematics/DM-36/"><![CDATA[<h1 id="조합">조합</h1>

<p>순열의 경우 나열에 순서에 의미를 부여한다.</p>

<p>그래서 순열의 예에서 $123$ 과 $213$ 은 서로 다른 나열로 판단했다.</p>

<p>하지만 나열의 순서에 의미를 두지 않는다면 $123$ 과 $213$ 은 같은 나열이 된다.</p>

<blockquote>
  <p>이렇게 순서에 의미를 두지 않는 나열을 조합이라고 한다.</p>
</blockquote>

<p><br /></p>

<h2 id="정의--조합-combination--_n-mathrmc-_r">정의 : 조합 (combination : $_{n} \mathrm{C} _{r}$)</h2>

<blockquote>
  <p>서로 다른 $n$ 개의 원소 중 중복을 허락하지 않고 $r$ 개를 선택하여 순서에 의미를 두지 않고 나열한 것</p>
</blockquote>

<p align="center">$$조합의 수 : \ _{n} \mathrm{C} _{r} = \frac{_{n} \mathrm{P} _{r}}{r!} = \frac{n!}{r!(n - r)!}$$</p>

<p><br /></p>

<h3 id="예시">예시</h3>

<p>$1, 2, 3, 4$ 가 쓰여 있는 숫자 카드 $4$ 장의 예로 세 자릿수를 만드는 조합을 구해보자.</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">$1$</th>
      <th style="text-align: center">$2$</th>
      <th style="text-align: center">$3$</th>
      <th style="text-align: center">$4$</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">$123$</td>
      <td style="text-align: center">$124$</td>
      <td style="text-align: center">$134$</td>
      <td style="text-align: center">$234$</td>
    </tr>
    <tr>
      <td style="text-align: center">$132$</td>
      <td style="text-align: center">$142$</td>
      <td style="text-align: center">$143$</td>
      <td style="text-align: center">$243$</td>
    </tr>
    <tr>
      <td style="text-align: center">$213$</td>
      <td style="text-align: center">$214$</td>
      <td style="text-align: center">$314$</td>
      <td style="text-align: center">$324$</td>
    </tr>
    <tr>
      <td style="text-align: center">$231$</td>
      <td style="text-align: center">$241$</td>
      <td style="text-align: center">$341$</td>
      <td style="text-align: center">$342$</td>
    </tr>
    <tr>
      <td style="text-align: center">$312$</td>
      <td style="text-align: center">$412$</td>
      <td style="text-align: center">$413$</td>
      <td style="text-align: center">$423$</td>
    </tr>
    <tr>
      <td style="text-align: center">$321$</td>
      <td style="text-align: center">$421$</td>
      <td style="text-align: center">$431$</td>
      <td style="text-align: center">$432$</td>
    </tr>
  </tbody>
</table>

<p>위 표의 $1,2,3,4$ 로 정의되어 있는 세 자릿수 숫자는 같은 조합으로 정의한다.</p>

<p>예를 들어 $1$ 번에 해당하는 $123, \ 132, \ 213, \ 231, \ 312, \ 321$ 은 같은 조합으로 경우의 수는 $1$ 개이다.</p>

<p>그러므로 $1, 2, 3, 4$ 가 쓰여 있는 숫자 카드 $4$ 장으로 세 자릿수를 만드는 조합에 대한 경우의 수는 다음과 같다.</p>

<p align="center">$$\ _{4} \mathrm{C} _{3} = \frac{_{4} \mathrm{P} _{3}}{3!} = \frac{4 \times 3 \times 2 \times 1}{3 \times 2 \times 1} = 4 개$$</p>

<p><br /></p>

<h3 id="예제">예제</h3>

<ol>
  <li>회원이 $10$ 명 모임에서 직책을 구분하지 않고 $3$ 명으로 구성된 임원단을 뽑으려고 한다.<br />
가능한 임원단의 수는 몇 가지인가?</li>
</ol>

<ul>
  <li>직책을 구분하지 않으므로 $10$ 명 중 $3$ 명을 선택하는 경우의 수를 구한다.</li>
</ul>

<p><br /></p>

<p align="center">$$\therefore \ _{10} \mathrm{C} _{3} = \frac{_{10} \mathrm{P} _{3}}{3!} = \frac{10 \times 9 \times 8}{3 \times 2 \times 1} = 120 가지$$</p>

<p><br /></p>

<h2 id="정리--조합에-관한-공식">정리 : 조합에 관한 공식</h2>

<p align="center">$$_{n} \mathrm{C} _{r} = \frac{_{n} \mathrm{P} _{r}}{r!} = \frac{n!}{(n - r)!} \times \frac{1}{r!} = \frac{n!}{r!(n - r)!} = \frac{n!}{[n - (n - r)]!} \times \frac{1}{(n - r)!} = \frac{_{n} \mathrm{P} _{n - r}}{(n - r)!} = _{n} \mathrm{C} _{n - r}$$</p>

<p><br /></p>

<p align="center">$$_{n} \mathrm{C} _{0} = \frac{_{n} \mathrm{P} _{0}}{0!} = _{n} \mathrm{P} _{0} = \frac{n!}{(n - 0)!} = 1 = \frac{n!}{0!} \times \frac{1}{n!} = \frac{n!}{(n - n)!} \times \frac{1}{n!} = \frac{_{n} \mathrm{P} _{n}}{n!} = _{n} \mathrm{C} _{n}$$</p>

<p><br /></p>

<h3 id="예제-1">예제</h3>

<ul>
  <li>남자회원 $15$ 명, 여자회원 $10$ 명이 모인 동아리에서 대표자 그룹을 뽑으려고 한다.</li>
</ul>

<ol>
  <li>
    <p>남자 $3$ 명, 여자 $3$ 명이 뽑힐 경우는 몇 가지인가?</p>

    <ul>
      <li>남자회원이 $3$ 명이 뽑힐 경우와 여자회원이 $3$ 명 뽑힐 경우의 수를 곱의 법칙으로 연산한다.</li>
    </ul>

    <ol>
      <li>
        <p>남자회원 $15$ 명 중 $3$ 명이 뽑힐 경우의 수는 $_{15} \mathrm{C} _{3}$ 이다.</p>
      </li>
      <li>
        <p>여자회원 $10$ 명 중 $3$ 명이 뽑힐 경우의 수는 $_{10} \mathrm{C} _{3}$ 이다.</p>
      </li>
    </ol>

    <ul>
      <li>$_{15} \mathrm{C} _{3} \times _{10} \mathrm{C} _{3} = 455 \times 120 = 54600 가지$</li>
    </ul>

    <p><br /></p>
  </li>
  <li>
    <p>$5$ 명의 대표를 뽑았을 때, 남자회원 또는 여자회원이 적어도 $1$ 명 포함되는 경우는 몇 가지인가?</p>

    <ul>
      <li>모든 조합에서 대표자 그룹이 모두 여자이거나 모두 남자인 경우를 제외한다.</li>
    </ul>

    <ol>
      <li>
        <p>전체 $25$ 명으로 구성할 수 있는 대표자 그룹의 경우의 수는 $_{25} \mathrm{C} _{5}$ 이다.</p>
      </li>
      <li>
        <p>남자회원 $15$ 명 중 대표자 그룹으로 $5$ 명이 뽑힐 경우의 수는 $_{15} \mathrm{C} _{5}$ 이다.</p>
      </li>
      <li>
        <p>여자회원 $10$ 명 중 대표자 그룹으로 $5$ 명이 뽑힐 경우의 수는 $_{10} \mathrm{C} _{5}$ 이다.</p>
      </li>
    </ol>

    <ul>
      <li>$_{25} \mathrm{C} _{5} - _{15} \mathrm{C} _{5} - _{10} \mathrm{C} _{5} = 53130 - 3003 - 252 = 49875$</li>
    </ul>

    <p><br /></p>
  </li>
  <li>
    <p>$6$ 명의 대표를 뽑을 때, A 남자회원과 B 여자회원이 동시에 뽑힐 경우는 몇 가지인가?</p>

    <ul>
      <li>
        <p>$6$ 명 중 A 남자회원과 B 여자회원이 포함된 경우이므로 두 명을 제외한 나머지 $23$ 명 중 $4$ 명을 뽑는 조합을 구한다.</p>
      </li>
      <li>
        <p>$_{23} \mathrm{C} _{4} = 8855$</p>
      </li>
    </ul>
  </li>
</ol>

<p><br /></p>

<h2 id="정리--원소들을-그룹-짓는-조합-공식">정리 : 원소들을 그룹 짓는 조합 공식</h2>

<blockquote>
  <p>서로 다른 $n$ 개의 원소를 $p$ 개, $q$ 개, $\cdots$ , $r$ 개로 하여 $k$ 개의 그룹으로 나누는 방법의 수</p>
</blockquote>

<ul>
  <li>
    <p>$(p + q + \cdots + r = n)$</p>
  </li>
  <li>
    <p>$k$ 개의 각 그룹을 구성하는 원소의 수가 서로 다를 때 $\ (p \neq q \neq r \cdots \neq s)$</p>
  </li>
</ul>

<p align="center">$$_{n} \mathrm{C} _{p} \ \times \ _{n - p} \mathrm{C} _{q} \ \times \ \cdots \ \times \ _{r} \mathrm{C} _{r}$$</p>

<p><br /></p>

<ul>
  <li>$k$ 개의 그룹 중 $i$ 개의 그룹의 원소 수만 같을 때</li>
</ul>

<p align="center">$$_{n} \mathrm{C} _{p} \ \times \ _{n - p} \mathrm{C} _{q} \ \times \ \cdots \ \times \ _{r} \mathrm{C} _{r} \ \times \ \frac{1}{i!}$$</p>

<p><br /></p>

<ul>
  <li>$k$ 개의 각 그룹을 구성하는 원소의 수가 모두 같을 때 $\ (p = q = r = \cdots = s)$</li>
</ul>

<p align="center">$$_{n} \mathrm{C} _{p} \ \times \ _{n - p} \mathrm{C} _{q} \ \times \ \cdots \ \times \ _{r} \mathrm{C} _{r} \ \times \ \frac{1}{k!}$$</p>

<p><br /></p>

<h3 id="예제-2">예제</h3>

<p>학생이 $10$ 명 있을 때, 다음과 같이 나누는 경우의 수를 구하라.</p>

<blockquote>
  <p>$4$ 명, $3$ 명, $2$ 명, $1$ 명으로 나누는 경우</p>
</blockquote>

<ul>
  <li>$10$ 명에서 $4$ 명으로 한 그룹을 만들고, 남은 $6$ 명에서 $3$ 명, 남은 $3$ 명에서 $2$ 명, 남은 $1$ 명에서 $1$ 명의 그룹으로 만드는 경우다.</li>
</ul>

<p align="center">$$\therefore \ _{10} \mathrm{C} _{4} \ \times \ _{6} \mathrm{C} _{3} \ \times \  _{3} \mathrm{C} _{2} \ \times \  _{1} \mathrm{C} _{1} = 210 \times 20 \times 3 \times 1 = 12600 가지$$</p>

<p><br /></p>

<blockquote>
  <p>$3$ 명씩 두 그룹, $2$ 명씩 두 그룹으로 나누는 경우</p>
</blockquote>

<ul>
  <li>인원수가 같은 그룹은 각각 두 그룹(인원수 $3$ 명, 인원수 $2$ 명)이 있으므로 정리의 두 번째 식을 이용해 구한다.</li>
</ul>

<p align="center">$$\therefore \ _{10} \mathrm{C} _{3} \ \times \ _{7} \mathrm{C} _{3} \ \times \  _{4} \mathrm{C} _{2} \ \times \  _{2} \mathrm{C} _{2} \ \times \frac{1}{2!} \ \times \frac{1}{2!} = 120 \times 35 \times 6 \times 1 \times \frac{1}{2} \times \frac{1}{2} = 6300 가지$$</p>

<p><br /></p>

<blockquote>
  <p>$5$ 명씩 두 그룹으로 나누는 경우</p>
</blockquote>

<ul>
  <li>그룹마다 $5$ 명씩 같은 인원수를 포함하므로 정리 세 번째 식을 이용해 구한다.</li>
</ul>

<p align="center">$$\therefore \ _{10} \mathrm{C} _{5} \ \times \ _{5} \mathrm{C} _{5} \ \times  \frac{1}{2!} = 252 \times 1 \times \frac{1}{2} = 126 가지$$</p>

<p><br /></p>]]></content><author><name>지지형</name></author><category term="Discrete Mathematics" /><summary type="html"><![CDATA[조합]]></summary></entry><entry><title type="html">[이산수학] 순열, 조합, 확률 : 03. 중복순열</title><link href="http://localhost:4000/discrete%20mathematics/DM-34/" rel="alternate" type="text/html" title="[이산수학] 순열, 조합, 확률 : 03. 중복순열" /><published>2024-02-25T00:00:00+09:00</published><updated>2024-02-25T00:00:00+09:00</updated><id>http://localhost:4000/discrete%20mathematics/DM-34</id><content type="html" xml:base="http://localhost:4000/discrete%20mathematics/DM-34/"><![CDATA[<h1 id="중복순열">중복순열</h1>

<p>이전 장에서 다뤘던 순열의 경우 서로 다른 두 개의 원소를 순서에 의미를 두고 나열하는 것으로 한번 선택된 원소는 다시 선택하지 않는다.</p>

<p>그러나 선택했던 원소를 다시 선택하여 나열하는 방법도 있을 수 있다.</p>

<p>그러면 순열의 경우의 수도 달라질 것이다.</p>

<blockquote>
  <p>이러한 나열을 중복순열이라고 한다.</p>
</blockquote>

<p><br /></p>

<h2 id="정의--중복순열-permutation-with-repetition---_n-prod-_r">정의 : 중복순열 (permutation with repetition : $ _{n} \prod{} _{r}$)</h2>

<blockquote>
  <p>서로 다른 $n$ 개의 원소 중 $r$ 개를 중복을 허용하며 선택하여 순서대로 나열한 것</p>
</blockquote>

<ul>
  <li>중복순열의 수 : $_{n} \prod{} _{r} = n^{r} \quad (n \in N, \  0 \le r \le n)$</li>
</ul>

<p><br /></p>

<h3 id="예시">예시</h3>

<p>이전 장에서 예로 들었던 $1,2,3,4$ 가 쓰여 있는 4장의 숫자 카드의 예로 중복순열을 이해해보자.</p>

<p>순열은 이 $4$ 장의 카드들 중 서로 다른 숫자 카드 $3$ 장은 나열한 것이다.</p>

<p>중복순열은 ‘서로 다른’ 이라는 전제가 필요 없다.</p>

<p>이 $4$ 장의 숫자 카드들을 이용해 중복을 허용하며 만들 수 있는 세 자릿수가 몇개인가를 구해보면 다음과 같다.</p>

<p><img src="/assets/images/Math/dm/dm_example_34_01.png" width="500" /></p>

<p><br /></p>

<ul>
  <li>위 그림과 마찬가지로 $211$ ~ $244$, $\ 311$ ~ $344$, $\ 411$ ~ $444$ 를 선택할 수 있다.</li>
</ul>

<p>이 풀이를 통해 알 수 있듯이 중복을 허용하기 위해 백의 자리에서 선택했던 숫자 카드를<br />
다시 십의 자리의 선택 범위, 일의 자리의 선택 범위에도 포함시켜서 숫자들을 나열하여 중복순열의 결과를 얻는다.</p>

<p>그러면 세 자릿수의 각 자리에서 선택할 수 있는 원소의 수는 모두 $4$ 개이므로 이 중복순열의 경우의 수는 다음과 같다.</p>

<blockquote>
  <p>$4 \times 4 \times 4 = 4^{3} = _{4} \prod{} _{3} = 64$ 개</p>
</blockquote>

<p><br /></p>

<p>중복순열은 선택했던 원소를 다시 선택할 수 있기 때문에 원소의 수보다 더 많은 원소를 이용한 순열을 구할 수 있다.</p>

<p>예를 들어 $1,2,3,4$ 가 쓰여 있는 $4$ 장의 숫자 카드를 이용해 여섯 자리수를 만들 수도 있다.</p>

<p>십만 자리부터 일의 자리까지 $4$ 장의 카드를 모두 중복을 허용하며 사용할 수 있다.</p>

<p>숫자 카드 $4$ 장으로 만들 수 있는 여섯 자릿수에 대한 경우의 수는 다음과 같다.</p>

<ul>
  <li>$_{4} \prod{} _{6} = 4^{6} = 4096$ 가지</li>
</ul>

<p><br /></p>

<h3 id="예제">예제</h3>

<ol>
  <li>회원이 $10$ 명인 모임에서 임원단을 뽑으려고 한다.<br />
직책을 겸임할 수 있는 가정 하에<br />
회장, 부회장, 총무를 차례로 선출한다고 하면 가능한 임원단의 수는 몇 가지인가?</li>
</ol>

<ul>
  <li>
    <p>회장으로 선출될 수 있는 회원 수 : $10$ 명</p>
  </li>
  <li>
    <p>부회장으로 선출될 수 있는 회원 수 : $10$ 명</p>
  </li>
  <li>
    <p>총무로 선출될 수 있는 회원 수 : $10$ 명</p>

    <blockquote>
      <p>$_{10} \prod{} _{3} = 10^{3} = 1000$ 가지</p>
    </blockquote>
  </li>
</ul>]]></content><author><name>지지형</name></author><category term="Discrete Mathematics" /><summary type="html"><![CDATA[중복순열]]></summary></entry><entry><title type="html">[이산수학] 순열, 조합, 확률 : 04. 같은 원소를 나열하는 순열</title><link href="http://localhost:4000/discrete%20mathematics/DM-35/" rel="alternate" type="text/html" title="[이산수학] 순열, 조합, 확률 : 04. 같은 원소를 나열하는 순열" /><published>2024-02-25T00:00:00+09:00</published><updated>2024-02-25T00:00:00+09:00</updated><id>http://localhost:4000/discrete%20mathematics/DM-35</id><content type="html" xml:base="http://localhost:4000/discrete%20mathematics/DM-35/"><![CDATA[<h1 id="같은-원소를-나열하는-순열">같은 원소를 나열하는 순열</h1>

<p>순열과 중복순열은 숫자 카드나 단어를 구성하는 스펠링과 같은 순열의 대상이 되는 원소들이 모두 다르다는 전제가 있다.</p>

<p>그러나 순열의 대상이 되는 원소들이 같은 원소를 포함하는 경우도 있다.</p>

<ul>
  <li>
    <p>예를 들어, <strong>banana</strong> 라는 단어는 다음과 같이 구성되어있다.</p>

    <ul>
      <li>
        <p>$b \rightarrow 1$ 번</p>
      </li>
      <li>
        <p>$a \rightarrow 3$ 번</p>
      </li>
      <li>
        <p>$n \rightarrow 2$ 번</p>
      </li>
    </ul>
  </li>
</ul>

<p>이렇게 같은 문자들이 포함된 원소들을 이용해 순열을 구한다면 구한 순열 중에는 같은 단어들이 포함될 수 있다.</p>

<p>그러므로 순열의 대상에 같은 원소들이 포함되었을 때는 다음과 같이 순열을 구한다.</p>

<p><br /></p>

<h2 id="정의--같은-원소를-포함하는-집합에-대한-순열">정의 : 같은 원소를 포함하는 집합에 대한 순열</h2>

<blockquote>
  <p>$n$ 개의 원소 중에서 같은 원소들이 각각 $p$ 개, $q$ 개, $r$ 개, $\cdots$ , $s$ 개 있을 때, $n$ 개의 원소를 순서대로 나열한 것</p>
</blockquote>

<p align="center"> $$\frac{n!}{p! \times q! \times r! \times \ \cdots \ \times s!}$$ </p>

<p align="center"> $$(p + q + r + \cdots + s = n)$$ </p>

<p><br /></p>

<h3 id="예시">예시</h3>

<p>$6$ 장의 문자 카드에 각각 $b, a, a, a, n, n$ 가 쓰여져 있을 때 문자 카드 모두를 이용해 만들 수 있는 단어는 몇 개인지 구해보자.</p>

<p>문자 카드 중 $a$ 는 $3$ 장 이므로 $a1, a2, a3$ 로 구분할 수 있다.</p>

<p>또한 문자 카드 $n$ 도 마찬가지로 $2$ 장 이므로 $n1, n2$ 로 구분할 수 있다.</p>

<p>이렇게 구분한 $6$ 개의 원소에서 $6$ 개를 선택하여 나열하는 것이므로 $_{6} \mathrm{P} _{6} = 6!$ 로 구할 수 있다.</p>

<p><strong>그러나</strong> $a$ 를 $a1, a2, a3$ , $n$ 을 $n1, n2$ 로 구분은 했으나 $a1a2a3$, $\ a2a1a3$ 모두 $aaa$ 의 나열이 된다.</p>

<p>그러므로 6개의 원소를 나열한 경우의 수에서 $a1, a2, a3$ $\ 3$ 장의 카드를 나열하는 경우의 수와 $n1, n2$ 를 나열하는 경우의 수를 제외해야 한다.</p>

<p>즉, $ _{3} \mathrm{P} _{3} = 3!$ 과 $ _{2} \mathrm{P} _{2} = 2!$ 를 제외해야 한다.</p>

<p>그러므로 $6$ 장의 문자 카드에 각각 $b, a, a, a, n, n$ 를 모두 나열해 만들 수 있는 단어의 수는 다음과 같다.</p>

<p align="center"> $$\frac{6!}{3! \times 2! \times 1!} = 60 가지$$</p>

<p><br /></p>

<h3 id="예제">예제</h3>

<p>$10$ 장의 문자 카드에 $A$ 가 $4$ 장, $B$ 가 $3$ 장, $C$ 가 $2$ 장, $D$ 가 $1$ 장 있을 때,<br />
주어진 카드 $10$ 장을 모두 이용해 만들 수 있는 단어의 수를 구하라.</p>

<p align="center"> $$\frac{10!}{4! \times 3! \times 2! \times 1!} = \frac{10 \times 9 \times 8 \times 7 \times 6 \times 5 \times 4 \times 3 \times 2 \times 1}{4 \times 3 \times 2 \times 1 \times 3 \times 2 \times 1 \times 2 \times 1 \times 1} = 12600 개$$</p>

<p><br /></p>]]></content><author><name>지지형</name></author><category term="Discrete Mathematics" /><summary type="html"><![CDATA[같은 원소를 나열하는 순열]]></summary></entry></feed>