<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.9.3">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2023-10-20T21:11:56+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">느려도 괜찮아</title><author><name>지지형</name></author><entry><title type="html">[백준] 4673 : 셀프 넘버 (파이썬)</title><link href="http://localhost:4000/boj/BOJ-4673/" rel="alternate" type="text/html" title="[백준] 4673 : 셀프 넘버 (파이썬)" /><published>2023-10-20T00:00:00+09:00</published><updated>2023-10-20T00:00:00+09:00</updated><id>http://localhost:4000/boj/BOJ-4673</id><content type="html" xml:base="http://localhost:4000/boj/BOJ-4673/"><![CDATA[<h1 id="-난이도">🔎 난이도</h1>
<blockquote>
  <p>⚪️ <strong>실버 5</strong></p>
</blockquote>

<h1 id="️-문제">✏️ 문제</h1>
<blockquote>
  <p><a href="https://www.acmicpc.net/problem/4673">https://www.acmicpc.net/problem/4673</a></p>
</blockquote>

<p><img src="/assets/images/Coding_test/Boj/BOJ_4673_1.png" /></p>

<p><br /></p>

<h1 id="-예제-입력-및-출력">🤖 예제 입력 및 출력</h1>

<p><img src="/assets/images/Coding_test/Boj/BOJ_4673_2.png" /></p>

<p><br /></p>

<h1 id="-알고리즘-분류">📑 알고리즘 분류</h1>

<ul>
  <li>수학</li>
  <li>구현</li>
  <li>브루트포스 알고리즘</li>
</ul>

<p><br /></p>

<h1 id="-아이디어">🧐 아이디어</h1>

<blockquote>
  <p>10,000 보다 작거나 같은 <strong>셀프 넘버</strong> 를 출력하는 문제이다.</p>
  <ul>
    <li>생성자 : 양의 정수 $n$ 에 대해서 $n$ 과 $n$ 의 각 자리수를 더하는 함수라고 정의해보면 $d(75) = 75 + 7 + 5 = 87$
      <ul>
        <li>$75$ 는 $d(75) = 87$ 의 생성자이다.</li>
      </ul>
    </li>
    <li>셀프넘버 : 위의 경우처럼 생성자가 있는 것이 아니라 생성자가 없을 경우 셀프 넘버라고 한다.
      <ul>
        <li>각 자리수를 더하여 $31$ 을 만들 수 있는 숫자는 없기에, $31$ 은 셀프 넘버이다.</li>
      </ul>
    </li>
  </ul>
</blockquote>

<p><br /></p>

<h1 id="-내-풀이">📝 내 풀이</h1>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># 생성자 함수
</span><span class="k">def</span> <span class="nf">d</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">:</span> <span class="c1"># 한 자리 수일 경우
</span>        <span class="k">return</span> <span class="n">n</span> <span class="o">+</span> <span class="n">n</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">n</span> <span class="o">+</span> <span class="nb">sum</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">n</span><span class="p">)))</span> <span class="c1"># n과 각 자리수의 합 더하기
</span>
<span class="n">self_num</span> <span class="o">=</span> <span class="p">[</span><span class="bp">True</span><span class="p">]</span> <span class="o">*</span> <span class="mi">10001</span> <span class="c1"># 셀프넘버 리스트
</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">self_num</span><span class="p">)):</span> <span class="c1"># 1 ~ 10000
</span>    <span class="k">if</span> <span class="n">d</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">10000</span><span class="p">:</span> <span class="c1"># 10000보다 작거나 같을 경우
</span>        <span class="n">self_num</span><span class="p">[</span><span class="n">d</span><span class="p">(</span><span class="n">i</span><span class="p">)]</span> <span class="o">=</span> <span class="bp">False</span> <span class="c1"># 생성자일 경우 False 처리 (셀프넘버가 아닐 경우)
</span>
<span class="c1"># 출력
</span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">self_num</span><span class="p">)):</span>
    <span class="k">if</span> <span class="n">self_num</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="bp">True</span><span class="p">:</span> <span class="k">print</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="c1"># 셀프넘버(True)일 경우 출력
</span></code></pre></div></div>
<p><br /></p>

<h1 id="-풀이-리뷰">😳 풀이 리뷰</h1>
<blockquote>
  <p>위 아이디어에서 정리한 개념을 이해 한 후</p>
</blockquote>

<ol>
  <li>인덱스를 통해 문제를 풀어야겠다고 생각했다.</li>
  <li>True로 이루어진 10001개의 셀프넘버 리스트</li>
  <li>반복문을 통해 생성자가 있을 경우 False 처리를 해주는 함수 정의.</li>
  <li>셀프넘버 리스트 True로 남아있는 원소(셀프넘버)의 인덱스를 출력해줌으로써 문제를 해결하였다.</li>
</ol>]]></content><author><name>지지형</name></author><category term="BOJ" /><summary type="html"><![CDATA[🔎 난이도 ⚪️ 실버 5 ✏️ 문제 https://www.acmicpc.net/problem/4673 🤖 예제 입력 및 출력 📑 알고리즘 분류 수학 구현 브루트포스 알고리즘 🧐 아이디어 10,000 보다 작거나 같은 셀프 넘버 를 출력하는 문제이다. 생성자 : 양의 정수 $n$ 에 대해서 $n$ 과 $n$ 의 각 자리수를 더하는 함수라고 정의해보면 $d(75) = 75 + 7 + 5 = 87$ $75$ 는 $d(75) = 87$ 의 생성자이다. 셀프넘버 : 위의 경우처럼 생성자가 있는 것이 아니라 생성자가 없을 경우 셀프 넘버라고 한다. 각 자리수를 더하여 $31$ 을 만들 수 있는 숫자는 없기에, $31$ 은 셀프 넘버이다. 📝 내 풀이 # 생성자 함수 def d(n): if n &lt; 10: # 한 자리 수일 경우 return n + n else: return n + sum(map(int, str(n))) # n과 각 자리수의 합 더하기 self_num = [True] * 10001 # 셀프넘버 리스트 for i in range(1,len(self_num)): # 1 ~ 10000 if d(i) &lt;= 10000: # 10000보다 작거나 같을 경우 self_num[d(i)] = False # 생성자일 경우 False 처리 (셀프넘버가 아닐 경우) # 출력 for i in range(1,len(self_num)): if self_num[i] == True: print(i) # 셀프넘버(True)일 경우 출력 😳 풀이 리뷰 위 아이디어에서 정리한 개념을 이해 한 후 인덱스를 통해 문제를 풀어야겠다고 생각했다. True로 이루어진 10001개의 셀프넘버 리스트 반복문을 통해 생성자가 있을 경우 False 처리를 해주는 함수 정의. 셀프넘버 리스트 True로 남아있는 원소(셀프넘버)의 인덱스를 출력해줌으로써 문제를 해결하였다.]]></summary></entry><entry><title type="html">[백준] 7568 : 덩치 (파이썬)</title><link href="http://localhost:4000/boj/BOJ-7568/" rel="alternate" type="text/html" title="[백준] 7568 : 덩치 (파이썬)" /><published>2023-10-20T00:00:00+09:00</published><updated>2023-10-20T00:00:00+09:00</updated><id>http://localhost:4000/boj/BOJ-7568</id><content type="html" xml:base="http://localhost:4000/boj/BOJ-7568/"><![CDATA[<h1 id="-난이도">🔎 난이도</h1>
<blockquote>
  <p>⚪️ <strong>실버 5</strong></p>
</blockquote>

<h1 id="️-문제">✏️ 문제</h1>
<blockquote>
  <p><a href="https://www.acmicpc.net/problem/7568">https://www.acmicpc.net/problem/7568</a></p>
</blockquote>

<p><img src="/assets/images/Coding_test/Boj/BOJ_7568_1.png" />
<img src="/assets/images/Coding_test/Boj/BOJ_7568_2.png" />
<br /></p>

<h1 id="-예제-입력-및-출력">🤖 예제 입력 및 출력</h1>

<p><img src="/assets/images/Coding_test/Boj/BOJ_7568_3.png" /></p>

<p><br /></p>

<h1 id="-알고리즘-분류">📑 알고리즘 분류</h1>

<ul>
  <li>구현</li>
  <li>브루트포스 알고리즘</li>
</ul>

<p><br /></p>

<h1 id="-아이디어">🧐 아이디어</h1>

<blockquote>
  <p>처음에 다양한 정렬을 해보며 시도하였지만, 풀수가 없었다. 하지만 문제를 다시 살펴보니 문제 안에   답이 있었다.</p>
  <ul>
    <li>N명의 집단에서 각 사람의 덩치 등수는 자신보다 더 “큰 덩치”의 사람의 수로 정해진다.</li>
    <li>즉, 몸무게와 키 모두 큰 사람이 덩치 등수가 높다.</li>
    <li>만약 몸무게와 키 둘 중 하나만 큰 상태에서는 덩치 등수를 매길 수 없다.
      <ul>
        <li>같은 덩치 등수를 가진 사람은 여러명이다.</li>
      </ul>
    </li>
  </ul>
</blockquote>

<blockquote>
  <p>결론은 각 몸무게와 키를 비교하면 전체 사람의 덩치 등수를 구할 수 있다.</p>
</blockquote>

<p><br /></p>

<h1 id="-내-풀이">📝 내 풀이</h1>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># 입력
</span><span class="n">n</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">input</span><span class="p">())</span>

<span class="c1"># (몸무게, 덩체) 튜플 형식을 입력 받기
</span><span class="n">lst</span> <span class="o">=</span> <span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">input</span><span class="p">().</span><span class="n">split</span><span class="p">()))</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)]</span> 

<span class="c1"># print(lst) - [(55, 185), (58, 183), (88, 186), (60, 175), (46, 155)]
</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">lst</span><span class="p">:</span>
    <span class="n">rank</span> <span class="o">=</span> <span class="mi">1</span> <span class="c1"># 순위 초기화
</span>    <span class="n">w</span><span class="p">,</span><span class="n">h</span> <span class="o">=</span> <span class="n">i</span> <span class="c1"># 순위를 매길 몸무게와 키;
</span>    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">lst</span><span class="p">:</span>
        <span class="n">w1</span><span class="p">,</span> <span class="n">h1</span> <span class="o">=</span> <span class="n">j</span> <span class="c1"># 비교할 몸무게와 키
</span>
        <span class="c1"># 비교할 몸무게와 키가 모두 크다면, 즉 순위를 매길 몸무게가 더 작다면 순위 증가
</span>        <span class="k">if</span> <span class="n">w</span> <span class="o">&lt;</span> <span class="n">w1</span> <span class="ow">and</span> <span class="n">h</span> <span class="o">&lt;</span> <span class="n">h1</span><span class="p">:</span> 
            <span class="n">rank</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="k">print</span><span class="p">(</span><span class="n">rank</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s">' '</span><span class="p">)</span> <span class="c1"># 순위 이어서 출력하기
</span>
</code></pre></div></div>
<p><br /></p>

<h1 id="-풀이-리뷰">😳 풀이 리뷰</h1>

<blockquote>
  <p>이중 반복문을 통해 w,h에 순위를 매길 몸무게와 키를 w1, h1에는 비교할 몸무게와 키를 담고 비교하여 덩치 등수를 매겼다.</p>
</blockquote>]]></content><author><name>지지형</name></author><category term="BOJ" /><summary type="html"><![CDATA[🔎 난이도 ⚪️ 실버 5 ✏️ 문제 https://www.acmicpc.net/problem/7568 🤖 예제 입력 및 출력 📑 알고리즘 분류 구현 브루트포스 알고리즘 🧐 아이디어 처음에 다양한 정렬을 해보며 시도하였지만, 풀수가 없었다. 하지만 문제를 다시 살펴보니 문제 안에 답이 있었다. N명의 집단에서 각 사람의 덩치 등수는 자신보다 더 “큰 덩치”의 사람의 수로 정해진다. 즉, 몸무게와 키 모두 큰 사람이 덩치 등수가 높다. 만약 몸무게와 키 둘 중 하나만 큰 상태에서는 덩치 등수를 매길 수 없다. 같은 덩치 등수를 가진 사람은 여러명이다. 결론은 각 몸무게와 키를 비교하면 전체 사람의 덩치 등수를 구할 수 있다. 📝 내 풀이 # 입력 n = int(input()) # (몸무게, 덩체) 튜플 형식을 입력 받기 lst = [tuple(map(int, input().split())) for _ in range(n)] # print(lst) - [(55, 185), (58, 183), (88, 186), (60, 175), (46, 155)] for i in lst: rank = 1 # 순위 초기화 w,h = i # 순위를 매길 몸무게와 키; for j in lst: w1, h1 = j # 비교할 몸무게와 키 # 비교할 몸무게와 키가 모두 크다면, 즉 순위를 매길 몸무게가 더 작다면 순위 증가 if w &lt; w1 and h &lt; h1: rank += 1 print(rank, end=' ') # 순위 이어서 출력하기 😳 풀이 리뷰 이중 반복문을 통해 w,h에 순위를 매길 몸무게와 키를 w1, h1에는 비교할 몸무게와 키를 담고 비교하여 덩치 등수를 매겼다.]]></summary></entry><entry><title type="html">[이산수학] 증명(Proofs)</title><link href="http://localhost:4000/discrete%20mathematics/DM-04/" rel="alternate" type="text/html" title="[이산수학] 증명(Proofs)" /><published>2023-10-19T00:00:00+09:00</published><updated>2023-10-19T00:00:00+09:00</updated><id>http://localhost:4000/discrete%20mathematics/DM-04</id><content type="html" xml:base="http://localhost:4000/discrete%20mathematics/DM-04/"><![CDATA[<h1 id="증명proofs이란">증명(Proofs)이란?</h1>
<blockquote>
  <p>특정한 공리(Axiom)들을 가정하고, 그 가정 하에서 어떤 명제가 참이라는 것을 보여주는 것이다.</p>
</blockquote>

<hr />

<h1 id="증명관련-용어">증명관련 용어</h1>
<h2 id="정리-theorem">정리 (Theorem)</h2>
<blockquote>
  <p>정리란 공리와 정의를 통해 참(True)으로 증명된 명제이다.</p>
  <ul>
    <li>피타고라스의 정리 (Pythagorean theorem)</li>
  </ul>
</blockquote>

<h2 id="정의-definition">정의 (Definition)</h2>
<blockquote>
  <p>용어 또는 기호의 의미를 확실하게 규정한 문장이나 식, 용어의 뜻에 대한 약속</p>
  <ul>
    <li>삼각형 : 세 개의 선분으로 둘러싸인 다각형</li>
  </ul>
</blockquote>

<h2 id="공리-axiom">공리 (Axiom)</h2>
<blockquote>
  <p>증명이 불필요한 명제</p>
  <ul>
    <li>페아노의 공리 : 어떤 자연수에 대해서도, 그 수의 ‘다음’ 자연수(따름수)가 존재한다.
      <ul>
        <li>자연수 N에 대하여, N + 1 이 존재한다.</li>
      </ul>
    </li>
  </ul>
</blockquote>

<h2 id="가설-conjecture">가설 (Conjecture)</h2>
<blockquote>
  <p>증명되지는 않았지만 참으로 믿어지는 명제</p>
</blockquote>

<h2 id="이론-theory">이론 (Theory)</h2>
<blockquote>
  <p>공리(axiom)로부터 증명이 가능한 모든 정리(theorem)의 집합</p>
</blockquote>

<hr />

<h1 id="방법론">방법론</h1>

<h2 id="연역법deduction">연역법(deduction)</h2>
<blockquote>
  <p>주어진 사실(facts)들과 공리(axioms)들에 입각하여 추론(inference)을 통하여 새로운 사실을 도출하는 것</p>
</blockquote>

<ul>
  <li>예시(일반적)
    <ul>
      <li>모든 사람은 죽는다. 소크라테스는 사람이다. 그러므로 소크라테스는 죽는다.</li>
    </ul>
  </li>
</ul>

<h2 id="귀납법induction">귀납법(induction)</h2>
<blockquote>
  <p>관찰과 실험에 기반한 가설을 귀납 추론을 통하여 일반적인 규칙을 입증하는 것</p>
</blockquote>

<ul>
  <li>예시(일반적)
    <ul>
      <li>A새는 난다. B새도 난다. C새도 난다. 그러므로 모든 새는 날 수있다.</li>
    </ul>
  </li>
</ul>

<h2 id="수학적-귀납법">수학적 귀납법</h2>
<blockquote>
  <p>명제 $p_1, p_2, p_3, \cdots, p_n$ 이 참이라고 할 때, $p_n+1$의 경우에도 성립함을 보이면 된다.</p>
</blockquote>

<h3 id="수학적-귀납법-예시">수학적 귀납법 예시</h3>
<blockquote>
  <p>가우스 식</p>
  <ul>
    <li>$1 + 2 + 3 \cdots + n = \frac{n \times (n+1)}{2}$
      <ol>
        <li>$P(n) = \frac{n \times (n+1)}{2}$</li>
        <li>$P(1) = \frac{1 \times (1+1)}{2} = 1 \rightarrow True$ <br /></li>
        <li>귀납 가정 : $P(k) = \frac{k \times (k+1)}{2}$ ($n$이 $k$일 경우도 성립) <br /></li>
        <li>귀납 단계 : $P(k+1) = \frac{(k+1) \times (k+2)}{2}$  <br />
          <ul>
            <li>$P(k+1) = P(k) + (k+1)$  <br /><br />
   $= \frac{k \times (k+1)}{2} + (k+1)$  <br /><br />
   $= \frac{k^2 + k + 2k + 2}{2}$  <br /><br />
   $= \frac{k^2 + 3k + 2}{2}$  <br /><br />
   $= \frac{(k+1)(k+2)}{2}$</li>
          </ul>
        </li>
      </ol>
    </li>
  </ul>
</blockquote>

<h1 id="다양한-증명법">다양한 증명법</h1>

<h2 id="1직접-증명법-direct-proof">1.직접 증명법 (Direct Proof)</h2>
<blockquote>
  <p>주어진 명제를 참이라고 가정하고, 정리와 공리를 이용해서 명제가 참이 됨을 증명하는 방법이다.<br />
명제 $p \rightarrow q$ 의 직접증명은 논리적으로 $p$의 진리값이 참일 때 $q$도 참임을 보이는 증명 방법이다.</p>
</blockquote>

<h3 id="예시">예시</h3>
<blockquote>
  <p>두 홀수의 곱이 홀수임을 증명하라</p>
  <ul>
    <li>$p$ : 두 수 $a,b$은 홀수이다.</li>
    <li>$q$ : $a$ 와 $b$ 의 곱은 홀수이다.</li>
    <li>$p \rightarrow q$ : 두 홀수 $a,b$ 의 곱은 홀수이다.</li>
    <li>증명
      <ul>
        <li>두 정수 $k$ 와 $j$ 가 있을 때, 홀수 $a,b$ 는 각각 $a = 2k + 1, b = 2j + 1$ 로 표현할 수 있다.</li>
        <li>$a \times b = (2k + 1) \times (2j + 1) = 4kj + 2k + 2j + 1 = 2(2kj + k + j) + 1$</li>
        <li>$k$ 와 $j$ 는 정수이므로 $2kj + k + j$ 은 정수가되어 $2(2kj + k + j)$ 는 반드시 짝수가 되고, $2(2kj + k + j) + 1$ 은 반드시 홀수가 된다.</li>
        <li>따라서 두 홀수 $a,b$의 곱은 홀수이다 라는 명제는 참이 된다.</li>
      </ul>
    </li>
  </ul>
</blockquote>

<h2 id="2반례-증명법-proof-by-counter-example">2.반례 증명법 (Proof by Counter-example)</h2>
<blockquote>
  <p>$P(x)$ 가 명제함수라고 할 때, $\forall P(x)$ 중 단 하나의 값이라도 $P(x)$를 거짓으로 만드는 반례(counterexample)찾아서 명제가 거짓임을 증명하는 방법이다.</p>
</blockquote>

<h3 id="예시-1">예시</h3>
<blockquote>
  <p>모든 실수 $x$ 에 대하여 $x^2 &gt; 0$이 성립하는가?</p>
</blockquote>

<ul>
  <li>증명
    <ul>
      <li>$x = 0$ 이면 $x^2 = 0$ 이 되어, $x^2 &gt; 0$ 을 만족하지 않는다.</li>
      <li>따라서, 명제는 거짓이 되고, 반례는 $x = 0$이 된다.</li>
    </ul>
  </li>
</ul>

<h2 id="3모순-증명법-proof-by-contradiction">3.모순 증명법 (Proof by Contradiction)</h2>
<blockquote>
  <p>주어진 명제를 부정하면 모순(contradiction)이 된다는 것을 입증하는 방법이다.<br />
즉, 모순 증명법은 결론을 거짓이라고 가정할 경우, 모순이 도출되도록 하는 증명법이다.</p>
</blockquote>

<h3 id="예시-2">예시</h3>
<blockquote>
  <p>$\sqrt{2}$ 는 무리수이다.</p>
</blockquote>

<ul>
  <li>증명
    <ul>
      <li>$p : \sqrt{2}$ 이다.</li>
      <li>$\lnot p$ : $\sqrt{2}$ 는 무리수가 아니다. = $\sqrt{2}$ 는 유리수이다.</li>
      <li>유리수의 정의에 의하여 어떤 서로소인 정수 $a,b$가 존재하여 $\sqrt{2}$ = ${a}\over{b}$ 이다.</li>
      <li>양변에 $b$ 를 곱한 후 제곱을 하면 $2b^2 = a^2$ 이 된다.</li>
      <li>$a^2$ 이 2의 배수이므로 $a$ 는 짝수이다.</li>
      <li>$a$ 를 2로 나눈 몫을 $k$ 라고 하면, $a = 2k$ 가 되고 $2b^2 = a^2$ 에 대입하면 $2b^2 = 4k^2$ 이므로 $b^2 = 2k^2$이 되어 $b$ 도 2의 배수가 된다.</li>
      <li>$a$ 와 $b$ 는 서로소 이므로 둘이 동시에 2의 배수인 것은 가정에 모순이다.</li>
      <li>$\therefore$ $\sqrt{2}$ 는 무리수이다.</li>
    </ul>
  </li>
</ul>

<h2 id="4대우-증명법-contrapositive-proof">4.대우 증명법 (Contrapositive Proof)</h2>
<blockquote>
  <p>$p \rightarrow q$ 와 $\lnot p \rightarrow \lnot q$ 가 대우 관계 논리적 동치가 됨을 이용하여<br />
$p \rightarrow q$ 가 참이 되는 것을 간접적으로 보여주는 증명 방법이다.</p>
</blockquote>

<h3 id="예시-3">예시</h3>
<blockquote>
  <p>$3n + 2$ 가 홀수이면 $n$ 은 홀수이다.</p>
</blockquote>

<ul>
  <li>증명
    <ul>
      <li>$p : 3n + 2 = 2k + 1$</li>
      <li>$q : n = 2k’ + 1$</li>
      <li>대우 관계를 이용하여 $n$ 이 짝수이면 $3n + 2$ 도 짝수이다.</li>
      <li>$n = 2k$이면 $3n + 2 = 3(2k) + 2 = 2(3k + 1)$</li>
      <li>따라서, $n$ 이 짝수이면 $3n + 2$ 도 짝수이고, 대우관계에 의해 $3n + 2$ 가 홀수이면 $n$ 은 홀수이다.</li>
    </ul>
  </li>
</ul>

<h2 id="5동치-증명법-필요충분조건-증명법-if-and-only-if-proof">5.동치 증명법, 필요충분조건 증명법 (if and only if proof)</h2>
<blockquote>
  <p>$p \leftrightarrow q$ 를 증명하기 위해 $p \rightarrow q$ 와 $q \rightarrow p$ 두 가지를 증명하는 방법이다.</p>
</blockquote>

<h3 id="예시-4">예시</h3>
<blockquote>
  <p>$n$ 이 홀수이면 $n^2$ 은 홀수이다. ($p$ : $n$ 이 홀수이다. , $q$ : $n^2$ 은 홀수이다.)</p>
</blockquote>

<ul>
  <li>증명
    <ul>
      <li>$p \rightarrow q$ : $n$ 이 홀수이면 $n^2$ 은 홀수이다.
        <ul>
          <li>$n = 2k + 1$, $n^2 = 4k^2 + 4k + 1 = 2(2k^2 + 2k) + 1$ 이므로 $n^2$ 은 홀수이다.</li>
        </ul>
      </li>
      <li>$q \rightarrow p$ : $n^2$ 이 홀수이면 $n$ 은 홀수이다. (직접 증명이 어렵기 때문에 대우증명을 이용하여 증명)</li>
      <li>$\lnot q \rightarrow \lnot p$ : $n$ 이 짝수이면, $n^2$ 은 짝수이다.
        <ul>
          <li>$n = 2k$ 이면 $n^2 = 4k^2 = 2(2k^2)$ 이므로 $n^2$ 은 짝수이다.</li>
        </ul>
      </li>
      <li>$p \rightarrow q$ 는 직접증명법에 의해 참이고, $q \rightarrow p$ 는 대우증명법에 의해 참이므로<br />
  $\therefore q \leftrightarrow p$는  참이다.</li>
    </ul>
  </li>
</ul>

<h2 id="6존재-증명법-existence-proof">6.존재 증명법 (Existence Proof)</h2>
<blockquote>
  <p>$P(x)$ 라는 명제함수에서 $P(x)$ 가 참인 $x$ 가 적어도 하나가 존재한다는 것을 보이는 증명 방법이다.</p>
</blockquote>

<h3 id="예시-5">예시</h3>
<blockquote>
  <p>$x^2 + y^2 = z^2$ 인 정수 $x,y,z$ 가 존재함을 보여라</p>
</blockquote>

<ul>
  <li>증명
    <ul>
      <li>$x = 3, y = 4, z = 5$ 라고 할 때, $3^2 + 4^2 = 9 + 16 = 25 = 5^2$</li>
    </ul>
  </li>
</ul>

<hr />

<p><br />
<br /></p>

<h1 id="참조">참조</h1>
<p><a href="https://ko.wikipedia.org/wiki/%EC%A6%9D%EB%AA%85_(%EC%88%98%ED%95%99)">https://ko.wikipedia.org/wiki/%EC%A6%9D%EB%AA%85_(%EC%88%98%ED%95%99)</a><br />
<a href="http://bigdata.dongguk.ac.kr/lectures/disc_math/_book/%EC%A6%9D%EB%AA%85.html#%EC%A6%9D%EB%AA%85%EA%B4%80%EB%A0%A8-%EC%9A%A9%EC%96%B4">http://bigdata.dongguk.ac.kr/lectures/disc_math/_book/%EC%A6%9D%EB%AA%85.html#%EC%A6%9D%EB%AA%85%EA%B4%80%EB%A0%A8-%EC%9A%A9%EC%96%B4</a><br />
<a href="https://mathbang.net/121#gsc.tab=0">https://mathbang.net/121#gsc.tab=0</a>
<a href="https://ko.wikipedia.org/wiki/%EA%B3%B5%EB%A6%AC">https://ko.wikipedia.org/wiki/%EA%B3%B5%EB%A6%AC</a>
<a href="https://m.blog.naver.com/junhyuk7272/221961339600">https://m.blog.naver.com/junhyuk7272/221961339600</a></p>]]></content><author><name>지지형</name></author><category term="Discrete Mathematics" /><summary type="html"><![CDATA[증명(Proofs)이란? 특정한 공리(Axiom)들을 가정하고, 그 가정 하에서 어떤 명제가 참이라는 것을 보여주는 것이다.]]></summary></entry><entry><title type="html">[백준] 2309 : 일곱 난쟁이 (파이썬)</title><link href="http://localhost:4000/boj/BOJ-2309/" rel="alternate" type="text/html" title="[백준] 2309 : 일곱 난쟁이 (파이썬)" /><published>2023-10-19T00:00:00+09:00</published><updated>2023-10-19T00:00:00+09:00</updated><id>http://localhost:4000/boj/BOJ-2309</id><content type="html" xml:base="http://localhost:4000/boj/BOJ-2309/"><![CDATA[<h1 id="-난이도">🔎 난이도</h1>
<blockquote>
  <p>🟤 <strong>브론즈 1</strong></p>
</blockquote>

<h1 id="️-문제">✏️ 문제</h1>
<blockquote>
  <p><a href="https://www.acmicpc.net/problem/2309">https://www.acmicpc.net/problem/2309</a></p>
</blockquote>

<p><img src="/assets/images/Coding_test/Boj/BOJ_2309_1.png" />
<br /></p>

<h1 id="-예제-입력-및-출력">🤖 예제 입력 및 출력</h1>

<p><img src="/assets/images/Coding_test/Boj/BOJ_2309_2.png" /></p>

<p><br /></p>

<h1 id="-알고리즘-분류">📑 알고리즘 분류</h1>

<ul>
  <li>브루트포스 알고리즘</li>
  <li>정렬</li>
</ul>

<p><br /></p>

<h1 id="-아이디어">🧐 아이디어</h1>
<blockquote>
  <p>문제를 보자마자 순열과 조합이 떠올랐다.</p>
  <ul>
    <li>순열과 조합은 서로 다른 n개에서 r개를 고르는 경우의 수이다. 간단하게 순열은 순서를 고려한 것, 조합은 순서를 고려하지 않는다.
      <ul>
        <li>자세한 설명은 <a href="[wlgudths](https://wlgudths.github.io/)">이산수학파트에서 업로드 예정</a></li>
      </ul>
    </li>
  </ul>
</blockquote>

<blockquote>
  <p>9명의 난쟁이 중에 7명을 뽑아 키의 총합이 100이되면 <u>진짜 난쟁이 7명</u>을 찾을 수 있다.<br />
하지만 for문을 7번 쓸 수도 없고 매우 복잡해질 것이다.<br />
난쟁이 9명 중에서 진짜 난쟁이를 찾는 것보다 <u>가짜 난쟁이 2명</u>을 찾는 것이 더 효율적일 것이다.<br />
가짜 난쟁이 2명의 합은 9명의 합 - 100을 하면 구할 수 있다.</p>
</blockquote>

<p><br /></p>

<h1 id="-첫-풀이">📝 첫 풀이</h1>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># 입력
</span><span class="n">dwarf</span> <span class="o">=</span> <span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="nb">input</span><span class="p">())</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">9</span><span class="p">)]</span>

<span class="c1"># 총합 - 100
</span><span class="n">fake</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">dwarf</span><span class="p">)</span> <span class="o">-</span> <span class="mi">100</span>

<span class="c1"># 9명의 난쟁이 중 가짜 난쟁이 뽑기
</span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">dwarf</span><span class="p">)):</span>
    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">dwarf</span><span class="p">)):</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">dwarf</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">dwarf</span><span class="p">[</span><span class="n">j</span><span class="p">])</span> <span class="o">==</span> <span class="n">fake</span><span class="p">:</span>
            <span class="n">fake_1</span><span class="p">,</span> <span class="n">fake_2</span> <span class="o">=</span> <span class="n">dwarf</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">dwarf</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
            <span class="k">break</span>


<span class="c1"># 오름차순 정렬
</span><span class="n">dwarf</span><span class="p">.</span><span class="n">sort</span><span class="p">()</span>

<span class="c1"># 출력
</span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">dwarf</span><span class="p">:</span>
    <span class="k">if</span> <span class="n">fake_1</span> <span class="o">!=</span> <span class="n">i</span> <span class="ow">and</span> <span class="n">fake_2</span> <span class="o">!=</span> <span class="n">i</span><span class="p">:</span> <span class="c1"># 가짜 난쟁이를 제외하고 print
</span>        <span class="k">print</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
</code></pre></div></div>

<p><br /></p>

<h1 id="-풀이-리뷰">😳 풀이 리뷰</h1>
<blockquote>
  <p>fake라는 변수에 가짜 난쟁이의 합을 담고, 이중반복문을 통해 36가지 가짜 난쟁이 조합의 합이 fake와 같을 경우 반복문을 탈출 한 후 정렬, 출력하였다.</p>
</blockquote>

<h1 id="-두-번째-풀이">📝 두 번째 풀이</h1>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">itertools</span> <span class="kn">import</span> <span class="n">combinations</span>

<span class="c1"># 입력
</span><span class="n">dwarf</span> <span class="o">=</span> <span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="nb">input</span><span class="p">())</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">9</span><span class="p">)]</span>

<span class="c1"># 의심 난쟁이 두 명씩 뽑기
</span><span class="n">fake_lst</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">combinations</span><span class="p">(</span><span class="n">dwarf</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span>

<span class="c1"># 가짜 난쟁이 키의 합
</span><span class="n">fake_num</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">dwarf</span><span class="p">)</span> <span class="o">-</span> <span class="mi">100</span>

<span class="c1"># 가짜 난쟁이 찾아내기
</span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">fake_lst</span><span class="p">:</span>
    <span class="k">if</span> <span class="nb">sum</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">==</span> <span class="n">fake_num</span><span class="p">:</span>
        <span class="n">fake</span> <span class="o">=</span> <span class="n">i</span>
        <span class="k">break</span>

<span class="c1"># 오름차순 정렬
</span><span class="n">dwarf</span><span class="p">.</span><span class="n">sort</span><span class="p">()</span>

<span class="c1"># 가짜 난쟁이를 제외한 진짜 난쟁이들 출력
</span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">dwarf</span><span class="p">:</span>
    <span class="k">if</span> <span class="n">i</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">fake</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
</code></pre></div></div>

<h1 id="-풀이-리뷰-1">😳 풀이 리뷰</h1>
<blockquote>
  <p>첫 번째 풀이와 방식은 비슷하지만, itertools 모듈의 combinations를 활용하여 36가지의 의심 난쟁이들을 fake_lst에 담았다. 이후 첫 번째 풀이와 같다.</p>
</blockquote>]]></content><author><name>지지형</name></author><category term="BOJ" /><summary type="html"><![CDATA[🔎 난이도 🟤 브론즈 1]]></summary></entry><entry><title type="html">[백준] 2231 : 분해합 (파이썬)</title><link href="http://localhost:4000/boj/BOJ-2231/" rel="alternate" type="text/html" title="[백준] 2231 : 분해합 (파이썬)" /><published>2023-10-19T00:00:00+09:00</published><updated>2023-10-19T00:00:00+09:00</updated><id>http://localhost:4000/boj/BOJ-2231</id><content type="html" xml:base="http://localhost:4000/boj/BOJ-2231/"><![CDATA[<h1 id="-난이도">🔎 난이도</h1>
<blockquote>
  <p>🟤 <strong>브론즈 2</strong></p>
</blockquote>

<h1 id="️-문제">✏️ 문제</h1>
<blockquote>
  <p><a href="https://www.acmicpc.net/problem/2231">https://www.acmicpc.net/problem/2231</a></p>
</blockquote>

<p><img src="/assets/images/Coding_test/Boj/BOJ_2231_1.png" />
<br /></p>

<h1 id="-예제-입력-및-출력">🤖 예제 입력 및 출력</h1>

<p><img src="/assets/images/Coding_test/Boj/BOJ_2231_2.png" /></p>

<p><br /></p>

<h1 id="-알고리즘-분류">📑 알고리즘 분류</h1>

<ul>
  <li>브루트포스 알고리즘</li>
</ul>

<p><br /></p>

<h1 id="-아이디어">🧐 아이디어</h1>
<blockquote>
  <p>이 문제의 핵심은 분해합과 생성자에 대한 이해, N의 가장 작은 생성자 출력! 이라고 할 수 있다.</p>
  <ul>
    <li>분해합 : 자연수 N과 N을 이루는 각 자리수의 합
      <ul>
        <li>N = 123, N을 이루는 각 자리수 1, 2, 3 의 합이다. (123 + 1 + 2 + 3)</li>
      </ul>
    </li>
    <li>생성자 : 자연수 M의 분해합이 N인 경우, M은 생성자이다.
      <ul>
        <li>M = 120, N = 123 M의 분해합은 (120 + 1 + 2 + 0) = 123 = N 이다.<br />
즉, 120은 123의 생성자이다.</li>
      </ul>
    </li>
    <li>어떠한 자연수의 생성자가 없을 수도 있고, 여러 개일 수도 있다.
      <ul>
        <li>출력 : 생성자가 없을 경우 <strong>0</strong> / 생성자가 여러 개일 경우 <strong>가장 작은 생성자</strong></li>
      </ul>
    </li>
  </ul>
</blockquote>

<blockquote>
  <p>문제에서 요구한 개념들을 이해한 후에는 각 자리수를 더하는 과정을 코드로 구현하는 것이 포인트라고 생각한다.</p>
</blockquote>

<p><br /></p>

<h1 id="-첫-풀이">📝 첫 풀이</h1>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># 입력
</span><span class="n">n</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">input</span><span class="p">())</span>

<span class="c1"># 생성자를 받을 리스트
</span><span class="n">ans_lst</span> <span class="o">=</span> <span class="p">[]</span>

<span class="c1"># 정답 비교용
</span><span class="n">num</span> <span class="o">=</span> <span class="n">n</span>

<span class="k">while</span> <span class="n">n</span><span class="p">:</span> <span class="c1"># n이 0이 될 때까지 반복
</span>
    <span class="n">lst</span> <span class="o">=</span> <span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="c1"># 각 자리수의 합을 위한 리스트
</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">str</span><span class="p">(</span><span class="n">n</span><span class="p">):</span> <span class="c1"># 각 자리 수 반복 
</span>        <span class="n">lst</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">i</span><span class="p">))</span> <span class="c1"># 리스트에 각 자리수 담기
</span>
    <span class="k">if</span> <span class="nb">sum</span><span class="p">(</span><span class="n">lst</span><span class="p">)</span> <span class="o">==</span> <span class="n">num</span><span class="p">:</span> <span class="c1"># 각 자리수의 합이 생성자일 경우 
</span>        <span class="n">ans_lst</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="c1"># 결과값(생성자)을 담을 리스트에 담기
</span>    
    <span class="n">n</span> <span class="o">-=</span> <span class="mi">1</span> <span class="c1"># n에서 1씩 줄여가며 반복
</span>

<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ans_lst</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span> <span class="c1"># 결과 리스트에 원소가 있을 경우 가장 작은 생성자 출력
</span>    <span class="k">print</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">ans_lst</span><span class="p">))</span>

<span class="k">else</span><span class="p">:</span> <span class="c1"># 원소가 들어있지않으면 0을 출력
</span>    <span class="k">print</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
</code></pre></div></div>
<p><br /></p>

<h1 id="-풀이-리뷰">😳 풀이 리뷰</h1>
<p>물론 정답이 인정된 코드지만, 다시봐도 복잡하고 가독성이 떨어진다…<br />
while문을 통해 자연수 N을 하나씩 줄여가며 각 자리수를 더하고 num과 같은 지 비교하였다.<br />
while문을 빠져 나온 후 정답리스트에 원소가 있을 경우 min을 통해 가장 작은 숫자를 출력하고, 원소가 없을 경우 생성자가 없기 때문에 0을 출력하게 하였다.<br />
문제에서는 가장 작은 생성자를 출력하거나 없을 경우 0을 출력하는 것이다. 위 코드에서는 가장 큰 숫자인 N에서 1씩 빼며 반복하기에 가장 큰 생성자가 먼저 담기는 문제가 생겼다.</p>

<p><br /></p>

<h1 id="-두-번째-풀이">📝 두 번째 풀이</h1>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># 입력
</span><span class="n">n</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">input</span><span class="p">())</span> 

<span class="c1"># 결과를 담을 변수
</span><span class="n">ans</span> <span class="o">=</span> <span class="mi">0</span>

<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span> <span class="c1"># 1 ~ n 까지
</span>    <span class="n">num</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="nb">sum</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)))</span> <span class="c1"># i의 분해합
</span>
    <span class="k">if</span> <span class="n">num</span> <span class="o">==</span> <span class="n">n</span><span class="p">:</span> <span class="c1"># 생성자의 분해합과 N이 같을 경우
</span>        <span class="n">ans</span> <span class="o">=</span> <span class="n">i</span> <span class="c1"># 결과에 생성자 i를 담고 반복문 종료!
</span>        <span class="k">break</span>

<span class="c1"># for문을 1부터 n까지 돌며 생성자를 찾게되면 가장 작은 생성자를 찾게 된다.
# 만약 n까지 돌고 나서 생성자가 없을 경우 결과는 그래로 0을 출력하게 된다.
</span>
<span class="c1"># 결과 출력
</span><span class="k">print</span><span class="p">(</span><span class="n">ans</span><span class="p">)</span>
</code></pre></div></div>

<h1 id="-풀이-리뷰-1">😳 풀이 리뷰</h1>

<p>첫 번째 풀이 이후, 문제가 요구하는 사항에 맞춰 코드를 개선하였다.<br />
각 자리수의 합을 구할 때 리스트를 만들고 append시키며 복잡헀던 것이 map, sum을 통해 간략화 했다.<br />
이후 1 ~ N까지 반복문을 돌며 생성자를 생성하고 분해합과 같을 때 반복문을 탈출하도록 하였다.</p>]]></content><author><name>지지형</name></author><category term="BOJ" /><summary type="html"><![CDATA[🔎 난이도 🟤 브론즈 2]]></summary></entry><entry><title type="html">[백준] 1065 : 한수 (파이썬)</title><link href="http://localhost:4000/boj/BOJ-1065/" rel="alternate" type="text/html" title="[백준] 1065 : 한수 (파이썬)" /><published>2023-10-17T00:00:00+09:00</published><updated>2023-10-18T00:00:00+09:00</updated><id>http://localhost:4000/boj/BOJ-1065</id><content type="html" xml:base="http://localhost:4000/boj/BOJ-1065/"><![CDATA[<h1 id="-난이도">🔎 난이도</h1>
<blockquote>
  <p>⚪️ <strong>실버 4</strong></p>
</blockquote>

<h1 id="️-문제">✏️ 문제</h1>
<blockquote>
  <p><a href="https://www.acmicpc.net/problem/1065">https://www.acmicpc.net/problem/1065</a></p>
</blockquote>

<p><img src="/assets/images/Coding_test/Boj/BOJ_1065_1.png" />
<br /></p>

<h1 id="-예제-입력-및-출력">🤖 예제 입력 및 출력</h1>

<p><img src="/assets/images/Coding_test/Boj/BOJ_1065_2.png" /></p>

<p><br /></p>

<h1 id="-알고리즘-분류">📑 알고리즘 분류</h1>

<ul>
  <li>수학</li>
  <li>브루트포스 알고리즘</li>
</ul>

<p><br /></p>

<h1 id="-아이디어">🧐 아이디어</h1>

<blockquote>
  <p>문제에서 정의한 한수의 뜻을 이해하는데 많은 시간이 걸렸다.<br />
문제의 포인트는 이 두가지를 잘 파악하는데 있다고 생각한다.</p>
</blockquote>

<h2 id="1-한수의-정의">1. 한수의 정의</h2>

<blockquote>
  <p>어떤 양의 정수 X의 <strong>각 자리</strong>가 등차수열을 이루면 그 수를 <strong>한수</strong>라고 한다.</p>
  <ul>
    <li>등차 수열은 연속된 두 개의 수의 차이가 일정한 수열이다.
      <ul>
        <li><a href="https://wlgudths.github.io/">이산수학 파트에서 업로드 예정</a></li>
      </ul>
    </li>
  </ul>
</blockquote>

<h3 id="예시">예시</h3>
<blockquote>
  <p>이 문제는 N의 범위가 정해져있다. (1 &lt;= N &lt;= 1000)<br />
일, 십, 백, 천 각 자리수마다 한수의 유무를 다음과 같이 파악할 수 있다.</p>
</blockquote>

<ol>
  <li>N이 일의 자리일 경우 공차가 0인 등차수열이므로 모든 일의 자리의 자연수는 한수이다.
    <ul>
      <li>N = 2, 수열 S = {2}</li>
    </ul>
  </li>
  <li>N이 십의자리 수일 경우 연속된 두 수의 차이(공차)가 존재하므로 모든 십의 자리의 자연수도 한수이다.
    <ul>
      <li>N = 24, 수열 S = {2, 4} (공차가 2인 수열)</li>
    </ul>
  </li>
  <li>N이 백의 자리일 경우 연속된 두 수는 다음과 나타낼 수 있다.
    <ul>
      <li>N = 135, <u>13</u> 5 , 1 <u>35</u><br />
 135의 연속된 두 수는 1 , 3 과 3 , 5이다. 이 두 수의 공차가 같을 경우 135 는 한수이다.<br />
 1 - 3 = 3 - 5 = -2 로 같으므로 한수이다.</li>
    </ul>
  </li>
  <li>N이 1000인 경우
    <ul>
      <li>N = 1000, <u>10</u> 00, 1 <u>00</u> 0, 10 <u>00</u> 와 같이 연속된 두 수들로 나타낼 수 있다.<br />
 3번 경우와 같이 공차를 구하면 1, 0, 0 같지 않으므로 한수가 아니다.</li>
    </ul>
  </li>
</ol>

<h2 id="2-한수의-개수">2. <strong>한수</strong>의 <strong>개수</strong></h2>
<blockquote>
  <p>문제의 정답은 한수의 유무를 파악하는 것이 아닌 <u>한수의 개수</u>를 구하는 것이다.<br />
양의 정수 N이 주어질 경우 1부터 N까지 각각의 숫자의 한수 유무를 파악하여 한수의 개수를 출력해주면 된다.</p>
</blockquote>

<p><br />
<br /></p>

<h1 id="-내-풀이">📝 내 풀이</h1>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># 백준 1065 한수
</span>
<span class="c1"># 100의 자리 한수 판별 함수
</span><span class="k">def</span> <span class="nf">hansu</span> <span class="p">(</span><span class="n">n</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">&gt;=</span> <span class="mi">1000</span><span class="p">:</span> <span class="c1"># 천의 자리숫자가 들어올 경우 False 반환
</span>        <span class="k">return</span> <span class="bp">False</span>
    
    <span class="n">temp</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">n</span><span class="p">)))</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">temp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">temp</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">temp</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">temp</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
    
    <span class="c1"># 한수일 경우 True 반환 / 아닐 경우 False 반환
</span>    <span class="k">if</span> <span class="n">a</span> <span class="o">==</span> <span class="n">b</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">True</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">False</span>

<span class="c1"># 입력
</span><span class="n">n</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">input</span><span class="p">())</span>

<span class="c1"># 출력 / 한수 개수 카운트
</span><span class="n">cnt</span> <span class="o">=</span> <span class="mi">0</span>


<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span> <span class="c1"># 1 ~ N 까지 반복
</span>    <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">100</span><span class="p">:</span> <span class="c1"># 100보다 작을 경우
</span>        <span class="n">cnt</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">else</span><span class="p">:</span> <span class="c1"># 100과 같거나 큰 경우
</span>        <span class="k">if</span> <span class="n">hansu</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">==</span> <span class="bp">True</span><span class="p">:</span> <span class="c1"># 한수 판별이 True 일 경우 카운트
</span>            <span class="n">cnt</span> <span class="o">+=</span> <span class="mi">1</span>

<span class="k">print</span><span class="p">(</span><span class="n">cnt</span><span class="p">)</span>
</code></pre></div></div>
<p><br /></p>

<h1 id="-다른-사람-풀이">😳 다른 사람 풀이</h1>

<p>출처 : <a href="https://roseline124.github.io/algorithm/2019/03/29/Algorithem-baekjoon-1065.html">https://roseline124.github.io/algorithm/2019/03/29/Algorithem-baekjoon-1065.html</a></p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">num</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">input</span><span class="p">())</span>
<span class="n">hansu</span> <span class="o">=</span> <span class="mi">0</span>

<span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">num</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="p">:</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;=</span> <span class="mi">99</span> <span class="p">:</span> <span class="c1"># 1부터 99까지는 모두 한수
</span>        <span class="n">hansu</span> <span class="o">+=</span> <span class="mi">1</span> 
    
    <span class="k">else</span> <span class="p">:</span>     
        <span class="n">nums</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">n</span><span class="p">)))</span> <span class="c1"># 숫자를 자릿수대로 분리 
</span>        <span class="k">if</span> <span class="n">nums</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">nums</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">nums</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">nums</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="p">:</span> <span class="c1">#등차수열 확인
</span>            <span class="n">hansu</span><span class="o">+=</span><span class="mi">1</span>
</code></pre></div></div>

<blockquote>
  <p>내 풀이와 비교하면 더욱 간결하고 깔끔한 코드로 나타냈다.<br />
오히려 함수를 정의해서 깔끔하게 구현하겠다는 나의 생각을 깨버렸다 ☹️.</p>
</blockquote>]]></content><author><name>지지형</name></author><category term="BOJ" /><summary type="html"><![CDATA[🔎 난이도 ⚪️ 실버 4]]></summary></entry><entry><title type="html">[백준] 2798 : 블랙잭 (파이썬)</title><link href="http://localhost:4000/boj/BOJ-2798/" rel="alternate" type="text/html" title="[백준] 2798 : 블랙잭 (파이썬)" /><published>2023-10-16T00:00:00+09:00</published><updated>2023-10-16T00:00:00+09:00</updated><id>http://localhost:4000/boj/BOJ-2798</id><content type="html" xml:base="http://localhost:4000/boj/BOJ-2798/"><![CDATA[<h1 id="-난이도">🔎 난이도</h1>
<blockquote>
  <p>🟤 <strong>브론즈 2</strong></p>
</blockquote>

<h1 id="️-문제">✏️ 문제</h1>
<blockquote>
  <p><a href="https://www.acmicpc.net/problem/2798">https://www.acmicpc.net/problem/2798</a></p>
</blockquote>

<p><img src="/assets/images/Coding_test/Boj/BOJ_2798_1.png" />
<br /></p>

<h1 id="-예제-입력-및-출력">🤖 예제 입력 및 출력</h1>

<p><img src="/assets/images/Coding_test/Boj/BOJ_2798_2.png" /></p>

<p><br /></p>

<h1 id="-알고리즘-분류">📑 알고리즘 분류</h1>

<ul>
  <li>브루트포스 알고리즘</li>
</ul>

<p><br /></p>

<h1 id="-아이디어">🧐 아이디어</h1>

<blockquote>
  <p>N개의 카드 중 <strong>중복 없이</strong> 3장의 카드를 뽑은 후 M보다 작거나 같은 숫자들을 담는다 !</p>
</blockquote>

<p><br /></p>

<h1 id="-내-풀이">📝 내 풀이</h1>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># 입력
</span><span class="n">n</span><span class="p">,</span><span class="n">m</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">input</span><span class="p">().</span><span class="n">split</span><span class="p">())</span> <span class="c1"># 카드의 개수, M
</span><span class="n">cards</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">input</span><span class="p">().</span><span class="n">split</span><span class="p">()))</span> <span class="c1"># 카드의 숫자들
</span>
<span class="c1"># 카드의 합들을 담을 리스트
</span><span class="n">basket</span> <span class="o">=</span> <span class="p">[]</span>

<span class="c1"># 중복없이 3장의 카드 뽑기
</span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
  <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
      <span class="n">nums</span> <span class="o">=</span> <span class="n">card</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">cards</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">+</span> <span class="n">cards</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="c1"># 중복없이 뽑은 3장의 카드 합
</span>      <span class="k">if</span> <span class="n">nums</span> <span class="o">&lt;=</span> <span class="n">m</span><span class="p">:</span> <span class="c1"># 카드의 합이 M 보다 작거나 같을 경우 리스트에 담는다.
</span>        <span class="n">basket</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span>

<span class="c1"># 출력
</span><span class="k">print</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">basket</span><span class="p">))</span> <span class="c1"># 리스트 원소 중 가장 큰 값 출력
</span></code></pre></div></div>
<p><br /></p>]]></content><author><name>지지형</name></author><category term="BOJ" /><summary type="html"><![CDATA[🔎 난이도 🟤 브론즈 2]]></summary></entry><entry><title type="html">[백준] 1543 : 문서검색 (파이썬)</title><link href="http://localhost:4000/boj/BOJ-1543/" rel="alternate" type="text/html" title="[백준] 1543 : 문서검색 (파이썬)" /><published>2023-10-16T00:00:00+09:00</published><updated>2023-10-16T00:00:00+09:00</updated><id>http://localhost:4000/boj/BOJ-1543</id><content type="html" xml:base="http://localhost:4000/boj/BOJ-1543/"><![CDATA[<h1 id="-난이도">🔎 난이도</h1>
<blockquote>
  <p>⚪️ <strong>실버 5</strong></p>
</blockquote>

<h1 id="️-문제">✏️ 문제</h1>
<blockquote>
  <p><a href="https://www.acmicpc.net/problem/1543">https://www.acmicpc.net/problem/1543</a></p>
</blockquote>

<p><img src="/assets/images/Coding_test/Boj/BOJ_1543_1.png" />
<br /></p>

<h1 id="-예제-입력-및-출력">🤖 예제 입력 및 출력</h1>

<p><img src="/assets/images/Coding_test/Boj/BOJ_1543_2.png" /></p>

<p><br /></p>

<h1 id="-알고리즘-분류">📑 알고리즘 분류</h1>

<ul>
  <li>문자열</li>
  <li>브루트포스 알고리즘</li>
</ul>

<p><br /></p>

<h1 id="-아이디어">🧐 아이디어</h1>

<blockquote>
  <p>문제를 읽자마자 <strong>replace</strong> 함수가 딱 떠올랐다.</p>
</blockquote>

<p><br /></p>

<h1 id="-내-풀이">📝 내 풀이</h1>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># 입력
</span><span class="n">words</span> <span class="o">=</span> <span class="nb">input</span><span class="p">()</span> <span class="c1"># 문서
</span><span class="n">word</span> <span class="o">=</span> <span class="nb">input</span><span class="p">()</span> <span class="c1"># 검색하고 싶은 단어
</span>
<span class="n">change</span> <span class="o">=</span> <span class="n">words</span><span class="p">.</span><span class="n">replace</span><span class="p">(</span><span class="n">word</span><span class="p">,</span> <span class="s">'*'</span><span class="p">)</span> <span class="c1"># 중복되지 않게 단어 &gt; "*" 변환
</span>
<span class="c1"># 출력
</span><span class="k">print</span><span class="p">(</span><span class="n">change</span><span class="p">.</span><span class="n">count</span><span class="p">(</span><span class="s">'*'</span><span class="p">))</span>
</code></pre></div></div>
<p><br /></p>]]></content><author><name>지지형</name></author><category term="BOJ" /><summary type="html"><![CDATA[🔎 난이도 ⚪️ 실버 5]]></summary></entry><entry><title type="html">[이산수학] 논리와 명제 (Logic &amp;amp; Proposition)</title><link href="http://localhost:4000/discrete%20mathematics/DM-03/" rel="alternate" type="text/html" title="[이산수학] 논리와 명제 (Logic &amp;amp; Proposition)" /><published>2023-10-16T00:00:00+09:00</published><updated>2023-10-19T00:00:00+09:00</updated><id>http://localhost:4000/discrete%20mathematics/DM-03</id><content type="html" xml:base="http://localhost:4000/discrete%20mathematics/DM-03/"><![CDATA[<h1 id="명제-proposition">명제 (Proposition)</h1>
<blockquote>
  <p>논리학적으로 뜻이 분명한 문장을 말한다.</p>
</blockquote>

<ul>
  <li>즉, <strong>참(True)</strong> 혹은 <strong>거짓(False)</strong> 으로 구분할 수 있는 문장이나 수식이다.</li>
  <li>명제는 통상 영문 소문자 $p$, $q$, $r$, $\cdots$ 등으로 표기</li>
</ul>

<h2 id="명제-예시">명제 예시</h2>
<ol>
  <li>손흥민이 태어난 년도는 2000년이다.
    <ul>
      <li>손흥민이 태어난 년도는 1992년이므로 거짓인 명제이다.</li>
    </ul>
  </li>
  <li>1 + 2 = 3
    <ul>
      <li>산수에 원리에 따라 객관적으로 참, 거짓을 판달할 수 있으므로 명제이며 참이다.</li>
    </ul>
  </li>
  <li>커피는 달달하다.
    <ul>
      <li>참 또는 거짓을 판단할 수 없으므로 명제가 아니다.</li>
    </ul>
  </li>
</ol>

<h2 id="진리값-truth-value">진리값 (Truth value)</h2>
<blockquote>
  <p>참, 거짓을 가르키는 값을 진리값(truth value)라고 한다.</p>
</blockquote>

<ul>
  <li>프로그래밍 언어에서는 조건이 참인지 거짓인지 표현하는 논리 연산에 사용한다.<br />
참 $\rightarrow$ 1, 거짓 $\rightarrow$ 0</li>
</ul>

<h2 id="진리표-truth-table">진리표 (Truth table)</h2>
<blockquote>
  <p>모든 명제 및 그 조합에 대한 입출력 결과를 기록한 표</p>
</blockquote>

<table>
  <thead>
    <tr>
      <th style="text-align: left">명제 $P$</th>
      <th style="text-align: center">명제 $Q$</th>
      <th style="text-align: right">$P$ $\land$ $Q$</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left">참</td>
      <td style="text-align: center">참</td>
      <td style="text-align: right">참</td>
    </tr>
    <tr>
      <td style="text-align: left">참</td>
      <td style="text-align: center">거짓</td>
      <td style="text-align: right">거짓</td>
    </tr>
    <tr>
      <td style="text-align: left">거짓</td>
      <td style="text-align: center">참</td>
      <td style="text-align: right">거짓</td>
    </tr>
    <tr>
      <td style="text-align: left">거짓</td>
      <td style="text-align: center">거짓</td>
      <td style="text-align: right">거짓</td>
    </tr>
  </tbody>
</table>

<h2 id="명제함수">명제함수</h2>
<blockquote>
  <p>명제변수 $x$ 를 포함하여 진리값을 판별할 수 있는 문장이나 수식</p>
</blockquote>

<h3 id="명제함수-예시">명제함수 예시</h3>
<blockquote>
  <p>$P(x)$ = $x$ &gt; 2  이라는 명제 함수라고 하면 명제변수 $x$의 값에 따라 $P(x)$ 의 진리값을 판별할 수 있다.</p>
</blockquote>

<ul>
  <li>변수에 특정 값을 할당하는 방법
    <ul>
      <li>$x$ = 3이라면 $P(x)$는 참인 명제가 되고, $x$ = 1이라면 $P(x)$는 거짓인 명제가 된다.</li>
    </ul>
  </li>
  <li>변수의 범위를 제한하는 방법
    <ul>
      <li>$x$ $\ge$ 3이라면, $P(x)$는 참이 된다.</li>
    </ul>
  </li>
</ul>

<h3 id="한정자">한정자</h3>
<blockquote>
  <p>명제함수에서 변수의 범위를 제한하는 연산자이다.</p>
</blockquote>

<h4 id="전체한정자-universal-quantifier">전체한정자 (Universal Quantifier)</h4>
<blockquote>
  <p>모든 것에 대하여 <strong>(for all)</strong></p>
</blockquote>

<ul>
  <li>$\forall xP(x)$ : 모든 $x$에 대하여 $P(x)$
    <ul>
      <li>모든 $x$에 대하여 참일 경우 참인 명제이다.</li>
    </ul>
  </li>
  <li>기호
    <ul>
      <li>$\forall$</li>
    </ul>
  </li>
</ul>

<h4 id="존재한정자-existential-quantifier">존재한정자 (existential quantifier)</h4>
<blockquote>
  <p>존재한다 <strong>(there exist)</strong></p>
</blockquote>

<ul>
  <li>$\exists xP(x)$ : 어떤 $x$에 대하여 $P(x)$
    <ul>
      <li>참이되는 $x$가 하나라도 있을 경우 참인 명제이다.</li>
    </ul>
  </li>
  <li>기호
    <ul>
      <li>$\exists$</li>
    </ul>
  </li>
</ul>

<h2 id="논리연산자logical-operator">논리연산자(logical operator)</h2>
<blockquote>
  <p>여러 명제를 결합할 때 사용</p>
</blockquote>

<h3 id="종류">종류</h3>
<h4 id="1-부정-negation">1. 부정 (Negation)</h4>
<blockquote>
  <p>명제 $p$에 대하여 $p$의 진리값을 반대로 갖는 명제</p>
</blockquote>

<ul>
  <li>언어
    <ul>
      <li>$not$</li>
    </ul>
  </li>
  <li>기호
    <ul>
      <li>$\lnot$</li>
      <li>$\sim$</li>
    </ul>
  </li>
  <li>
    <p>진리표 (truth table)</p>

    <table>
      <thead>
        <tr>
          <th style="text-align: center">$p$</th>
          <th style="text-align: center">$\lnot p$</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td style="text-align: center">T</td>
          <td style="text-align: center">F</td>
        </tr>
        <tr>
          <td style="text-align: center">F</td>
          <td style="text-align: center">T</td>
        </tr>
      </tbody>
    </table>
  </li>
</ul>

<h4 id="2-논리곱-conjunction">2. 논리곱 (Conjunction)</h4>
<blockquote>
  <p>명제 $p$, $q$에 대하여 $p$와 $q$가 모두 참일 경우에만 참, 반대일 경우 거짓이 되는 명제</p>
</blockquote>

<ul>
  <li>언어
    <ul>
      <li>$and$</li>
    </ul>
  </li>
  <li>기호
    <ul>
      <li>$\land$</li>
    </ul>
  </li>
  <li>
    <p>진리표 (truth table)</p>

    <table>
      <thead>
        <tr>
          <th style="text-align: center">$p$</th>
          <th style="text-align: center">$q$</th>
          <th style="text-align: center">$p$ $\land$ $p$</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td style="text-align: center">T</td>
          <td style="text-align: center">T</td>
          <td style="text-align: center">T</td>
        </tr>
        <tr>
          <td style="text-align: center">T</td>
          <td style="text-align: center">F</td>
          <td style="text-align: center">F</td>
        </tr>
        <tr>
          <td style="text-align: center">F</td>
          <td style="text-align: center">T</td>
          <td style="text-align: center">F</td>
        </tr>
        <tr>
          <td style="text-align: center">F</td>
          <td style="text-align: center">F</td>
          <td style="text-align: center">T</td>
        </tr>
      </tbody>
    </table>
  </li>
</ul>

<h4 id="3-논리합-disjunction">3. 논리합 (Disjunction)</h4>
<blockquote>
  <p>명제 $p$, $q$에 대하여 $p$와 $q$가 모두 거짓일 경우에만 거짓, 그렇지 않을 경우 참이 되는 명제</p>
</blockquote>

<ul>
  <li>언어
    <ul>
      <li>$or$</li>
    </ul>
  </li>
  <li>기호
    <ul>
      <li>$\lor$</li>
    </ul>
  </li>
  <li>
    <p>진리표 (truth table)</p>

    <table>
      <thead>
        <tr>
          <th style="text-align: center">$p$</th>
          <th style="text-align: center">$q$</th>
          <th style="text-align: center">$p$ $\lor$ $p$</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td style="text-align: center">T</td>
          <td style="text-align: center">T</td>
          <td style="text-align: center">T</td>
        </tr>
        <tr>
          <td style="text-align: center">T</td>
          <td style="text-align: center">F</td>
          <td style="text-align: center">T</td>
        </tr>
        <tr>
          <td style="text-align: center">F</td>
          <td style="text-align: center">T</td>
          <td style="text-align: center">T</td>
        </tr>
        <tr>
          <td style="text-align: center">F</td>
          <td style="text-align: center">F</td>
          <td style="text-align: center">F</td>
        </tr>
      </tbody>
    </table>
  </li>
</ul>

<h4 id="4-배타적-논리합-exclusive-or">4. 배타적 논리합 (Exclusive OR)</h4>
<blockquote>
  <p>명제 $p$, $q$에 대하여 $p$와 $q$ 중 하나만 참일 때 참이되고, 그렇지 않으면 거짓이 되는 명제</p>
</blockquote>

<ul>
  <li>언어
    <ul>
      <li>$X OR$</li>
    </ul>
  </li>
  <li>기호
    <ul>
      <li>$\oplus$</li>
      <li>$\sim$</li>
    </ul>
  </li>
  <li>
    <p>진리표 (truth table)</p>

    <table>
      <thead>
        <tr>
          <th style="text-align: center">$p$</th>
          <th style="text-align: center">$q$</th>
          <th style="text-align: center">$p$ $\oplus$ $p$</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td style="text-align: center">T</td>
          <td style="text-align: center">T</td>
          <td style="text-align: center">F</td>
        </tr>
        <tr>
          <td style="text-align: center">T</td>
          <td style="text-align: center">F</td>
          <td style="text-align: center">T</td>
        </tr>
        <tr>
          <td style="text-align: center">F</td>
          <td style="text-align: center">T</td>
          <td style="text-align: center">T</td>
        </tr>
        <tr>
          <td style="text-align: center">F</td>
          <td style="text-align: center">F</td>
          <td style="text-align: center">F</td>
        </tr>
      </tbody>
    </table>
  </li>
</ul>

<hr />

<h3 id="조건명제-conditional-proposition">조건명제 (Conditional Proposition)</h3>

<blockquote>
  <p>$p \rightarrow q$</p>
  <ul>
    <li>$p$이면 $q$이다. ( $if$  $p$  $then$   $q$ )</li>
    <li>$p$를 가설(hypothesis), 전제(premise) $q$를 결론(conclusion), 결과(consequence)</li>
  </ul>
</blockquote>

<h4 id="조건-명제-진리표">조건 명제 진리표</h4>

<table>
  <thead>
    <tr>
      <th style="text-align: center">$p$</th>
      <th style="text-align: center">$q$</th>
      <th style="text-align: center">$p \rightarrow q$</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">T</td>
      <td style="text-align: center">T</td>
      <td style="text-align: center">T</td>
    </tr>
    <tr>
      <td style="text-align: center">T</td>
      <td style="text-align: center">F</td>
      <td style="text-align: center">F</td>
    </tr>
    <tr>
      <td style="text-align: center">F</td>
      <td style="text-align: center">T</td>
      <td style="text-align: center">T</td>
    </tr>
    <tr>
      <td style="text-align: center">F</td>
      <td style="text-align: center">F</td>
      <td style="text-align: center">T</td>
    </tr>
  </tbody>
</table>

<hr />

<h4 id="역-converse">역 (converse)</h4>
<blockquote>
  <p>$p \rightarrow q$ 에 대하여 $q \rightarrow p$ 가설과 결론이 바뀐 것이다.</p>
</blockquote>

<h4 id="이-inverse">이 (inverse)</h4>
<blockquote>
  <p>$p \rightarrow q$ 에 대하여 $\lnot p \rightarrow \lnot q$ 가설과 결론을 각각 부정한 것이다.</p>
</blockquote>

<h4 id="대우-contrapositive">대우 (contrapositive)</h4>
<blockquote>
  <p>$p \rightarrow q$ 에 대하여 $\lnot q \rightarrow \lnot p$ 가설과 결론이 바뀐 동시에 부정한 것이다.</p>
</blockquote>

<h4 id="역-이-대우-진리표">역, 이, 대우 진리표</h4>

<table>
  <thead>
    <tr>
      <th style="text-align: center">$p$</th>
      <th style="text-align: center">$q$</th>
      <th style="text-align: center">$p \rightarrow q$</th>
      <th style="text-align: center">$q \rightarrow p$</th>
      <th style="text-align: center">$\lnot p \rightarrow \lnot q$</th>
      <th style="text-align: center">$\lnot q \rightarrow \lnot p$</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">T</td>
      <td style="text-align: center">T</td>
      <td style="text-align: center">T</td>
      <td style="text-align: center">T</td>
      <td style="text-align: center">T</td>
      <td style="text-align: center">T</td>
    </tr>
    <tr>
      <td style="text-align: center">T</td>
      <td style="text-align: center">F</td>
      <td style="text-align: center">F</td>
      <td style="text-align: center">T</td>
      <td style="text-align: center">T</td>
      <td style="text-align: center">F</td>
    </tr>
    <tr>
      <td style="text-align: center">F</td>
      <td style="text-align: center">T</td>
      <td style="text-align: center">T</td>
      <td style="text-align: center">F</td>
      <td style="text-align: center">F</td>
      <td style="text-align: center">T</td>
    </tr>
    <tr>
      <td style="text-align: center">F</td>
      <td style="text-align: center">F</td>
      <td style="text-align: center">T</td>
      <td style="text-align: center">T</td>
      <td style="text-align: center">T</td>
      <td style="text-align: center">T</td>
    </tr>
  </tbody>
</table>

<hr />
<p><br /></p>

<h1 id="참조">참조</h1>
<p><a href="https://ko.wikipedia.org/wiki/%EB%AA%85%EC%A0%9C">https://ko.wikipedia.org/wiki/%EB%AA%85%EC%A0%9C</a><br />
<a href="https://ko.wikipedia.org/wiki/%EC%A7%84%EB%A6%BF%EA%B0%92">https://ko.wikipedia.org/wiki/%EC%A7%84%EB%A6%BF%EA%B0%92</a><br />
<a href="http://bigdata.dongguk.ac.kr/lectures/disc_math/_book/%EB%85%BC%EB%A6%AC%EC%99%80-%EB%AA%85%EC%A0%9C-logic-propositions.html">http://bigdata.dongguk.ac.kr/lectures/disc_math/_book/%EB%85%BC%EB%A6%AC%EC%99%80-%EB%AA%85%EC%A0%9C-logic-propositions.html</a><br />
<a href="https://ko.wikipedia.org/wiki/%EC%A7%84%EB%A6%AC%ED%91%9C">https://ko.wikipedia.org/wiki/%EC%A7%84%EB%A6%AC%ED%91%9C</a></p>]]></content><author><name>지지형</name></author><category term="Discrete Mathematics" /><summary type="html"><![CDATA[명제 (Proposition) 논리학적으로 뜻이 분명한 문장을 말한다.]]></summary></entry><entry><title type="html">[이산수학] 집합(Set)</title><link href="http://localhost:4000/discrete%20mathematics/DM-02/" rel="alternate" type="text/html" title="[이산수학] 집합(Set)" /><published>2023-10-15T00:00:00+09:00</published><updated>2023-10-16T00:00:00+09:00</updated><id>http://localhost:4000/discrete%20mathematics/DM-02</id><content type="html" xml:base="http://localhost:4000/discrete%20mathematics/DM-02/"><![CDATA[<h1 id="집합set이란">집합(Set)이란?</h1>

<blockquote>
  <p>집합(Set)은 어떤 명확한 조건을 서로 만족시키는 서로 다른 대상들의 모임</p>
</blockquote>

<ul>
  <li>여러 원소들의 모임</li>
  <li>중복된 원소를 가지지 않음</li>
  <li>집합은 대문자 $A$,$B$,$C$ $\cdots$ 로 표기</li>
  <li>원소는 소문자 $a$,$b$,$c$ $\cdots$ 로 표기</li>
  <li>원소 a가 A의 원소임을 a $\in$ A 와 같이 표기</li>
  <li>a가 A의 원소가 아니면 a $\notin$ A 와 같이 표기</li>
  <li>원소가 0개일 경우, 공집합($\emptyset$)으로 표기</li>
</ul>

<hr />

<h1 id="집합의-표현">집합의 표현</h1>

<h2 id="1-원소-나열법">1. 원소 나열법</h2>
<blockquote>
  <p>집합의 원소를 나열하여 집합을 표현하는 방법<br />
중괄호 { } 속에 “ , “ 구별하여 나열한다.</p>
</blockquote>

<ul>
  <li>{1, 2, 3}</li>
  <li>{빨간색, 파란색, 보라색}</li>
</ul>

<h2 id="2-조건-제시법">2. 조건 제시법</h2>
<blockquote>
  <p>조건을 제시하여 집합을 표현하는 방법
<br /></p>
</blockquote>

<ol>
  <li>중괄호 { } 속에 수직선 $\mid$ , 쌍점 : 을 써서 구역을 나눈 후</li>
  <li>왼쪽구역 : 집합을 나타내는식</li>
  <li>오른쪽 구역 : 원소를 만족시킬 조건</li>
</ol>

<ul>
  <li>{2n $\mid$ n은 정수} $\rightarrow$ 모든 짝수의 집합</li>
</ul>

<h2 id="3-벤-다이어그램">3. 벤 다이어그램</h2>
<blockquote>
  <p>집합 사이의 관계를 표시하기 위헤 도형으로 표기한 것</p>
</blockquote>

<p><img src="/assets/images/Math/dm/dm_example_2_1.png" width="200" height="200" /></p>

<p><br /></p>

<h1 id="집합의-종류">집합의 종류</h1>
<h2 id="1-유한--무한-집합">1. 유한 / 무한 집합</h2>
<blockquote>
  <p>유한개 원소로 이루어진 집합 $\rightarrow$ {1, 2, 3}<br />
무한개 원소로 이루어진 집합 $\rightarrow$ 자연수</p>
</blockquote>

<h2 id="2-전체-집합-universal-set">2. 전체 집합 (Universal Set)</h2>
<blockquote>
  <p>모든 대상을 (자기 자신까지도) 원소로 포함하는 집합<br />
보통 알파벳 U로 표기</p>
</blockquote>

<h2 id="3-공집합-empty-set">3. 공집합 (Empty Set)</h2>
<blockquote>
  <p>원소가 하나도 없는 집합<br />
기호 $\phi$ 로 표기</p>
</blockquote>

<h2 id="4-부분집합-subset">4. 부분집합 (subset)</h2>
<blockquote>
  <p>집합 A의 모든 원소가 집합 B에 포함되는 집합<br />
A $\subseteq$ B 로 표기</p>
</blockquote>

<h2 id="5-진부분집합-proper-subset">5. 진부분집합 (proper subset)</h2>
<blockquote>
  <p>부분 집합 중 자기 자신은 원소로 갖지 않는 집합<br />
A $\subseteq$ B 이고, A $\ne$ B 일때, 진부분집합이라고 한다.<br />
A $\subset$ B 로 표기</p>
</blockquote>

<h2 id="6-여집합-complementary-set">6. 여집합 (complementary set)</h2>
<blockquote>
  <p>전체 집합 U 에는 속하나 A에 속하지 않는 집합<br />
$A^c$ 로 표기</p>
</blockquote>

<p><img src="/assets/images/Math/dm/dm_example_2_2.png" width="200" height="200" /></p>

<h1 id="집합의-연산">집합의 연산</h1>
<h2 id="1-합집합-union">1. 합집합 (Union)</h2>
<blockquote>
  <p>둘 또는 더 많은 집합의 원소를 한 군데 합쳐놓은 집합<br />
A $\cup$ B 로 표기</p>
</blockquote>

<ul>
  <li>A $\cup$ B = {x : x $\in$ A 또는 x $\in$ B}</li>
  <li>x가 A $\cup$ B 에 속할 필요충분조건은 x $\in$ A 또는 x $\in$ B 이다.</li>
</ul>

<p><img src="/assets/images/Math/dm/dm_example_2_3.png" width="200" height="200" /></p>

<h2 id="2-교집합-intersection">2. 교집합 (Intersection)</h2>
<blockquote>
  <p>둘 또는 더 많은 집합이 공통으로 포함하는 원소로 이루어진 집합<br />
A $\cap$ B 로 표기</p>
</blockquote>

<ul>
  <li>A $\cap$ B = {x : x $\in$ A and x $\in$ B}</li>
  <li>x $\in$ A $\cap$ B  일 필요충분조건은 x x $\in$ A 또한 x $\in$ B 이다.</li>
</ul>

<p><img src="/assets/images/Math/dm/dm_example_2_4.png" width="200" height="200" /></p>

<h2 id="3-차집합-difference">3. 차집합 (Difference)</h2>
<blockquote>
  <p>두 집합 A, B 에서 B의 원소 중 A에 속하지 않는 원소만으로 이루어진 집합을 B $\setminus$ A 라고 한다.</p>
</blockquote>

<ul>
  <li>집합 B 에 대한 A 의 차집합은 B - A 또는 B $\setminus$ A 로 표기</li>
</ul>

<p><img src="/assets/images/Math/dm/dm_example_2_5.png" width="200" height="200" /></p>

<h2 id="4-곱집합-product-set">4. 곱집합 (Product Set)</h2>
<blockquote>
  <ol>
    <li>곱집합 (Product Set) 또는 카티션 곱 (Cartesian Product) 라고 한다.
      <ul>
        <li>두 집합 A,B 의 원소들로 만들어지는 모든 순서상 (a,b) 들의 집합</li>
        <li>a $\in$ A 이고, b $\in$ B 인 모든 순서쌍 (a,b) 들의 집합</li>
        <li>A $\times$ B 로 표기</li>
        <li>A $\times$ B = {(a,b) $\mid$ a $\in$ A and b $\in$ B}</li>
      </ul>
    </li>
    <li>카티션 곱의 길이(크기) $\rightarrow$ 가능한 모든 순서쌍의 개수
      <ul>
        <li>$\mid$ A $\times$ B $\mid$ 로 표기</li>
        <li>$\mid$ A $\times$ B $\mid$ = $\mid$ A $\mid$  $\cdot$ $\mid$ B $\mid$</li>
      </ul>
    </li>
  </ol>
</blockquote>

<ul>
  <li>A = {x, y, z}, B = {1, 2, 3}
    <ul>
      <li>A $\times$ B = {(x,1), (x,2), (x,3), (y,1), (y,2), (y,3), (z,1), (z,2), (z,3)}</li>
      <li>$\mid$ A $\times$ B $\mid$ = 3 $\cdot$ 3 = 9<br />
<br />
<img src="/assets/images/Math/dm/dm_example_2_6.png" width="200" height="200" /></li>
    </ul>
  </li>
</ul>

<h2 id="5-서로소-disjoint">5. 서로소 (disjoint)</h2>
<blockquote>
  <p>두 집합의 교집합이 공집합이면 두 집합을 서로소 (disjoint)라고 한다.</p>
</blockquote>

<ul>
  <li>A $\cap$ B = $\emptyset$</li>
</ul>

<hr />

<h1 id="집합의-법칙">집합의 법칙</h1>
<h2 id="1-항등법칙">1. 항등법칙</h2>
<ul>
  <li>A $\cap$ $\emptyset$ = A</li>
  <li>A $\cup$ U = A</li>
</ul>

<h2 id="2-지배법칙">2. 지배법칙</h2>
<ul>
  <li>A $\cup$ U = U</li>
  <li>A $\cap$ $\emptyset$ = $\emptyset$</li>
</ul>

<h2 id="3-멱등법칙">3. 멱등법칙</h2>
<ul>
  <li>A $\cup$ A = A</li>
  <li>A $\cap$ A = A</li>
</ul>

<h2 id="4-교환법칙">4. 교환법칙</h2>
<ul>
  <li>A $\cup$ B = B $\cup$ A</li>
  <li>A $\cap$ B = B $\cap$ A</li>
</ul>

<h2 id="5-결합법칙">5. 결합법칙</h2>
<ul>
  <li>A $\cup$ (B $\cup$ C) = (A $\cup$ B) $\cup$ C</li>
  <li>A $\cap$ (B $\cap$ C) = (A $\cap$ B) $\cap$ C</li>
</ul>

<h2 id="6-분배법칙">6. 분배법칙</h2>
<ul>
  <li>A $\cup$ (B $\cap$ C) = (A $\cup$ B) $\cap$ (A $\cup$ C)</li>
  <li>A $\cap$ (B $\cup$ C) = (A $\cap$ B) $\cup$ (A $\cap$ C)</li>
</ul>

<h2 id="7-이중-여집합">7. 이중 여집합</h2>
<ul>
  <li>$(A^c)^c$ = $A$</li>
</ul>

<h2 id="8-여집합의-법칙">8. 여집합의 법칙</h2>
<ul>
  <li>$A$ $\cup$ $A^c$ = U</li>
  <li>$A$ $\cap$ $A^c$ = $\phi$</li>
  <li>$\emptyset^c$ = U</li>
  <li>$U^c$ = $\emptyset$</li>
</ul>

<h2 id="9-드로므간의-법칙">9. 드로므간의 법칙</h2>
<ul>
  <li>(A $\cup$ B)$^c$ = A$^c$ $\cap$ B$^c$</li>
  <li>(A $\cap$ B)$^c$ = A$^c$ $\cup$ B$^c$</li>
</ul>

<h2 id="10-흡수법칙">10. 흡수법칙</h2>
<ul>
  <li>A $\cup$ (A $\cap$ B) = A</li>
  <li>A $\cap$ (A $\cup$ B) = A</li>
</ul>

<hr />

<h1 id="참조">참조</h1>
<p><a href="https://ko.wikipedia.org/wiki/%EC%A7%91%ED%95%A9">https://ko.wikipedia.org/wiki/%EC%A7%91%ED%95%A9</a><br />
<a href="https://mathbang.net/1#gsc.tab=0">https://mathbang.net/1#gsc.tab=0</a><br />
<a href="http://www.ktword.co.kr/test/view/view.php?nav=2&amp;no=3902&amp;sh=%EC%A7%91%ED%95%A9">http://www.ktword.co.kr/test/view/view.php?nav=2&amp;no=3902&amp;sh=%EC%A7%91%ED%95%A9</a></p>]]></content><author><name>지지형</name></author><category term="Discrete Mathematics" /><summary type="html"><![CDATA[집합(Set)이란?]]></summary></entry></feed>