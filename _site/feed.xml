<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.9.3">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2023-11-26T01:37:41+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">느려도 괜찮아</title><author><name>지지형</name></author><entry><title type="html">[이산수학] 행렬(Matrix) : 02_행렬의 연산</title><link href="http://localhost:4000/discrete%20mathematics/DM-07/" rel="alternate" type="text/html" title="[이산수학] 행렬(Matrix) : 02_행렬의 연산" /><published>2023-11-24T00:00:00+09:00</published><updated>2023-11-24T00:00:00+09:00</updated><id>http://localhost:4000/discrete%20mathematics/DM-07</id><content type="html" xml:base="http://localhost:4000/discrete%20mathematics/DM-07/"><![CDATA[<h1 id="행렬의-연산">행렬의 연산</h1>

<ul>
  <li>행렬에서 가능한 연산은 덧셈, 곱셈, 스칼라곱, 곱셈이 있다.</li>
</ul>

<p><br />
<br /></p>

<h1 id="행렬의-덧셈과-뺄셈">행렬의 덧셈과 뺄셈</h1>

<blockquote>
  <p>행렬의 덧셈과 뺄셈이 가능하려면 두 행렬의 크기가 같아야 한다.</p>
</blockquote>

<ul>
  <li>두 행렬 $A$ 와 $B$ 는 덧셈과 뺄셈이 가능하다.
    <ul>
      <li>$A = 4 \times 4$</li>
      <li>$B = 4 \times 4$</li>
    </ul>
  </li>
</ul>

<h2 id="정의">정의</h2>
<blockquote>
  <p>두 행렬 크기가 $m \times n$인 두 행렬 $A$, $B$ 에서 <strong>같은 위치</strong>에 있는 원소끼리 더하거나 빼는 연산</p>
</blockquote>

<ul>
  <li>$A =$
$\begin{bmatrix}
a_{11} &amp; a_{12} &amp; \cdots &amp; a_{1n} \\<br />
a_{21} &amp; a_{22} &amp; \cdots &amp; a_{2n} \\<br />
\cdots &amp; \cdots &amp; \cdots &amp; \cdots \\<br />
a_{m1} &amp; a_{m2} &amp; \cdots &amp; a_{mn}
\end{bmatrix}$ $B =$
$\begin{bmatrix}
b_{11} &amp; b_{12} &amp; \cdots &amp; b_{1n} \\<br />
b_{21} &amp; b_{22} &amp; \cdots &amp; b_{2n} \\<br />
\cdots &amp; \cdots &amp; \cdots &amp; \cdots \\<br />
b_{m1} &amp; b_{m2} &amp; \cdots &amp; b_{mn}
\end{bmatrix}$</li>
</ul>

<p><br /></p>

<ul>
  <li>$A + B = $
$\begin{bmatrix}
a_{11} + b_{11} &amp; a_{12} + b_{12} &amp; \cdots &amp; a_{1n} +b_{1n} \\<br />
a_{21} + b_{21} &amp; a_{21} +b_{22} &amp; \cdots &amp; a_{21} +b_{2n} \\<br />
\cdots &amp; \cdots &amp; \cdots &amp; \cdots \\<br />
a_{m1} + b_{m1} &amp; a_{m2} + b_{m2} &amp; \cdots &amp; a_{mn} + b_{mn}
\end{bmatrix}$</li>
</ul>

<p><br /></p>

<ul>
  <li>$A - B = $
$\begin{bmatrix}
a_{11} - b_{11} &amp; a_{12} - b_{12} &amp; \cdots &amp; a_{1n} - b_{1n} \\<br />
a_{21} - b_{21} &amp; a_{21} - b_{22} &amp; \cdots &amp; a_{21} - b_{2n} \\<br />
\cdots &amp; \cdots &amp; \cdots &amp; \cdots \\<br />
a_{m1} - b_{m1} &amp; a_{m2} - b_{m2} &amp; \cdots &amp; a_{mn} - b_{mn}
\end{bmatrix}$</li>
</ul>

<h2 id="행렬의-덧셈과-뺄셈의-특징">행렬의 덧셈과 뺄셈의 특징</h2>

<blockquote>
  <p>다음과 같은 행렬 $A, B, C$ 가 있다.</p>
</blockquote>

<ul>
  <li>
    <p>$A =$
$\begin{bmatrix}
1 &amp; 3  &amp; 5 \\<br />
7 &amp; 9  &amp; 11 \\<br />
13 &amp; 15 &amp; 17
\end{bmatrix}$ $B = $
$\begin{bmatrix}
2 &amp; 4  &amp; 6 \\<br />
8 &amp; 10  &amp; 12 \\<br />
14 &amp; 16 &amp; 18
\end{bmatrix}$ $C = $
$\begin{bmatrix}
3 &amp; 6  &amp; 9 \\  <br />
12 &amp; 15 &amp; 18
\end{bmatrix}$</p>
  </li>
  <li>
    <p>행렬 $A, B, C$ 중 크기가 $3 \times 3$ 인 행렬 $A,B$ 는 덧셈이나 뺄셈이 가능하나, 크기가 $2 \times 3$ 인 $C$ 는 불가능하다.</p>
  </li>
  <li>
    <p>$A + B = $
$\begin{bmatrix}
3 &amp; 7  &amp; 11 \\<br />
15 &amp; 19  &amp; 23 \\<br />
27 &amp; 31 &amp; 35
\end{bmatrix}$ $\quad B + A = $
$\begin{bmatrix}
3 &amp; 7  &amp; 11 \\<br />
15 &amp; 19  &amp; 23 \\<br />
27 &amp; 31 &amp; 35
\end{bmatrix}$</p>
  </li>
  <li>
    <p>$A - B = $
$\begin{bmatrix}
-1 &amp; -1  &amp; -1 \\<br />
-1 &amp; -1  &amp; -1 \\<br />
-1 &amp; -1 &amp; -1
\end{bmatrix}$ $\quad B - A = $
$\begin{bmatrix}
1 &amp; 1  &amp; 1 \\<br />
1 &amp; 1  &amp; 1 \\<br />
1 &amp; 1 &amp; 1
\end{bmatrix}$</p>
  </li>
</ul>

<blockquote>
  <p>실수의 덧셈, 뺄셈과 마찬가지로 행렬의 덧셈은 교환법칙이 성립하고, 뺄셈은 교환법칙이 성립하지 않는다.</p>
</blockquote>

<p><br /></p>

<h1 id="행렬의-스칼라-곱">행렬의 스칼라 곱</h1>

<blockquote>
  <p><span style="color:red">스칼라(scalar)</span>는 하나의 수로 표현할 수 있는 값이다. 일반적으로 사용하는 실수는 스칼라에 해당한다.</p>
</blockquote>

<ul>
  <li>행렬과 스칼라 사이에는 곱셈 연산이 가능하다.</li>
</ul>

<h2 id="정의-1">정의</h2>

<blockquote>
  <p>행렬 $A$ 에 실수 $k$ 를 곱하는 연산</p>
</blockquote>

<p>$kA = k \times A = [ka_{ij}] = k$
$\begin{bmatrix}
a_{11} &amp; a_{12} &amp; \cdots &amp; a_{1n} \\<br />
a_{21} &amp; a_{22} &amp; \cdots &amp; a_{2n} \\<br />
\cdots &amp; \cdots &amp; \cdots &amp; \cdots \\<br />
a_{m1} &amp; a_{m2} &amp; \cdots &amp; a_{mn}
\end{bmatrix} = $
$\begin{bmatrix}
ka_{11} &amp; ka_{12} &amp; \cdots &amp; ka_{1n} \\<br />
ka_{21} &amp; ka_{22} &amp; \cdots &amp; ka_{2n} \\<br />
\cdots &amp; \cdots &amp; \cdots &amp; \cdots \\<br />
ka_{m1} &amp; ka_{m2} &amp; \cdots &amp; ka_{mn}
\end{bmatrix}$</p>

<h2 id="예시">예시</h2>

<ul>
  <li>$5A = 5 \times A =  5 \times$
$\begin{bmatrix}
1 &amp; 2 &amp; 3 \\<br />
4 &amp; 5 &amp; 6 \\<br />
7 &amp; 8 &amp; 9
\end{bmatrix} = $
$\begin{bmatrix}
5 &amp; 10 &amp; 15 \\<br />
20 &amp; 25 &amp; 30 \\<br />
35 &amp; 40 &amp; 45
\end{bmatrix}$</li>
</ul>

<p><br /><br /></p>

<h1 id="행렬의-곱셈">행렬의 곱셈</h1>

<h2 id="정의-2">정의</h2>
<blockquote>
  <p>$m \times n$ 행렬 $A$ 와 $n \times r$ 행렬 $B$ 가 있을 때, 다음 연산식을 이용하여 구하는 $m \times r$ 행렬 $C$</p>
  <ul>
    <li>$AB = A \times B = C = [c_{ij}]$</li>
    <li>$c_{ij} = a_{i1}b_{1j} + a_{i2}b_{2j} + \cdots a_{in}b_{nj} = \sum_{k=1}^N a_{ik}b_{kj}$</li>
  </ul>
</blockquote>

<ul>
  <li>$A = [a_{ij}] = $
$\begin{bmatrix}
a_{11} &amp; a_{12} &amp; \cdots &amp; a_{1n} \\<br />
a_{21} &amp; a_{22} &amp; \cdots &amp; a_{2n} \\<br />
\cdots &amp; \cdots &amp; \cdots &amp; \cdots \\<br />
a_{m1} &amp; a_{m2} &amp; \cdots &amp; a_{mn}
\end{bmatrix}$ $,\quad B = [b_{ij}] = $
$\begin{bmatrix}
b_{11} &amp; b_{12} &amp; \cdots &amp; b_{1n} \\<br />
b_{21} &amp; b_{22} &amp; \cdots &amp; b_{2n} \\<br />
\cdots &amp; \cdots &amp; \cdots &amp; \cdots \\<br />
b_{m1} &amp; b_{m2} &amp; \cdots &amp; b_{mn}
\end{bmatrix}$ 일 때,</li>
</ul>

<p><br /></p>

<ul>
  <li>$AB = A \times B = $
$\begin{bmatrix}
a_{11} &amp; a_{12} &amp; \cdots &amp; a_{1n} \\<br />
a_{21} &amp; a_{22} &amp; \cdots &amp; a_{2n} \\<br />
\cdots &amp; \cdots &amp; \cdots &amp; \cdots \\<br />
a_{m1} &amp; a_{m2} &amp; \cdots &amp; a_{mn}
\end{bmatrix} \times $
$\begin{bmatrix}
b_{11} &amp; b_{12} &amp; \cdots &amp; b_{1n} \\<br />
b_{21} &amp; b_{22} &amp; \cdots &amp; b_{2n} \\<br />
\cdots &amp; \cdots &amp; \cdots &amp; \cdots \\<br />
b_{m1} &amp; b_{m2} &amp; \cdots &amp; b_{mn}
\end{bmatrix} = $
$\begin{bmatrix}
c_{11} &amp; c_{12} &amp; \cdots &amp; c_{1n} \\<br />
c_{21} &amp; c_{22} &amp; \cdots &amp; c_{2n} \\<br />
\cdots &amp; \cdots &amp; \cdots &amp; \cdots \\<br />
c_{m1} &amp; c_{m2} &amp; \cdots &amp; c_{mn}
\end{bmatrix}$</li>
</ul>

<p><br /></p>

<ul>
  <li>$\begin{bmatrix}
a_{11}b_{11} + a_{12}b_{21} + \cdots + a_{1n}b_{n1} &amp; a_{11}b_{12} + a_{12}b_{22} + \cdots + a_{1n}b_{n2} &amp; \cdots &amp; a_{11}b_{1r} + a_{12}b_{2r} + \cdots + a_{1n}b_{nr} \\<br />
a_{21}b_{11} + a_{22}b_{21} + \cdots + a_{2n}b_{n1} &amp; a_{21}b_{12} + a_{22}b_{22} + \cdots + a_{2n}b_{n2} &amp; \cdots &amp; a_{21}b_{1r} + a_{22}b_{2r} + \cdots + a_{2n}b_{nr}\\<br />
\cdots &amp; \cdots &amp; \cdots &amp; \cdots \\<br />
a_{m1}b_{11} + a_{m2}b_{21} + \cdots + a_{mn}b_{n1} &amp; a_{m1}b_{12} + a_{m2}b_{22} + \cdots + a_{mn}b_{n2} &amp; \cdots &amp; a_{m1}b_{1r} + a_{m2}b_{2r} + \cdots + a_{mn}b_{nr}
\end{bmatrix}$</li>
</ul>

<p><img src="/assets/images/Math/dm/dm_example_7_1.png" /></p>

<h2 id="예시-1">예시</h2>
<ul>
  <li>다음 행렬 $A,B,C$ 가 있다.</li>
</ul>

<p>$A = $
$\begin{bmatrix}
1 &amp; 2  &amp; 3 \\<br />
4 &amp; 5  &amp; 6
\end{bmatrix}$ $\quad B = $
$\begin{bmatrix}
1 &amp; 1 &amp; 1 \\<br />
2 &amp; 2 &amp; 2 \\<br />
3 &amp; 3 &amp; 3
\end{bmatrix}$ $\quad C = $
$\begin{bmatrix}
1 &amp; 1\\ 
2 &amp; 2
\end{bmatrix}$</p>

<ul>
  <li>각 행렬의 크기는 다음과 같다.
    <ul>
      <li>$A = 2 \times 3$</li>
      <li>$B = 3 \times 3$</li>
      <li>$C = 2 \times 2$</li>
    </ul>
  </li>
  <li>곱셈 연산이 가능한 행렬 $(m \times n) \times (n \times r)$
    <ul>
      <li>
        <p>$A \times B = $
  $\begin{bmatrix}
  14 &amp; 14 &amp; 14 \\<br />
  32 &amp; 32 &amp; 32
  \end{bmatrix}$</p>
      </li>
      <li>
        <p>$C \times A = $
  $\begin{bmatrix}
  5 &amp; 7 &amp; 9 \\<br />
  10 &amp; 14 &amp; 18
  \end{bmatrix}$</p>
      </li>
    </ul>
  </li>
</ul>

<h1 id="행렬-연산의-성질">행렬 연산의 성질</h1>

<blockquote>
  <p>행렬 $A,B,C$, 영행렬 $O$, 단위행렬 $I$ 와 스칼라 $k$ 에 대하여 다음이 성립한다.</p>
</blockquote>

<ol>
  <li>$A + B = B + A$</li>
  <li>$A + O = O + A = A$</li>
  <li>$(-1)A = -A$</li>
  <li>$(k+l)A = kA + lA$</li>
  <li>$kAB = (kA)B = A(kB)$</li>
  <li>$AO = OA = O$</li>
  <li>$A + (B+C) = (A + B) + C$</li>
  <li>$A + (-A) = (-A) + A = O$</li>
  <li>$k(A+B) = kA + kB$</li>
  <li>$(kl)A = k(lA)$</li>
  <li>$AI = IA = A$</li>
</ol>

<hr />

<h1 id="참고-문헌">참고 문헌</h1>
<ul>
  <li>박주미, ⌜컴퓨팅 사고력을 키우는 이산 수학수학 3판⌟ , 2023 , 한빛아카데미 , p205 ~ p213</li>
</ul>]]></content><author><name>지지형</name></author><category term="Discrete Mathematics" /><summary type="html"><![CDATA[행렬의 연산]]></summary></entry><entry><title type="html">[백준] 1436 : 영화감독 숌 (파이썬)</title><link href="http://localhost:4000/boj/BOJ-1436/" rel="alternate" type="text/html" title="[백준] 1436 : 영화감독 숌 (파이썬)" /><published>2023-11-23T00:00:00+09:00</published><updated>2023-11-23T00:00:00+09:00</updated><id>http://localhost:4000/boj/BOJ-1436</id><content type="html" xml:base="http://localhost:4000/boj/BOJ-1436/"><![CDATA[<h1 id="-난이도">🔎 난이도</h1>
<blockquote>
  <p>⚪️ <strong>실버 5</strong></p>
</blockquote>

<h1 id="️-문제">✏️ 문제</h1>
<blockquote>
  <p><a href="https://www.acmicpc.net/problem/1436">https://www.acmicpc.net/problem/1436</a></p>
</blockquote>

<p><img src="/assets/images/Coding_test/Boj/BOJ_1436_1.png" />
<br /></p>

<h1 id="-예제-입력-및-출력">🤖 예제 입력 및 출력</h1>

<p><img src="/assets/images/Coding_test/Boj/BOJ_1436_2.png" /></p>

<p><br /></p>

<h1 id="-알고리즘-분류">📑 알고리즘 분류</h1>

<ul>
  <li>브루트포스 알고리즘</li>
</ul>

<p><br /></p>

<h1 id="-아이디어">🧐 아이디어</h1>

<ul>
  <li>처음에 규칙이 있을거라 생각했다.
    <ul>
      <li>666 ${\rightarrow}$ 1666 ${\rightarrow}$ … ${\rightarrow}$ 6660 ${\rightarrow}$ 6661 ${\rightarrow}$ 6662 ${\rightarrow}$ … ${\rightarrow}$ 6669 ${\rightarrow}$ 7666 ${\rightarrow}$ …</li>
    </ul>
  </li>
  <li>위와 같이 666 의 뒤로 0 ~ 9 까지 진행하는 경우와 666 앞으로 진행하는 규칙이 있기 때문에 일관된 규칙을 찾기 어려웠습니다.</li>
  <li>그리고 코드가 복잡해질거라 생각하여 첫 번째 제목인 ‘666’ 부터 1씩 더해가며 666이 들어간 숫자를 찾아내는 완전탐색 방식을 채택하여 풀이했습니다.</li>
</ul>

<p><br /></p>

<h1 id="-내-풀이">📝 내 풀이</h1>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># 입력
</span><span class="n">n</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">input</span><span class="p">())</span>

<span class="c1"># 영화 제목
</span><span class="n">title</span> <span class="o">=</span> <span class="mi">666</span>

<span class="c1"># n과 비교할 숫자
</span><span class="n">cnt</span> <span class="o">=</span> <span class="mi">0</span>

<span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
    <span class="c1"># 666이 영화제목에 들어가면 cnt = cnt + 1
</span>    <span class="k">if</span> <span class="s">'666'</span> <span class="ow">in</span> <span class="nb">str</span><span class="p">(</span><span class="n">title</span><span class="p">):</span>
      <span class="n">cnt</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="c1"># n과 cnt가 같으면 while문 탈출
</span>    <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="n">cnt</span><span class="p">:</span>
        <span class="k">break</span>
    
    <span class="c1"># 영화 제목 + 1
</span>    <span class="n">title</span> <span class="o">+=</span> <span class="mi">1</span>

<span class="c1"># 출력
</span><span class="k">print</span><span class="p">(</span><span class="n">title</span><span class="p">)</span>
</code></pre></div></div>
<p><br /></p>

<h1 id="-풀이-리뷰">😳 풀이 리뷰</h1>

<ul>
  <li>N번째로 큰 영화 제목을 찾을 때 연산의 횟수를 알수없기에 While문을 통해 반복했습니다.</li>
  <li>while문 종료 조건으로 n과 cnt를 비교하여 반복문을 탈출하게 설정했습니다.</li>
  <li>title을 1씩 더해가며 ‘666’이 포함될 때 cnt = cnt + 1</li>
</ul>]]></content><author><name>지지형</name></author><category term="BOJ" /><summary type="html"><![CDATA[🔎 난이도 ⚪️ 실버 5]]></summary></entry><entry><title type="html">[이산수학] 행렬(Matrix) : 01_행렬의 개념</title><link href="http://localhost:4000/discrete%20mathematics/DM-06/" rel="alternate" type="text/html" title="[이산수학] 행렬(Matrix) : 01_행렬의 개념" /><published>2023-11-23T00:00:00+09:00</published><updated>2023-11-23T00:00:00+09:00</updated><id>http://localhost:4000/discrete%20mathematics/DM-06</id><content type="html" xml:base="http://localhost:4000/discrete%20mathematics/DM-06/"><![CDATA[<h1 id="행렬-matrix">행렬 (Matrix)</h1>

<ul>
  <li>
    <p>행렬은 연립일차방적식을 풀기 위해 사용되는 수의 구조이다.</p>
  </li>
  <li>
    <p>2차원 배열 형태인 행렬은 두 개 이상의 집합을 구성하는 원소 간의 관계를 표현하기에 적합하다.</p>
  </li>
  <li>
    <p>행렬은 데이터 연산 구조, 네트워크 모델, 선형 모델등과 같은 수학적 모델을 표현하는데 활용된다.</p>
  </li>
</ul>

<blockquote>
  <p>인공지능 관련해서 Python의 라이브러리 numpy를 활용할 때 행렬에 대한 지식이 필수적이라 느껴 정리했습니다.</p>
</blockquote>

<h1 id="행렬의-개념">행렬의 개념</h1>

<h2 id="정의">정의</h2>
<blockquote>
  <p>하나 이상의 원소를 1차원 또는 2차원의 형태로 나열한 배열<br />
$m$ 행 $n$ 열로 나열한 실수의 2차원 배열 ($m &gt; 0, n &gt; 0$)</p>
</blockquote>

<ul>
  <li>
    <p>$A = [a_{ij}] \quad (1 \le i \le m, \quad 1 \le j \le n)$</p>
  </li>
  <li>
    <p>$\begin{bmatrix}
a_{11} &amp; a_{12} &amp; \cdots &amp; a_{1n} \\<br />
a_{21} &amp; a_{22} &amp; \cdots &amp; a_{2n} \\<br />
\cdots &amp; \cdots &amp; \cdots &amp; \cdots \\<br />
a_{m1} &amp; a_{m2} &amp; \cdots &amp; a_{mn}
\end{bmatrix}$</p>
  </li>
</ul>

<h2 id="행렬의-표현">행렬의 표현</h2>

<ul>
  <li>
    <p>행렬 (matrix : $A = [a_{ij}]$)</p>
  </li>
  <li>가로줄 : 행 (row)
    <ul>
      <li>행 크기 : 한 행을 이루는 원소의 개수</li>
    </ul>
  </li>
  <li>세로줄 : 열(column)
    <ul>
      <li>열 크기 : 한 열을 이루는 원소의 개수</li>
    </ul>
  </li>
</ul>

<ol>
  <li>영어 대문자 : $A, B, C \cdots$</li>
  <li>원소 표기 : $[a_{ij}]$</li>
</ol>

<ul>
  <li>행렬의 크기를 이용하여 나타내기
    <ul>
      <li>행 : $m$행, $\quad$ 열 : $n$열</li>
      <li>$m \times n $ 행렬</li>
    </ul>
  </li>
  <li>행렬의 위치를 이용하여 나타내기
    <ul>
      <li>행 번호($i$), 열번호($j$)</li>
      <li>$a_{ij}$ 는 $i$ 행 $j$ 열에 위치한 원소를 의미한다.</li>
    </ul>
  </li>
</ul>

<h3 id="예시">예시</h3>
<p><br /></p>

<p>$A = \begin{bmatrix}
1 &amp; 2 &amp; 3 &amp; 4 \\<br />
5 &amp; 6 &amp; 7 &amp; 8 \\<br />
8 &amp; 7 &amp; 6 &amp; 5 \\<br />
4 &amp; 3 &amp; 2 &amp; 1
\end{bmatrix}$</p>

<ul>
  <li>
    <p>위 행렬 A는 행 4개와 열 4개로 구성된 행렬이다.</p>
  </li>
  <li>
    <p>크기가 4행 4열인 행렬 또는 $4 \times 4$ (4 - by - 4)로 표현할 수 있다.</p>
  </li>
  <li>
    <p>행렬 A의 1행은 $\begin{bmatrix} 1 &amp; 2 &amp; 3 &amp; 4 \end{bmatrix}$ 이다.</p>
  </li>
  <li>
    <p>행렬 A의 1열은 $\begin{bmatrix}1 \\   5 \\   8 \\   4\end{bmatrix}$ 이다.</p>
  </li>
  <li>
    <p>원소표기법을 이용하면 행렬 $A$의 $a_{11}$ 은 $1$ 이고, $a_{44}$ 도 1이다.</p>
    <ul>
      <li>행렬 $A$ 에서 $a_{11}$ 과 $a_{44}$는 $1$이라는 동일한 값을 가지나, 서로 다른 원소로 구분된다.</li>
    </ul>
  </li>
</ul>

<h1 id="기본적인-행렬">기본적인 행렬</h1>

<h2 id="영행렬-zero-matrix--o">영행렬 (zero matrix : $O$)</h2>

<h3 id="정의-1">정의</h3>

<blockquote>
  <p>$m \times n$ 행렬 $A = [a_{ij}]$가 있을 때 모든 $i, j$ 에 대하여 $a_{ij} = 0$ 인 행렬</p>
</blockquote>

<ul>
  <li>$O =$
$\begin{bmatrix}
0 &amp; 0 &amp; \cdots &amp; 0 \\<br />
0 &amp; 0 &amp; \cdots &amp; 0 \\<br />
\cdots &amp; \cdots &amp; \cdots &amp; \cdots \\<br />
0 &amp; 0 &amp; \cdots &amp; 0 \\<br />
\end{bmatrix}$</li>
</ul>

<h2 id="n차-정사각행렬n-square-matrix">$n$차 정사각행렬(n-square matrix)</h2>

<h3 id="정의-2">정의</h3>

<blockquote>
  <p>$m \times n$ 행렬 $A = [a_{ij}]$ 가 있을 때 $m = n$인 행렬</p>
</blockquote>

<ul>
  <li>$A =$
$\begin{bmatrix}
a_{11} &amp; a_{12} &amp; \cdots &amp; a_{1n} \\<br />
a_{21} &amp; a_{22} &amp; \cdots &amp; a_{2n} \\<br />
\cdots &amp; \cdots &amp; \cdots &amp; \cdots \\<br />
a_{n1} &amp; a_{n2} &amp; \cdots &amp; a_{nn}
\end{bmatrix}$</li>
</ul>

<h3 id="주대각-원소-main-diagonal-element">주대각 원소 (main diagonal element)</h3>
<blockquote>
  <p>정사각형 행렬에서 행렬의 원소 $a_{ij}$ 중 $i = j$ 인 원소를 <strong>주대각 원소(main diagonal element)</strong>라고 한다.</p>
</blockquote>

<h4 id="예시-1">예시</h4>

<ul>
  <li>
    <p>$A =$ 
$\begin{bmatrix}
1 &amp; 3 &amp; 5 &amp; 7 \\<br />
5 &amp; 2 &amp; 7 &amp; 8 \\<br />
8 &amp; 7 &amp; 3 &amp; 5 \\<br />
4 &amp; 3 &amp; 2 &amp; 4
\end{bmatrix}$</p>

    <ul>
      <li>행렬 $A$ 의 원소 $a_{11}, a_{22}, a_{33}, a_{44}$ 에 해당하는 $1, 2, 3, 4$는 행렬 $A$ 의 <strong>주대각 원소</strong>이다.</li>
    </ul>
  </li>
</ul>

<h2 id="단위행렬-unit-matrix--i--항등행렬">단위행렬 (unit matrix : $I$ ), 항등행렬</h2>

<h3 id="정의-3">정의</h3>

<blockquote>
  <p>주대각 원소만 1 이고 나머지 원소는 모두 0 인 행렬</p>
</blockquote>

<ul>
  <li>단위행렬은 정사각행렬인 경우에만 존재하며 행렬의 곱셈에서 항등원 역할을 하기때문에 항등행렬이라고 말한다.</li>
</ul>

<p><br /></p>

<ul>
  <li>$I =$
$\begin{bmatrix}
1 &amp; 0 &amp; \cdots &amp; 0 \\<br />
0 &amp; 1 &amp; \cdots &amp; 0 \\<br />
\cdots &amp; \cdots &amp; \cdots &amp; \cdots \\<br />
0 &amp; 0 &amp; \cdots &amp; 1
\end{bmatrix}$</li>
</ul>

<hr />

<h1 id="참고-문헌">참고 문헌</h1>
<ul>
  <li>박주미, ⌜컴퓨팅 사고력을 키우는 이산 수학수학 3판⌟ , 2023 , 한빛아카데미 , p201 ~ p204</li>
</ul>]]></content><author><name>지지형</name></author><category term="Discrete Mathematics" /><summary type="html"><![CDATA[행렬 (Matrix)]]></summary></entry><entry><title type="html">[프로그래머스] Lv.01 : 삼총사 (파이썬)</title><link href="http://localhost:4000/programmers/Programmers-%EC%82%BC%EC%B4%9D%EC%82%AC/" rel="alternate" type="text/html" title="[프로그래머스] Lv.01 : 삼총사 (파이썬)" /><published>2023-11-04T00:00:00+09:00</published><updated>2023-11-04T00:00:00+09:00</updated><id>http://localhost:4000/programmers/Programmers-%EC%82%BC%EC%B4%9D%EC%82%AC</id><content type="html" xml:base="http://localhost:4000/programmers/Programmers-%EC%82%BC%EC%B4%9D%EC%82%AC/"><![CDATA[<h1 id="-난이도">🔎 난이도</h1>
<blockquote>
  <p><strong>Lv.01</strong></p>
</blockquote>

<h1 id="️-문제">✏️ 문제</h1>
<blockquote>
  <p><a href="https://school.programmers.co.kr/learn/courses/30/lessons/131705">https://school.programmers.co.kr/learn/courses/30/lessons/131705</a></p>
</blockquote>

<h1 id="️-문제-설명">✒️ 문제 설명</h1>
<p>한국중학교에 다니는 학생들은 각자 정수 번호를 갖고 있습니다.<br />
이 학교 학생 3명의 정수 번호를 더했을 때 0이 되면 3명의 학생은 삼총사라고 합니다.<br />
예를 들어, 5명의 학생이 있고, 각각의 정수 번호가 순서대로 $-2, 3, 0, 2, -5$ 일 때,<br />
첫 번째, 세 번째, 네 번째 학생의 정수 번호를 더하면 $0$ 이므로 세 학생은 삼총사입니다.<br />
또한, 두 번째, 네 번째, 다섯 번째 학생의 정수 번호를 더해도 $0$ 이므로 세 학생도 삼총사입니다.<br />
따라서 이 경우 한국 중학교에서는 두 가지 방법으로 삼총사를 만들 수 있습니다.</p>

<p>한국중학교 학생들의 번호를 나타내는 정수 배열 $number$ 가 매개변수로 주어질 때,<br />
학생들 중 삼총사를 만들 수 있는 방법의 수를 $return$ 하도록 $solution$ 함수를 완성하세요.</p>

<p><br /></p>

<h1 id="️-제한사항">🙅‍♂️ 제한사항</h1>
<ul>
  <li>
    <p>$3$ $\le$ $number$ 의 길이 $\le$ $13$</p>
  </li>
  <li>
    <p>$-1000$ $\le$ $number$ 의 각 원소 $\le$ $1000$</p>
  </li>
  <li>
    <p>서로 다른 학생의 정수 번호가 같을 수 있습니다.</p>
  </li>
</ul>

<h1 id="-입출력-예">🤖 입출력 예</h1>

<table>
  <thead>
    <tr>
      <th style="text-align: center">number</th>
      <th style="text-align: center">result</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">[-2, 3, 0, 2, -5]</td>
      <td style="text-align: center">2</td>
    </tr>
    <tr>
      <td style="text-align: center">[-3, -2, -1, 0, 1, 2, 3]</td>
      <td style="text-align: center">5</td>
    </tr>
    <tr>
      <td style="text-align: center">[-1, 1, -1, 1]</td>
      <td style="text-align: center">0</td>
    </tr>
  </tbody>
</table>

<h1 id="-입출력-예-설명">🤖 입출력 예 설명</h1>
<ul>
  <li>입출력 예 # 1
    <ul>
      <li>문제의 예시와 같습니다.</li>
    </ul>
  </li>
  <li>입출력 예 # 2
    <ul>
      <li>학생들의 정수 번호 쌍 (-3, 0, 3), (-2, 0, 2), (-1, 0, 1), (-2, -1, 3), (-3, 1, 2) 이 삼총사가 될 수 있으므로, 5를 return 합니다.</li>
    </ul>
  </li>
  <li>입출력 예 # 3
    <ul>
      <li>삼총사가 될 수 있는 방법이 없습니다.</li>
    </ul>
  </li>
</ul>

<p><br /></p>

<h1 id="-아이디어">🧐 아이디어</h1>
<blockquote>
  <p>number 리스트에서 3개의 원소를 뽑아 합이 0이되는 경우를 찾아 개수를 세는 문제였다.</p>
</blockquote>

<p><br /></p>

<h1 id="-내-풀이">📝 내 풀이</h1>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="k">def</span> <span class="nf">solution</span><span class="p">(</span><span class="n">number</span><span class="p">):</span>
    <span class="c1"># 출력 및 정답
</span>    <span class="n">answer</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="c1"># 3중 반복문을 통해 number 원소 3개씩 뽑기
</span>    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">number</span><span class="p">)</span><span class="o">-</span><span class="mi">2</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">number</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">number</span><span class="p">)):</span>
                <span class="c1"># 원소 3개의 합이 0이라면, 즉, 삼총사라면 정답 += 1
</span>                <span class="k">if</span> <span class="p">(</span><span class="n">number</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">number</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">+</span> <span class="n">number</span><span class="p">[</span><span class="n">k</span><span class="p">])</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">answer</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="n">answer</span>

</code></pre></div></div>
<p><br /></p>

<h1 id="-풀이-리뷰">😳 풀이 리뷰</h1>
<p>처음에는 DFS로 구현하여 풀었지만, 코드도 직관적이지 못하였고, 다시 보니 이해하기도 어려웠다.<br />
그래서 삼중 반복문을 통해 원소 3개를 뽑는 것을 구현하였다.<br />
삼중 반복문보다 더욱 간단하게 푸는 법은 itertools의 combinations 라이브러리를 활용하는 방법이 있다.</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">itertools</span> <span class="kn">import</span> <span class="n">combinations</span>
</code></pre></div></div>]]></content><author><name>지지형</name></author><category term="Programmers" /><summary type="html"><![CDATA[🔎 난이도 Lv.01 ✏️ 문제 https://school.programmers.co.kr/learn/courses/30/lessons/131705 ✒️ 문제 설명 한국중학교에 다니는 학생들은 각자 정수 번호를 갖고 있습니다. 이 학교 학생 3명의 정수 번호를 더했을 때 0이 되면 3명의 학생은 삼총사라고 합니다. 예를 들어, 5명의 학생이 있고, 각각의 정수 번호가 순서대로 $-2, 3, 0, 2, -5$ 일 때, 첫 번째, 세 번째, 네 번째 학생의 정수 번호를 더하면 $0$ 이므로 세 학생은 삼총사입니다. 또한, 두 번째, 네 번째, 다섯 번째 학생의 정수 번호를 더해도 $0$ 이므로 세 학생도 삼총사입니다. 따라서 이 경우 한국 중학교에서는 두 가지 방법으로 삼총사를 만들 수 있습니다. 한국중학교 학생들의 번호를 나타내는 정수 배열 $number$ 가 매개변수로 주어질 때, 학생들 중 삼총사를 만들 수 있는 방법의 수를 $return$ 하도록 $solution$ 함수를 완성하세요. 🙅‍♂️ 제한사항 $3$ $\le$ $number$ 의 길이 $\le$ $13$ $-1000$ $\le$ $number$ 의 각 원소 $\le$ $1000$ 서로 다른 학생의 정수 번호가 같을 수 있습니다. 🤖 입출력 예 number result [-2, 3, 0, 2, -5] 2 [-3, -2, -1, 0, 1, 2, 3] 5 [-1, 1, -1, 1] 0 🤖 입출력 예 설명 입출력 예 # 1 문제의 예시와 같습니다. 입출력 예 # 2 학생들의 정수 번호 쌍 (-3, 0, 3), (-2, 0, 2), (-1, 0, 1), (-2, -1, 3), (-3, 1, 2) 이 삼총사가 될 수 있으므로, 5를 return 합니다. 입출력 예 # 3 삼총사가 될 수 있는 방법이 없습니다. 🧐 아이디어 number 리스트에서 3개의 원소를 뽑아 합이 0이되는 경우를 찾아 개수를 세는 문제였다. 📝 내 풀이 def solution(number): # 출력 및 정답 answer = 0 # 3중 반복문을 통해 number 원소 3개씩 뽑기 for i in range(0, len(number)-2): for j in range(i+1, len(number)-1): for k in range(j+1, len(number)): # 원소 3개의 합이 0이라면, 즉, 삼총사라면 정답 += 1 if (number[i] + number[j] + number[k]) == 0: answer += 1 return answer 😳 풀이 리뷰 처음에는 DFS로 구현하여 풀었지만, 코드도 직관적이지 못하였고, 다시 보니 이해하기도 어려웠다. 그래서 삼중 반복문을 통해 원소 3개를 뽑는 것을 구현하였다. 삼중 반복문보다 더욱 간단하게 푸는 법은 itertools의 combinations 라이브러리를 활용하는 방법이 있다. from itertools import combinations]]></summary></entry><entry><title type="html">[백준] 1057 : 토너먼트 (파이썬)</title><link href="http://localhost:4000/boj/BOJ-1057/" rel="alternate" type="text/html" title="[백준] 1057 : 토너먼트 (파이썬)" /><published>2023-11-01T00:00:00+09:00</published><updated>2023-11-01T00:00:00+09:00</updated><id>http://localhost:4000/boj/BOJ-1057</id><content type="html" xml:base="http://localhost:4000/boj/BOJ-1057/"><![CDATA[<h1 id="-난이도">🔎 난이도</h1>
<blockquote>
  <p>⚪️ <strong>실버 4</strong></p>
</blockquote>

<h1 id="️-문제">✏️ 문제</h1>
<blockquote>
  <p><a href="https://www.acmicpc.net/problem/1057">https://www.acmicpc.net/problem/1057</a></p>
</blockquote>

<p><img src="/assets/images/Coding_test/Boj/BOJ_1057_1.png" />
<br /></p>

<h1 id="-예제-입력-및-출력">🤖 예제 입력 및 출력</h1>

<p><img src="/assets/images/Coding_test/Boj/BOJ_1057_2.png" /></p>

<p><br /></p>

<h1 id="-알고리즘-분류">📑 알고리즘 분류</h1>

<ul>
  <li>수학</li>
  <li>브루트포스 알고리즘</li>
</ul>

<p><br /></p>

<h1 id="-아이디어">🧐 아이디어</h1>
<p><br /></p>

<p><img src="/assets/images/Coding_test/boj/BOJ_1057_3.png" width="700" /></p>

<p><br /></p>

<p>고민하다 처음 생각한 아이디어이다.</p>

<ul>
  <li>0으로 이루어진 대진표 리스트와 김지민과 임한수의 인덱스를 1로 표시한다.</li>
  <li>대진표는 n // 2</li>
  <li>step을 2로 둔 for문을 통해 김지민과 임한수가 대결했을 경우의 리스트 합이 2가 나올 것이다.</li>
</ul>

<p>이러한 아이디어를 뼈대로 잡고 코드를 작성했다.</p>

<p><br /></p>

<h1 id="-내-풀이">📝 내 풀이</h1>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># 입력
</span><span class="n">n</span><span class="p">,</span> <span class="n">kim</span><span class="p">,</span> <span class="n">lim</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">input</span><span class="p">().</span><span class="n">split</span><span class="p">())</span>

<span class="c1"># 출력값
</span><span class="nb">round</span> <span class="o">=</span> <span class="mi">0</span>

<span class="c1"># 인덱스
</span><span class="n">kim</span> <span class="o">-=</span> <span class="mi">1</span>
<span class="n">lim</span> <span class="o">-=</span> <span class="mi">1</span>

<span class="k">if</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span> <span class="c1"># 서로 대결하지 않을 경우
</span>    <span class="k">print</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<span class="k">else</span><span class="p">:</span>
    <span class="k">while</span> <span class="n">n</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="nb">round</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="n">table</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">n</span> <span class="c1"># 대진표 생성
</span>
        <span class="n">table</span><span class="p">[</span><span class="n">kim</span><span class="p">],</span> <span class="n">table</span><span class="p">[</span><span class="n">lim</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span><span class="mi">1</span> <span class="c1"># 김, 임 대진 자리 표시
</span>
        <span class="c1"># 출력 (김지민과 임한수가 만났을 경우 break)
</span>        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="mi">2</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">sum</span><span class="p">(</span><span class="n">table</span><span class="p">[</span><span class="n">i</span> <span class="p">:</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">2</span><span class="p">])</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="k">print</span><span class="p">(</span><span class="nb">round</span><span class="p">)</span>
                <span class="k">break</span>
    
        <span class="c1"># n이 홀수 일 경우
</span>        <span class="k">if</span> <span class="n">n</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span> <span class="n">n</span> <span class="o">=</span> <span class="n">n</span> <span class="o">//</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span> <span class="n">n</span> <span class="o">//=</span> <span class="mi">2</span>

        <span class="n">kim</span> <span class="o">//=</span> <span class="mi">2</span>
        <span class="n">lim</span> <span class="o">//=</span> <span class="mi">2</span>
</code></pre></div></div>
<p><br /></p>

<h1 id="-풀이-리뷰">😳 풀이 리뷰</h1>

<blockquote>
  <p>생각한 아이디어를 충실히(?) 이행하며, 코드를 짜다보니 많이 복잡해졌다.<br />
while문이 한 번 돌 때마다 round(정답), 대진표, 인덱스 표시를 갱신 한다. <br />
for 문을 통해 김지민과 임한수가 대결 유무를 판단한다.<br />
대결을 했을 경우 탈출, 대결하지 않았을 경우 n과 kim.lim 를 // 2를 해준다.</p>
</blockquote>

<h1 id="-다른-사람-풀이">😳 다른 사람 풀이</h1>

<blockquote>
  <p>사실 이 문제는 수학적으로 해결이 가능한 문제였다. 필자는 n 길이의 리스트에 직접 김지민과 임한수의 위치를 표시하며 n,김지민,임한수의 2로 나누며 문제를 해결했다.</p>
</blockquote>

<blockquote>
  <p>이 문제의 핵심은 김지민과 임한수의 인덱스가 8,9 라고 할 때, 예시의 식을 이용하는 것이었다.</p>
</blockquote>

<ul>
  <li>김지민 : 8 $\rightarrow$ 4 $\rightarrow$ 2 $\rightarrow$ 1 $\rightarrow$ 1</li>
  <li>임한수 : 9 $\rightarrow$ 5 $\rightarrow$ 3 $\rightarrow$ 2 $\rightarrow$ 1</li>
</ul>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># 입력
</span><span class="n">n</span><span class="p">,</span> <span class="n">kim</span> <span class="p">,</span><span class="n">lim</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">input</span><span class="p">().</span><span class="n">split</span><span class="p">())</span>

<span class="c1"># 출력
</span><span class="nb">round</span> <span class="o">=</span> <span class="mi">0</span>

<span class="k">while</span> <span class="n">kim</span> <span class="o">!=</span> <span class="n">lim</span><span class="p">:</span>
  
    <span class="n">kim</span> <span class="o">-=</span> <span class="n">kim</span> <span class="o">//</span> <span class="mi">2</span>
  
    <span class="n">lim</span> <span class="o">-=</span> <span class="n">lim</span> <span class="o">//</span> <span class="mi">2</span>
  
    <span class="nb">round</span> <span class="o">+=</span> <span class="mi">1</span>

<span class="k">print</span><span class="p">(</span><span class="nb">round</span><span class="p">)</span>
</code></pre></div></div>]]></content><author><name>지지형</name></author><category term="BOJ" /><summary type="html"><![CDATA[🔎 난이도 ⚪️ 실버 4 ✏️ 문제 https://www.acmicpc.net/problem/1057 🤖 예제 입력 및 출력 📑 알고리즘 분류 수학 브루트포스 알고리즘 🧐 아이디어 고민하다 처음 생각한 아이디어이다. 0으로 이루어진 대진표 리스트와 김지민과 임한수의 인덱스를 1로 표시한다. 대진표는 n // 2 step을 2로 둔 for문을 통해 김지민과 임한수가 대결했을 경우의 리스트 합이 2가 나올 것이다. 이러한 아이디어를 뼈대로 잡고 코드를 작성했다. 📝 내 풀이 # 입력 n, kim, lim = map(int, input().split()) # 출력값 round = 0 # 인덱스 kim -= 1 lim -= 1 if n &lt; 2: # 서로 대결하지 않을 경우 print(-1) else: while n != 1: round += 1 table = [0] * n # 대진표 생성 table[kim], table[lim] = 1,1 # 김, 임 대진 자리 표시 # 출력 (김지민과 임한수가 만났을 경우 break) for i in range(0, n, 2): if sum(table[i : i + 2]) == 2: print(round) break # n이 홀수 일 경우 if n % 2 == 1: n = n // 2 + 1 else: n //= 2 kim //= 2 lim //= 2 😳 풀이 리뷰 생각한 아이디어를 충실히(?) 이행하며, 코드를 짜다보니 많이 복잡해졌다. while문이 한 번 돌 때마다 round(정답), 대진표, 인덱스 표시를 갱신 한다. for 문을 통해 김지민과 임한수가 대결 유무를 판단한다. 대결을 했을 경우 탈출, 대결하지 않았을 경우 n과 kim.lim 를 // 2를 해준다. 😳 다른 사람 풀이 사실 이 문제는 수학적으로 해결이 가능한 문제였다. 필자는 n 길이의 리스트에 직접 김지민과 임한수의 위치를 표시하며 n,김지민,임한수의 2로 나누며 문제를 해결했다. 이 문제의 핵심은 김지민과 임한수의 인덱스가 8,9 라고 할 때, 예시의 식을 이용하는 것이었다. 김지민 : 8 $\rightarrow$ 4 $\rightarrow$ 2 $\rightarrow$ 1 $\rightarrow$ 1 임한수 : 9 $\rightarrow$ 5 $\rightarrow$ 3 $\rightarrow$ 2 $\rightarrow$ 1 # 입력 n, kim ,lim = map(int, input().split()) # 출력 round = 0 while kim != lim: kim -= kim // 2 lim -= lim // 2 round += 1 print(round)]]></summary></entry><entry><title type="html">[프로그래머스] Lv.01 : 같은 숫자는 싫어 (파이썬)</title><link href="http://localhost:4000/programmers/Programmers-%EA%B0%99%EC%9D%80-%EC%88%AB%EC%9E%90%EB%8A%94-%EC%8B%AB%EC%96%B4/" rel="alternate" type="text/html" title="[프로그래머스] Lv.01 : 같은 숫자는 싫어 (파이썬)" /><published>2023-10-27T00:00:00+09:00</published><updated>2023-10-27T00:00:00+09:00</updated><id>http://localhost:4000/programmers/Programmers-%EA%B0%99%EC%9D%80%20%EC%88%AB%EC%9E%90%EB%8A%94%20%EC%8B%AB%EC%96%B4</id><content type="html" xml:base="http://localhost:4000/programmers/Programmers-%EA%B0%99%EC%9D%80-%EC%88%AB%EC%9E%90%EB%8A%94-%EC%8B%AB%EC%96%B4/"><![CDATA[<h1 id="-난이도">🔎 난이도</h1>
<blockquote>
  <p><strong>Lv.01</strong></p>
</blockquote>

<h1 id="️-문제">✏️ 문제</h1>
<blockquote>
  <p><a href="https://school.programmers.co.kr/learn/courses/30/lessons/12906">https://school.programmers.co.kr/learn/courses/30/lessons/12906</a></p>
</blockquote>

<h1 id="️-문제-설명">✒️ 문제 설명</h1>
<p>배열 arr가 주어집니다. 배열 arr의 각 원소는 숫자 0부터 9까지로 이루어져있습니다.<br />
이때, 배열 arr에서 연속적으로 나타나는 숫자는 하나만 남기고 전부 제거하려고 합니다.<br />
단, 제거 된 후 남은 수들을 반환할 때는 배열 arr의 원소들의 순서를 유지해야 합니다.</p>

<ul>
  <li>arr = [1, 1, 3, 3, 0, 1, 1] 이면 [1, 3, 0, 1] 을 return 합니다.</li>
  <li>arr = [4, 4, 4, 3, 3] 이면 [4, 3]을 return 합니다.</li>
</ul>

<p>배열 arr 에서 연속적으로 나타나는 숫자는 제거하고 남은 수들을 return 하는 solution 함수를 완성해 주세요.</p>

<p><br /></p>

<h1 id="️-제한사항">🙅‍♂️ 제한사항</h1>
<ul>
  <li>배열 arr의 크기 : 1,000,000 이하의 자연수</li>
  <li>배열 arr의 원소의 크기 : 0보다 크거나 같고 9보다 작거나 같은 정수</li>
</ul>

<h1 id="-입출력-예">🤖 입출력 예</h1>

<table>
  <thead>
    <tr>
      <th>arr</th>
      <th>answer</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>[1, 1, 3, 3, 0, 1 ,1]</td>
      <td>[1, 3, 0, 1]</td>
    </tr>
    <tr>
      <td>[4, 4, 4, 3, 3]</td>
      <td>[4, 3]</td>
    </tr>
  </tbody>
</table>

<h1 id="-입출력-예-설명">🤖 입출력 예 설명</h1>
<ul>
  <li>입출력 예 # 1,2 문제의 예시와 같습니다.</li>
</ul>

<p><br /></p>

<h1 id="-아이디어">🧐 아이디어</h1>
<p>단순히 연속된 숫자의 중복을 제거하는 문제였다면, Set 자료형을 통해 손 쉽게 풀 수 있었을 겁니다. 하지만 기존에 제시한 배열 arr의 순서를 보장해야하기 때문에 Set 자료형을 쓸 수 없습니다.</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">example</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">5</span><span class="p">]</span>

<span class="n">set_example</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">example</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">set_example</span><span class="p">)</span>
<span class="c1"># {1, 2, 3, 4, 5, 6}
</span></code></pre></div></div>

<p>순서 보장을 위해 원래 배열 그대로 탐색을 하며 answer 리스트에 arr 배열의 첫 번째 값(인덱스 = 0)을 넣어 준 후, 1부터 마지막 인덱스까지 전 후 값을 비교하여 다르다면 answer의 append 해주는 방법으로 풀었습니다.</p>

<p><br /></p>

<h1 id="-내-풀이">📝 내 풀이</h1>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">solution</span><span class="p">(</span><span class="n">arr</span><span class="p">):</span>
    <span class="n">answer</span> <span class="o">=</span> <span class="p">[</span><span class="n">arr</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="c1"># arr의 첫 번째 원소
</span>    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">arr</span><span class="p">)):</span> <span class="c1"># 1 ~ arr의 길이 만큼 반복 (길이가 n이라면 n-1 반복)
</span>        <span class="k">if</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span> <span class="c1"># arr배열의 전,후 값 비교 (1,0) (2,1) (3,2) ...
</span>            <span class="n">answer</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="c1"># 같지 않다면 answer 리스트에 원소 추가
</span>    <span class="k">return</span> <span class="n">answer</span>
</code></pre></div></div>
<p><br /></p>

<h1 id="-다른-풀이">😳 다른 풀이</h1>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">diff_solution</span><span class="p">(</span><span class="n">arr</span><span class="p">):</span>
    <span class="n">answer</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">arr</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">answer</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">:]</span> <span class="o">!=</span> <span class="p">[</span><span class="n">i</span><span class="p">]:</span>
            <span class="n">answer</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">answer</span>
</code></pre></div></div>

<p>answer의 마지막 원소와 현재 i와 비교를 하며 같지 않을 경우, 즉, 중복되지 않을 경우 answer 리스트에 원소를 추가하는 방법입니다.</p>]]></content><author><name>지지형</name></author><category term="Programmers" /><summary type="html"><![CDATA[🔎 난이도 Lv.01 ✏️ 문제 https://school.programmers.co.kr/learn/courses/30/lessons/12906 ✒️ 문제 설명 배열 arr가 주어집니다. 배열 arr의 각 원소는 숫자 0부터 9까지로 이루어져있습니다. 이때, 배열 arr에서 연속적으로 나타나는 숫자는 하나만 남기고 전부 제거하려고 합니다. 단, 제거 된 후 남은 수들을 반환할 때는 배열 arr의 원소들의 순서를 유지해야 합니다. arr = [1, 1, 3, 3, 0, 1, 1] 이면 [1, 3, 0, 1] 을 return 합니다. arr = [4, 4, 4, 3, 3] 이면 [4, 3]을 return 합니다. 배열 arr 에서 연속적으로 나타나는 숫자는 제거하고 남은 수들을 return 하는 solution 함수를 완성해 주세요. 🙅‍♂️ 제한사항 배열 arr의 크기 : 1,000,000 이하의 자연수 배열 arr의 원소의 크기 : 0보다 크거나 같고 9보다 작거나 같은 정수 🤖 입출력 예 arr answer [1, 1, 3, 3, 0, 1 ,1] [1, 3, 0, 1] [4, 4, 4, 3, 3] [4, 3] 🤖 입출력 예 설명 입출력 예 # 1,2 문제의 예시와 같습니다. 🧐 아이디어 단순히 연속된 숫자의 중복을 제거하는 문제였다면, Set 자료형을 통해 손 쉽게 풀 수 있었을 겁니다. 하지만 기존에 제시한 배열 arr의 순서를 보장해야하기 때문에 Set 자료형을 쓸 수 없습니다. example = [1,1,6,6,2,2,3,3,3,4,5,5] set_example = set(example) print(set_example) # {1, 2, 3, 4, 5, 6} 순서 보장을 위해 원래 배열 그대로 탐색을 하며 answer 리스트에 arr 배열의 첫 번째 값(인덱스 = 0)을 넣어 준 후, 1부터 마지막 인덱스까지 전 후 값을 비교하여 다르다면 answer의 append 해주는 방법으로 풀었습니다. 📝 내 풀이 def solution(arr): answer = [arr[0]] # arr의 첫 번째 원소 for i in range(1,len(arr)): # 1 ~ arr의 길이 만큼 반복 (길이가 n이라면 n-1 반복) if arr[i] != arr[i-1]: # arr배열의 전,후 값 비교 (1,0) (2,1) (3,2) ... answer.append(arr[i]) # 같지 않다면 answer 리스트에 원소 추가 return answer 😳 다른 풀이 def diff_solution(arr): answer = [] for i in arr: if answer[-1:] != [i]: answer.append(i) return answer answer의 마지막 원소와 현재 i와 비교를 하며 같지 않을 경우, 즉, 중복되지 않을 경우 answer 리스트에 원소를 추가하는 방법입니다.]]></summary></entry><entry><title type="html">[백준] 7568 : 덩치 (파이썬)</title><link href="http://localhost:4000/boj/BOJ-7568/" rel="alternate" type="text/html" title="[백준] 7568 : 덩치 (파이썬)" /><published>2023-10-20T00:00:00+09:00</published><updated>2023-10-20T00:00:00+09:00</updated><id>http://localhost:4000/boj/BOJ-7568</id><content type="html" xml:base="http://localhost:4000/boj/BOJ-7568/"><![CDATA[<h1 id="-난이도">🔎 난이도</h1>
<blockquote>
  <p>⚪️ <strong>실버 5</strong></p>
</blockquote>

<h1 id="️-문제">✏️ 문제</h1>
<blockquote>
  <p><a href="https://www.acmicpc.net/problem/7568">https://www.acmicpc.net/problem/7568</a></p>
</blockquote>

<p><img src="/assets/images/Coding_test/Boj/BOJ_7568_1.png" />
<img src="/assets/images/Coding_test/Boj/BOJ_7568_2.png" />
<br /></p>

<h1 id="-예제-입력-및-출력">🤖 예제 입력 및 출력</h1>

<p><img src="/assets/images/Coding_test/Boj/BOJ_7568_3.png" /></p>

<p><br /></p>

<h1 id="-알고리즘-분류">📑 알고리즘 분류</h1>

<ul>
  <li>구현</li>
  <li>브루트포스 알고리즘</li>
</ul>

<p><br /></p>

<h1 id="-아이디어">🧐 아이디어</h1>

<blockquote>
  <p>처음에 다양한 정렬을 해보며 시도하였지만, 풀수가 없었다. 하지만 문제를 다시 살펴보니 문제 안에   답이 있었다.</p>
  <ul>
    <li>N명의 집단에서 각 사람의 덩치 등수는 자신보다 더 “큰 덩치”의 사람의 수로 정해진다.</li>
    <li>즉, 몸무게와 키 모두 큰 사람이 덩치 등수가 높다.</li>
    <li>만약 몸무게와 키 둘 중 하나만 큰 상태에서는 덩치 등수를 매길 수 없다.
      <ul>
        <li>같은 덩치 등수를 가진 사람은 여러명이다.</li>
      </ul>
    </li>
  </ul>
</blockquote>

<blockquote>
  <p>결론은 각 몸무게와 키를 비교하면 전체 사람의 덩치 등수를 구할 수 있다.</p>
</blockquote>

<p><br /></p>

<h1 id="-내-풀이">📝 내 풀이</h1>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># 입력
</span><span class="n">n</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">input</span><span class="p">())</span>

<span class="c1"># (몸무게, 덩체) 튜플 형식을 입력 받기
</span><span class="n">lst</span> <span class="o">=</span> <span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">input</span><span class="p">().</span><span class="n">split</span><span class="p">()))</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)]</span> 

<span class="c1"># print(lst) - [(55, 185), (58, 183), (88, 186), (60, 175), (46, 155)]
</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">lst</span><span class="p">:</span>
    <span class="n">rank</span> <span class="o">=</span> <span class="mi">1</span> <span class="c1"># 순위 초기화
</span>    <span class="n">w</span><span class="p">,</span><span class="n">h</span> <span class="o">=</span> <span class="n">i</span> <span class="c1"># 순위를 매길 몸무게와 키;
</span>    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">lst</span><span class="p">:</span>
        <span class="n">w1</span><span class="p">,</span> <span class="n">h1</span> <span class="o">=</span> <span class="n">j</span> <span class="c1"># 비교할 몸무게와 키
</span>
        <span class="c1"># 비교할 몸무게와 키가 모두 크다면, 즉 순위를 매길 몸무게가 더 작다면 순위 증가
</span>        <span class="k">if</span> <span class="n">w</span> <span class="o">&lt;</span> <span class="n">w1</span> <span class="ow">and</span> <span class="n">h</span> <span class="o">&lt;</span> <span class="n">h1</span><span class="p">:</span> 
            <span class="n">rank</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="k">print</span><span class="p">(</span><span class="n">rank</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s">' '</span><span class="p">)</span> <span class="c1"># 순위 이어서 출력하기
</span>
</code></pre></div></div>
<p><br /></p>

<h1 id="-풀이-리뷰">😳 풀이 리뷰</h1>

<blockquote>
  <p>이중 반복문을 통해 w,h에 순위를 매길 몸무게와 키를 w1, h1에는 비교할 몸무게와 키를 담고 비교하여 덩치 등수를 매겼다.</p>
</blockquote>]]></content><author><name>지지형</name></author><category term="BOJ" /><summary type="html"><![CDATA[🔎 난이도 ⚪️ 실버 5 ✏️ 문제 https://www.acmicpc.net/problem/7568 🤖 예제 입력 및 출력 📑 알고리즘 분류 구현 브루트포스 알고리즘 🧐 아이디어 처음에 다양한 정렬을 해보며 시도하였지만, 풀수가 없었다. 하지만 문제를 다시 살펴보니 문제 안에 답이 있었다. N명의 집단에서 각 사람의 덩치 등수는 자신보다 더 “큰 덩치”의 사람의 수로 정해진다. 즉, 몸무게와 키 모두 큰 사람이 덩치 등수가 높다. 만약 몸무게와 키 둘 중 하나만 큰 상태에서는 덩치 등수를 매길 수 없다. 같은 덩치 등수를 가진 사람은 여러명이다. 결론은 각 몸무게와 키를 비교하면 전체 사람의 덩치 등수를 구할 수 있다. 📝 내 풀이 # 입력 n = int(input()) # (몸무게, 덩체) 튜플 형식을 입력 받기 lst = [tuple(map(int, input().split())) for _ in range(n)] # print(lst) - [(55, 185), (58, 183), (88, 186), (60, 175), (46, 155)] for i in lst: rank = 1 # 순위 초기화 w,h = i # 순위를 매길 몸무게와 키; for j in lst: w1, h1 = j # 비교할 몸무게와 키 # 비교할 몸무게와 키가 모두 크다면, 즉 순위를 매길 몸무게가 더 작다면 순위 증가 if w &lt; w1 and h &lt; h1: rank += 1 print(rank, end=' ') # 순위 이어서 출력하기 😳 풀이 리뷰 이중 반복문을 통해 w,h에 순위를 매길 몸무게와 키를 w1, h1에는 비교할 몸무게와 키를 담고 비교하여 덩치 등수를 매겼다.]]></summary></entry><entry><title type="html">[백준] 4673 : 셀프 넘버 (파이썬)</title><link href="http://localhost:4000/boj/BOJ-4673/" rel="alternate" type="text/html" title="[백준] 4673 : 셀프 넘버 (파이썬)" /><published>2023-10-20T00:00:00+09:00</published><updated>2023-10-20T00:00:00+09:00</updated><id>http://localhost:4000/boj/BOJ-4673</id><content type="html" xml:base="http://localhost:4000/boj/BOJ-4673/"><![CDATA[<h1 id="-난이도">🔎 난이도</h1>
<blockquote>
  <p>⚪️ <strong>실버 5</strong></p>
</blockquote>

<h1 id="️-문제">✏️ 문제</h1>
<blockquote>
  <p><a href="https://www.acmicpc.net/problem/4673">https://www.acmicpc.net/problem/4673</a></p>
</blockquote>

<p><img src="/assets/images/Coding_test/Boj/BOJ_4673_1.png" /></p>

<p><br /></p>

<h1 id="-예제-입력-및-출력">🤖 예제 입력 및 출력</h1>

<p><img src="/assets/images/Coding_test/Boj/BOJ_4673_2.png" /></p>

<p><br /></p>

<h1 id="-알고리즘-분류">📑 알고리즘 분류</h1>

<ul>
  <li>수학</li>
  <li>구현</li>
  <li>브루트포스 알고리즘</li>
</ul>

<p><br /></p>

<h1 id="-아이디어">🧐 아이디어</h1>

<blockquote>
  <p>10,000 보다 작거나 같은 <strong>셀프 넘버</strong> 를 출력하는 문제이다.</p>
  <ul>
    <li>생성자 : 양의 정수 $n$ 에 대해서 $n$ 과 $n$ 의 각 자리수를 더하는 함수라고 정의해보면 $d(75) = 75 + 7 + 5 = 87$
      <ul>
        <li>$75$ 는 $d(75) = 87$ 의 생성자이다.</li>
      </ul>
    </li>
    <li>셀프넘버 : 위의 경우처럼 생성자가 있는 것이 아니라 생성자가 없을 경우 셀프 넘버라고 한다.
      <ul>
        <li>각 자리수를 더하여 $31$ 을 만들 수 있는 숫자는 없기에, $31$ 은 셀프 넘버이다.</li>
      </ul>
    </li>
  </ul>
</blockquote>

<p><br /></p>

<h1 id="-내-풀이">📝 내 풀이</h1>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># 생성자 함수
</span><span class="k">def</span> <span class="nf">d</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">:</span> <span class="c1"># 한 자리 수일 경우
</span>        <span class="k">return</span> <span class="n">n</span> <span class="o">+</span> <span class="n">n</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">n</span> <span class="o">+</span> <span class="nb">sum</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">n</span><span class="p">)))</span> <span class="c1"># n과 각 자리수의 합 더하기
</span>
<span class="n">self_num</span> <span class="o">=</span> <span class="p">[</span><span class="bp">True</span><span class="p">]</span> <span class="o">*</span> <span class="mi">10001</span> <span class="c1"># 셀프넘버 리스트
</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">self_num</span><span class="p">)):</span> <span class="c1"># 1 ~ 10000
</span>    <span class="k">if</span> <span class="n">d</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">10000</span><span class="p">:</span> <span class="c1"># 10000보다 작거나 같을 경우
</span>        <span class="n">self_num</span><span class="p">[</span><span class="n">d</span><span class="p">(</span><span class="n">i</span><span class="p">)]</span> <span class="o">=</span> <span class="bp">False</span> <span class="c1"># 생성자일 경우 False 처리 (셀프넘버가 아닐 경우)
</span>
<span class="c1"># 출력
</span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">self_num</span><span class="p">)):</span>
    <span class="k">if</span> <span class="n">self_num</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="bp">True</span><span class="p">:</span> <span class="k">print</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="c1"># 셀프넘버(True)일 경우 출력
</span></code></pre></div></div>
<p><br /></p>

<h1 id="-풀이-리뷰">😳 풀이 리뷰</h1>
<blockquote>
  <p>위 아이디어에서 정리한 개념을 이해 한 후</p>
</blockquote>

<ol>
  <li>인덱스를 통해 문제를 풀어야겠다고 생각했다.</li>
  <li>True로 이루어진 10001개의 셀프넘버 리스트</li>
  <li>반복문을 통해 생성자가 있을 경우 False 처리를 해주는 함수 정의.</li>
  <li>셀프넘버 리스트 True로 남아있는 원소(셀프넘버)의 인덱스를 출력해줌으로써 문제를 해결하였다.</li>
</ol>]]></content><author><name>지지형</name></author><category term="BOJ" /><summary type="html"><![CDATA[🔎 난이도 ⚪️ 실버 5 ✏️ 문제 https://www.acmicpc.net/problem/4673 🤖 예제 입력 및 출력 📑 알고리즘 분류 수학 구현 브루트포스 알고리즘 🧐 아이디어 10,000 보다 작거나 같은 셀프 넘버 를 출력하는 문제이다. 생성자 : 양의 정수 $n$ 에 대해서 $n$ 과 $n$ 의 각 자리수를 더하는 함수라고 정의해보면 $d(75) = 75 + 7 + 5 = 87$ $75$ 는 $d(75) = 87$ 의 생성자이다. 셀프넘버 : 위의 경우처럼 생성자가 있는 것이 아니라 생성자가 없을 경우 셀프 넘버라고 한다. 각 자리수를 더하여 $31$ 을 만들 수 있는 숫자는 없기에, $31$ 은 셀프 넘버이다. 📝 내 풀이 # 생성자 함수 def d(n): if n &lt; 10: # 한 자리 수일 경우 return n + n else: return n + sum(map(int, str(n))) # n과 각 자리수의 합 더하기 self_num = [True] * 10001 # 셀프넘버 리스트 for i in range(1,len(self_num)): # 1 ~ 10000 if d(i) &lt;= 10000: # 10000보다 작거나 같을 경우 self_num[d(i)] = False # 생성자일 경우 False 처리 (셀프넘버가 아닐 경우) # 출력 for i in range(1,len(self_num)): if self_num[i] == True: print(i) # 셀프넘버(True)일 경우 출력 😳 풀이 리뷰 위 아이디어에서 정리한 개념을 이해 한 후 인덱스를 통해 문제를 풀어야겠다고 생각했다. True로 이루어진 10001개의 셀프넘버 리스트 반복문을 통해 생성자가 있을 경우 False 처리를 해주는 함수 정의. 셀프넘버 리스트 True로 남아있는 원소(셀프넘버)의 인덱스를 출력해줌으로써 문제를 해결하였다.]]></summary></entry><entry><title type="html">[이산수학] 관계(Relation)</title><link href="http://localhost:4000/discrete%20mathematics/DM-05/" rel="alternate" type="text/html" title="[이산수학] 관계(Relation)" /><published>2023-10-20T00:00:00+09:00</published><updated>2023-10-29T00:00:00+09:00</updated><id>http://localhost:4000/discrete%20mathematics/DM-05</id><content type="html" xml:base="http://localhost:4000/discrete%20mathematics/DM-05/"><![CDATA[<h1 id="관계relation란">관계(Relation)란?</h1>
<blockquote>
  <p>객체들 간의 연관성을 표현하는 구조이다.</p>
  <ul>
    <li>집합론에서는 곱집합의 부분집합이다.</li>
    <li>다른 두 집합에 속하는 서로 다른 두 원소의 관계를 나타낸 것.</li>
  </ul>
</blockquote>

<h2 id="이항관계-binary-relations">이항관계 (binary relations)</h2>
<blockquote>
  <p>집합 $A$ 와 $B$ 가 있을 때, $A$ 와 $B$ 의 곱집합 ($A \times B$)의 부분집합 $R$ 을 $A$ 에서 $B$ 로 가는 관계라고 한다.</p>
</blockquote>

<ul>
  <li>$a \in A$ 고, $b \in B$ 일 때, $(a ,b) \in A \times B$ 이면 ${a}\mathrm{R}{b}$</li>
</ul>

<h3 id="순서쌍ordered-pair">순서쌍(ordered pair)</h3>
<blockquote>
  <p>어떠한 원소 $a \in A, b \in B$ 와 같이 순서를 가진 쌍을 순서쌍이라고 한다. $a$ 를 첫 번째, $b$ 를 두 번째 원소라고 한다.</p>
</blockquote>

<h4 id="순서쌍-예시">순서쌍 예시</h4>
<p>$A$ = {$(x | 1 \le x  \le 3 , x는 정수)$} $A$ 에서 $A$ 로 가는 관계 $R$ 은 다음과 같을 때,<br />
관계 $R$ 을 순서쌍으로 나타내시오.<br />
<br />
    $R$ = {$((a,b)|a \times b 는 홀수, a \in A, b \in A )$}<br />
    $R$ = {$(1,1), (1,3), (3,1), (3,3)$}</p>

<h3 id="곱집합cartesian-product">곱집합(cartesian product)</h3>
<blockquote>
  <p><a href="https://wlgudths.github.io/discrete%20mathematics/DM-02/#4-%EA%B3%B1%EC%A7%91%ED%95%A9-product-set">이산수학 04.집합 참고</a></p>
</blockquote>

<h3 id="정의역domain--domr">정의역(Domain : $dom(R)$)</h3>
<blockquote>
  <p>집합 $A$ 에서 집합 $B$로 가는 이항관계 $R$에 속한 순서쌍의 <u>첫 번째 원소가 포함되어</u>있는 집합.</p>
</blockquote>

<ul>
  <li>$dom(R)$ = {$a$ : $a$ $\in$ $R$}</li>
</ul>

<h3 id="공역-공번역codomain--codomr">공역, 공번역(Codomain : $codom(R$))</h3>
<blockquote>
  <p>집합 $A$ 에서 집합 $B$로 가는 이항관계 $R$ 에 속한 순서쌍의 <u>두 번째 원소가 포함되어</u>있는 집합.</p>
</blockquote>

<ul>
  <li>$codom(R)$ = {$b$ : $b$ $\in$ $R$}</li>
</ul>

<h3 id="치역range--ranr">치역(Range : $ran(R)$)</h3>
<blockquote>
  <p>집합 $A$ 에서 집합 $B$로 가는 관계 $R$에 속한 순서쌍의 <u>두 번째 원소들을 모아놓은 집합</u>있는 집합.</p>
</blockquote>

<ul>
  <li>$ran(R)$ = {$b$ : $(a,b)$ $\in$ $R$} $\subseteq B$</li>
</ul>

<h2 id="역관계inverse-relation">역관계(Inverse relation)</h2>
<blockquote>
  <p>집합 $A$ 에서 $B$로의 이항관계 $R$ 의 역관계 $R^{-1}$ = {$(b,a)\in B \times A | (a,b) \in R$ }</p>
  <ul>
    <li>예시 ($A$ = {$1,3$}, $B$ = {$2,4$})
      <ul>
        <li>$R$ = {$(1,2), (1,4), (3,2), (3,4)$}</li>
        <li>$R^{-1}$ = {$(2,1), (4,1), (2,3), (4,3)$}</li>
      </ul>
    </li>
  </ul>
</blockquote>

<h1 id="관계의-표현-방법">관계의 표현 방법</h1>

<h2 id="화살표-도표">화살표 도표</h2>
<blockquote>
  <p>두 집합 원소 사이의 관계를 화살표로 나타내는 방법</p>
</blockquote>

<p><img src="/assets/images/Math/dm/dm_example_5_1.png" /></p>

<h2 id="좌표-도표">좌표 도표</h2>
<blockquote>
  <p>집합 $A$ 에서 집합 $B$로 가는 관계 $R$이 있을 때, 집합 $A$ (정의역)의 원소들을 $x$ 축에, 집합 $B$ (공역)의 원소들을  $y$축에 표시하여 관계 $R$을 나타내는 방법</p>
</blockquote>

<p><img src="/assets/images/Math/dm/dm_example_5_2.png" /></p>

<h2 id="방향-그래프">방향 그래프</h2>
<blockquote>
  <p>하나의 집합 $A$에서 집합 $A$로 가는 관계 $R$을 꼭짓점과 화살표를 이용해 나타낸 그래프</p>
  <ul>
    <li>루프(loop) : 특정 원소에서 시작해서 그 원소로 끝나는 화살표</li>
  </ul>
</blockquote>

<p><img src="/assets/images/Math/dm/dm_example_5_3.png" /></p>

<h2 id="관계-행렬">관계 행렬</h2>
<blockquote>
  <p>집합 $A$ 에서 집합 $B$로 가는 관계 $R$이 있을 때, 관계를 행렬로 표현한 방법</p>
  <ul>
    <li>$A$의 원소들을 행에 배치, $B$의 원소들을 열에 배치한 후 관계가 있으면 1, 없으면 0으로 행렬의 원소를 나타낸다.</li>
  </ul>
</blockquote>

<p><img src="/assets/images/Math/dm/dm_example_5_4.png" /></p>

<h1 id="관계의-성질">관계의 성질</h1>

<h2 id="반사성reflexive-relation">반사성(Reflexive Relation)</h2>
<blockquote>
  <p>집합 $A$ 에서 집합 $B$로 가는 관계 $R$이 있을 때, 모든 $a \in A$ 에 대해 $(a,a) \in R$ 인 관계</p>
</blockquote>

<h3 id="반사성-예시">반사성 예시</h3>

<ul>
  <li>
    <p>대각원소들이 모두 1인 관계행렬<br />
\(\begin{bmatrix}  
1 &amp; 0 &amp; 0 &amp; 0\\
0 &amp; 1 &amp; 0 &amp; 0\\
0 &amp; 0 &amp; 1 &amp; 0\\
0 &amp; 0 &amp; 0 &amp; 1\\
\end{bmatrix}\)</p>
  </li>
  <li>
    <p>모든 원소에 대해 루프<br />
<img src="/assets/images/Math/dm/dm_example_5_5.png" /></p>
  </li>
</ul>

<h2 id="대칭성symmetric-relation">대칭성(symmetric relation)</h2>
<blockquote>
  <p>집합 $A$ 에 대한 관계 $R$ 이 있을 때, 어떤 $a,b \in A$ 에 대해 $(a,b) \in R$ 이면 $(b,a) \in R$인 관계</p>
</blockquote>

<h3 id="대칭성-예시">대칭성 예시</h3>
<blockquote>
  <p>$M_r = [m_{ij}]$ 에서 $m_{ij} = m_{ji}$ 이다.</p>
</blockquote>

\[\begin{bmatrix}
0 &amp; 1 &amp; 0 &amp; 1\\
1 &amp; 0 &amp; 1 &amp; 0\\
0 &amp; 1 &amp; 0 &amp; 0\\
1 &amp; 0 &amp; 0 &amp; 1\\
\end{bmatrix}\]

<ul>
  <li>방향그래프 (양방향 화살표)<br />
<img src="/assets/images/Math/dm/dm_example_5_6.png" /></li>
</ul>

<h2 id="반대칭성antisymmetric">반대칭성(antisymmetric)</h2>
<blockquote>
  <p>집합 $A$ 에 대한 관계 $R$ 이 있을 때, 어떤 $(a,b) \in A$ 에 대해 $(a,b) \in R$ 이면 $(b,a) \in R$ 이고, $a = b$ 인 관계</p>
</blockquote>

<h3 id="반대칭성-예시">반대칭성 예시</h3>
<blockquote>
  <p>$M_r = [m_{ij}]$ 에서 $i \ne j $ 일 때, $m_{ij} = 0$ 또는 $m_{ji} = 0$ 이다.</p>
</blockquote>

\[\begin{bmatrix}
0 &amp; 0 &amp; 0 &amp; 0 \\
1 &amp; 0 &amp; 0 &amp; 0 \\
1 &amp; 1 &amp; 0 &amp; 0 \\
1 &amp; 1 &amp; 1 &amp; 0 \\
\end{bmatrix}\]

<h2 id="추이성transitive">추이성(Transitive)</h2>
<blockquote>
  <p>집합 $A$에 대한 관계 $R$이 있을 때, 어떤 $a,b,c \in A$에 대해 $(a,b) \in R$ 이고 $(b,c) \in R$ 이면 $(a,c) \in R$ 인 관계</p>
</blockquote>

<h3 id="추이성-예시">추이성 예시</h3>

\[\begin{bmatrix}
1 &amp; 1 &amp; 1 &amp; 1 \\
0 &amp; 1 &amp; 1 &amp; 1 \\
0 &amp; 0 &amp; 1 &amp; 1 \\
0 &amp; 0 &amp; 0 &amp; 1 \\
\end{bmatrix}\]

<h1 id="참조">참조</h1>
<p><a href="http://bigdata.dongguk.ac.kr/lectures/disc_math/_book/%EA%B4%80%EA%B3%84.html">http://bigdata.dongguk.ac.kr/lectures/disc_math/_book/%EA%B4%80%EA%B3%84.html</a><br />
<a href="https://ko.wikipedia.org/wiki/%EA%B4%80%EA%B3%84_(%EC%88%98%ED%95%99)">https://ko.wikipedia.org/wiki/%EA%B4%80%EA%B3%84_(%EC%88%98%ED%95%99)</a><br />
<a href="https://ko.wikipedia.org/wiki/%EC%A0%95%EC%9D%98%EC%97%AD">https://ko.wikipedia.org/wiki/%EC%A0%95%EC%9D%98%EC%97%AD</a><br />
<a href="https://johngrib.github.io/wiki/relations/#%EB%8C%80%EC%B9%AD-%EB%B0%98%EB%8C%80%EC%B9%AD-%EA%B4%80%EA%B3%84">https://johngrib.github.io/wiki/relations/#%EB%8C%80%EC%B9%AD-%EB%B0%98%EB%8C%80%EC%B9%AD-%EA%B4%80%EA%B3%84</a></p>]]></content><author><name>지지형</name></author><category term="Discrete Mathematics" /><summary type="html"><![CDATA[관계(Relation)란? 객체들 간의 연관성을 표현하는 구조이다. 집합론에서는 곱집합의 부분집합이다. 다른 두 집합에 속하는 서로 다른 두 원소의 관계를 나타낸 것. 이항관계 (binary relations) 집합 $A$ 와 $B$ 가 있을 때, $A$ 와 $B$ 의 곱집합 ($A \times B$)의 부분집합 $R$ 을 $A$ 에서 $B$ 로 가는 관계라고 한다. $a \in A$ 고, $b \in B$ 일 때, $(a ,b) \in A \times B$ 이면 ${a}\mathrm{R}{b}$ 순서쌍(ordered pair) 어떠한 원소 $a \in A, b \in B$ 와 같이 순서를 가진 쌍을 순서쌍이라고 한다. $a$ 를 첫 번째, $b$ 를 두 번째 원소라고 한다. 순서쌍 예시 $A$ = {$(x | 1 \le x \le 3 , x는 정수)$} $A$ 에서 $A$ 로 가는 관계 $R$ 은 다음과 같을 때, 관계 $R$ 을 순서쌍으로 나타내시오. $R$ = {$((a,b)|a \times b 는 홀수, a \in A, b \in A )$} $R$ = {$(1,1), (1,3), (3,1), (3,3)$} 곱집합(cartesian product) 이산수학 04.집합 참고 정의역(Domain : $dom(R)$) 집합 $A$ 에서 집합 $B$로 가는 이항관계 $R$에 속한 순서쌍의 첫 번째 원소가 포함되어있는 집합. $dom(R)$ = {$a$ : $a$ $\in$ $R$} 공역, 공번역(Codomain : $codom(R$)) 집합 $A$ 에서 집합 $B$로 가는 이항관계 $R$ 에 속한 순서쌍의 두 번째 원소가 포함되어있는 집합. $codom(R)$ = {$b$ : $b$ $\in$ $R$} 치역(Range : $ran(R)$) 집합 $A$ 에서 집합 $B$로 가는 관계 $R$에 속한 순서쌍의 두 번째 원소들을 모아놓은 집합있는 집합. $ran(R)$ = {$b$ : $(a,b)$ $\in$ $R$} $\subseteq B$ 역관계(Inverse relation) 집합 $A$ 에서 $B$로의 이항관계 $R$ 의 역관계 $R^{-1}$ = {$(b,a)\in B \times A | (a,b) \in R$ } 예시 ($A$ = {$1,3$}, $B$ = {$2,4$}) $R$ = {$(1,2), (1,4), (3,2), (3,4)$} $R^{-1}$ = {$(2,1), (4,1), (2,3), (4,3)$} 관계의 표현 방법 화살표 도표 두 집합 원소 사이의 관계를 화살표로 나타내는 방법 좌표 도표 집합 $A$ 에서 집합 $B$로 가는 관계 $R$이 있을 때, 집합 $A$ (정의역)의 원소들을 $x$ 축에, 집합 $B$ (공역)의 원소들을 $y$축에 표시하여 관계 $R$을 나타내는 방법 방향 그래프 하나의 집합 $A$에서 집합 $A$로 가는 관계 $R$을 꼭짓점과 화살표를 이용해 나타낸 그래프 루프(loop) : 특정 원소에서 시작해서 그 원소로 끝나는 화살표 관계 행렬 집합 $A$ 에서 집합 $B$로 가는 관계 $R$이 있을 때, 관계를 행렬로 표현한 방법 $A$의 원소들을 행에 배치, $B$의 원소들을 열에 배치한 후 관계가 있으면 1, 없으면 0으로 행렬의 원소를 나타낸다. 관계의 성질 반사성(Reflexive Relation) 집합 $A$ 에서 집합 $B$로 가는 관계 $R$이 있을 때, 모든 $a \in A$ 에 대해 $(a,a) \in R$ 인 관계 반사성 예시 대각원소들이 모두 1인 관계행렬 \(\begin{bmatrix} 1 &amp; 0 &amp; 0 &amp; 0\\ 0 &amp; 1 &amp; 0 &amp; 0\\ 0 &amp; 0 &amp; 1 &amp; 0\\ 0 &amp; 0 &amp; 0 &amp; 1\\ \end{bmatrix}\) 모든 원소에 대해 루프 대칭성(symmetric relation) 집합 $A$ 에 대한 관계 $R$ 이 있을 때, 어떤 $a,b \in A$ 에 대해 $(a,b) \in R$ 이면 $(b,a) \in R$인 관계 대칭성 예시 $M_r = [m_{ij}]$ 에서 $m_{ij} = m_{ji}$ 이다. \[\begin{bmatrix} 0 &amp; 1 &amp; 0 &amp; 1\\ 1 &amp; 0 &amp; 1 &amp; 0\\ 0 &amp; 1 &amp; 0 &amp; 0\\ 1 &amp; 0 &amp; 0 &amp; 1\\ \end{bmatrix}\] 방향그래프 (양방향 화살표) 반대칭성(antisymmetric) 집합 $A$ 에 대한 관계 $R$ 이 있을 때, 어떤 $(a,b) \in A$ 에 대해 $(a,b) \in R$ 이면 $(b,a) \in R$ 이고, $a = b$ 인 관계 반대칭성 예시 $M_r = [m_{ij}]$ 에서 $i \ne j $ 일 때, $m_{ij} = 0$ 또는 $m_{ji} = 0$ 이다. \[\begin{bmatrix} 0 &amp; 0 &amp; 0 &amp; 0 \\ 1 &amp; 0 &amp; 0 &amp; 0 \\ 1 &amp; 1 &amp; 0 &amp; 0 \\ 1 &amp; 1 &amp; 1 &amp; 0 \\ \end{bmatrix}\] 추이성(Transitive) 집합 $A$에 대한 관계 $R$이 있을 때, 어떤 $a,b,c \in A$에 대해 $(a,b) \in R$ 이고 $(b,c) \in R$ 이면 $(a,c) \in R$ 인 관계 추이성 예시 \[\begin{bmatrix} 1 &amp; 1 &amp; 1 &amp; 1 \\ 0 &amp; 1 &amp; 1 &amp; 1 \\ 0 &amp; 0 &amp; 1 &amp; 1 \\ 0 &amp; 0 &amp; 0 &amp; 1 \\ \end{bmatrix}\] 참조 http://bigdata.dongguk.ac.kr/lectures/disc_math/_book/%EA%B4%80%EA%B3%84.html https://ko.wikipedia.org/wiki/%EA%B4%80%EA%B3%84_(%EC%88%98%ED%95%99) https://ko.wikipedia.org/wiki/%EC%A0%95%EC%9D%98%EC%97%AD https://johngrib.github.io/wiki/relations/#%EB%8C%80%EC%B9%AD-%EB%B0%98%EB%8C%80%EC%B9%AD-%EA%B4%80%EA%B3%84]]></summary></entry><entry><title type="html">[백준] 2231 : 분해합 (파이썬)</title><link href="http://localhost:4000/boj/BOJ-2231/" rel="alternate" type="text/html" title="[백준] 2231 : 분해합 (파이썬)" /><published>2023-10-19T00:00:00+09:00</published><updated>2023-10-19T00:00:00+09:00</updated><id>http://localhost:4000/boj/BOJ-2231</id><content type="html" xml:base="http://localhost:4000/boj/BOJ-2231/"><![CDATA[<h1 id="-난이도">🔎 난이도</h1>
<blockquote>
  <p>🟤 <strong>브론즈 2</strong></p>
</blockquote>

<h1 id="️-문제">✏️ 문제</h1>
<blockquote>
  <p><a href="https://www.acmicpc.net/problem/2231">https://www.acmicpc.net/problem/2231</a></p>
</blockquote>

<p><img src="/assets/images/Coding_test/Boj/BOJ_2231_1.png" />
<br /></p>

<h1 id="-예제-입력-및-출력">🤖 예제 입력 및 출력</h1>

<p><img src="/assets/images/Coding_test/Boj/BOJ_2231_2.png" /></p>

<p><br /></p>

<h1 id="-알고리즘-분류">📑 알고리즘 분류</h1>

<ul>
  <li>브루트포스 알고리즘</li>
</ul>

<p><br /></p>

<h1 id="-아이디어">🧐 아이디어</h1>
<blockquote>
  <p>이 문제의 핵심은 분해합과 생성자에 대한 이해, N의 가장 작은 생성자 출력! 이라고 할 수 있다.</p>
  <ul>
    <li>분해합 : 자연수 N과 N을 이루는 각 자리수의 합
      <ul>
        <li>N = 123, N을 이루는 각 자리수 1, 2, 3 의 합이다. (123 + 1 + 2 + 3)</li>
      </ul>
    </li>
    <li>생성자 : 자연수 M의 분해합이 N인 경우, M은 생성자이다.
      <ul>
        <li>M = 120, N = 123 M의 분해합은 (120 + 1 + 2 + 0) = 123 = N 이다.<br />
즉, 120은 123의 생성자이다.</li>
      </ul>
    </li>
    <li>어떠한 자연수의 생성자가 없을 수도 있고, 여러 개일 수도 있다.
      <ul>
        <li>출력 : 생성자가 없을 경우 <strong>0</strong> / 생성자가 여러 개일 경우 <strong>가장 작은 생성자</strong></li>
      </ul>
    </li>
  </ul>
</blockquote>

<blockquote>
  <p>문제에서 요구한 개념들을 이해한 후에는 각 자리수를 더하는 과정을 코드로 구현하는 것이 포인트라고 생각한다.</p>
</blockquote>

<p><br /></p>

<h1 id="-첫-풀이">📝 첫 풀이</h1>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># 입력
</span><span class="n">n</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">input</span><span class="p">())</span>

<span class="c1"># 생성자를 받을 리스트
</span><span class="n">ans_lst</span> <span class="o">=</span> <span class="p">[]</span>

<span class="c1"># 정답 비교용
</span><span class="n">num</span> <span class="o">=</span> <span class="n">n</span>

<span class="k">while</span> <span class="n">n</span><span class="p">:</span> <span class="c1"># n이 0이 될 때까지 반복
</span>
    <span class="n">lst</span> <span class="o">=</span> <span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="c1"># 각 자리수의 합을 위한 리스트
</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">str</span><span class="p">(</span><span class="n">n</span><span class="p">):</span> <span class="c1"># 각 자리 수 반복 
</span>        <span class="n">lst</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">i</span><span class="p">))</span> <span class="c1"># 리스트에 각 자리수 담기
</span>
    <span class="k">if</span> <span class="nb">sum</span><span class="p">(</span><span class="n">lst</span><span class="p">)</span> <span class="o">==</span> <span class="n">num</span><span class="p">:</span> <span class="c1"># 각 자리수의 합이 생성자일 경우 
</span>        <span class="n">ans_lst</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="c1"># 결과값(생성자)을 담을 리스트에 담기
</span>    
    <span class="n">n</span> <span class="o">-=</span> <span class="mi">1</span> <span class="c1"># n에서 1씩 줄여가며 반복
</span>

<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ans_lst</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span> <span class="c1"># 결과 리스트에 원소가 있을 경우 가장 작은 생성자 출력
</span>    <span class="k">print</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">ans_lst</span><span class="p">))</span>

<span class="k">else</span><span class="p">:</span> <span class="c1"># 원소가 들어있지않으면 0을 출력
</span>    <span class="k">print</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
</code></pre></div></div>
<p><br /></p>

<h1 id="-풀이-리뷰">😳 풀이 리뷰</h1>
<p>물론 정답이 인정된 코드지만, 다시봐도 복잡하고 가독성이 떨어진다…<br />
while문을 통해 자연수 N을 하나씩 줄여가며 각 자리수를 더하고 num과 같은 지 비교하였다.<br />
while문을 빠져 나온 후 정답리스트에 원소가 있을 경우 min을 통해 가장 작은 숫자를 출력하고, 원소가 없을 경우 생성자가 없기 때문에 0을 출력하게 하였다.<br />
문제에서는 가장 작은 생성자를 출력하거나 없을 경우 0을 출력하는 것이다. 위 코드에서는 가장 큰 숫자인 N에서 1씩 빼며 반복하기에 가장 큰 생성자가 먼저 담기는 문제가 생겼다.</p>

<p><br /></p>

<h1 id="-두-번째-풀이">📝 두 번째 풀이</h1>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># 입력
</span><span class="n">n</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">input</span><span class="p">())</span> 

<span class="c1"># 결과를 담을 변수
</span><span class="n">ans</span> <span class="o">=</span> <span class="mi">0</span>

<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span> <span class="c1"># 1 ~ n 까지
</span>    <span class="n">num</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="nb">sum</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)))</span> <span class="c1"># i의 분해합
</span>
    <span class="k">if</span> <span class="n">num</span> <span class="o">==</span> <span class="n">n</span><span class="p">:</span> <span class="c1"># 생성자의 분해합과 N이 같을 경우
</span>        <span class="n">ans</span> <span class="o">=</span> <span class="n">i</span> <span class="c1"># 결과에 생성자 i를 담고 반복문 종료!
</span>        <span class="k">break</span>

<span class="c1"># for문을 1부터 n까지 돌며 생성자를 찾게되면 가장 작은 생성자를 찾게 된다.
# 만약 n까지 돌고 나서 생성자가 없을 경우 결과는 그래로 0을 출력하게 된다.
</span>
<span class="c1"># 결과 출력
</span><span class="k">print</span><span class="p">(</span><span class="n">ans</span><span class="p">)</span>
</code></pre></div></div>

<h1 id="-풀이-리뷰-1">😳 풀이 리뷰</h1>

<p>첫 번째 풀이 이후, 문제가 요구하는 사항에 맞춰 코드를 개선하였다.<br />
각 자리수의 합을 구할 때 리스트를 만들고 append시키며 복잡헀던 것이 map, sum을 통해 간략화 했다.<br />
이후 1 ~ N까지 반복문을 돌며 생성자를 생성하고 분해합과 같을 때 반복문을 탈출하도록 하였다.</p>]]></content><author><name>지지형</name></author><category term="BOJ" /><summary type="html"><![CDATA[🔎 난이도 🟤 브론즈 2]]></summary></entry></feed>