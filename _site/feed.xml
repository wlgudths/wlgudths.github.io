<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.9.3">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2023-11-01T21:56:18+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">느려도 괜찮아</title><author><name>지지형</name></author><entry><title type="html">[프로그래머스] Lv.01 : 같은 숫자는 싫어 (파이썬)</title><link href="http://localhost:4000/programmers/Programmers-%EA%B0%99%EC%9D%80-%EC%88%AB%EC%9E%90%EB%8A%94-%EC%8B%AB%EC%96%B4/" rel="alternate" type="text/html" title="[프로그래머스] Lv.01 : 같은 숫자는 싫어 (파이썬)" /><published>2023-10-27T00:00:00+09:00</published><updated>2023-10-27T00:00:00+09:00</updated><id>http://localhost:4000/programmers/Programmers-%EA%B0%99%EC%9D%80%20%EC%88%AB%EC%9E%90%EB%8A%94%20%EC%8B%AB%EC%96%B4</id><content type="html" xml:base="http://localhost:4000/programmers/Programmers-%EA%B0%99%EC%9D%80-%EC%88%AB%EC%9E%90%EB%8A%94-%EC%8B%AB%EC%96%B4/"><![CDATA[<h1 id="-난이도">🔎 난이도</h1>
<blockquote>
  <p><strong>Lv.01</strong></p>
</blockquote>

<h1 id="️-문제">✏️ 문제</h1>
<blockquote>
  <p><a href="https://school.programmers.co.kr/learn/courses/30/lessons/12906">https://school.programmers.co.kr/learn/courses/30/lessons/12906</a></p>
</blockquote>

<h1 id="️-문제-설명">✒️ 문제 설명</h1>
<p>배열 arr가 주어집니다. 배열 arr의 각 원소는 숫자 0부터 9까지로 이루어져있습니다.<br />
이때, 배열 arr에서 연속적으로 나타나는 숫자는 하나만 남기고 전부 제거하려고 합니다.<br />
단, 제거 된 후 남은 수들을 반환할 때는 배열 arr의 원소들의 순서를 유지해야 합니다.</p>

<ul>
  <li>arr = [1, 1, 3, 3, 0, 1, 1] 이면 [1, 3, 0, 1] 을 return 합니다.</li>
  <li>arr = [4, 4, 4, 3, 3] 이면 [4, 3]을 return 합니다.</li>
</ul>

<p>배열 arr 에서 연속적으로 나타나는 숫자는 제거하고 남은 수들을 return 하는 solution 함수를 완성해 주세요.</p>

<p><br /></p>

<h1 id="️-제한사항">🙅‍♂️ 제한사항</h1>
<ul>
  <li>배열 arr의 크기 : 1,000,000 이하의 자연수</li>
  <li>배열 arr의 원소의 크기 : 0보다 크거나 같고 9보다 작거나 같은 정수</li>
</ul>

<h1 id="-입출력-예">🤖 입출력 예</h1>

<table>
  <thead>
    <tr>
      <th>arr</th>
      <th>answer</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>[1, 1, 3, 3, 0, 1 ,1]</td>
      <td>[1, 3, 0, 1]</td>
    </tr>
    <tr>
      <td>[4, 4, 4, 3, 3]</td>
      <td>[4, 3]</td>
    </tr>
  </tbody>
</table>

<h1 id="-입출력-예-설명">🤖 입출력 예 설명</h1>
<ul>
  <li>입출력 예 # 1,2 문제의 예시와 같습니다.</li>
</ul>

<p><br /></p>

<h1 id="-아이디어">🧐 아이디어</h1>
<p>단순히 연속된 숫자의 중복을 제거하는 문제였다면, Set 자료형을 통해 손 쉽게 풀 수 있었을 겁니다. 하지만 기존에 제시한 배열 arr의 순서를 보장해야하기 때문에 Set 자료형을 쓸 수 없습니다.</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">example</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">5</span><span class="p">]</span>

<span class="n">set_example</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">example</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">set_example</span><span class="p">)</span>
<span class="c1"># {1, 2, 3, 4, 5, 6}
</span></code></pre></div></div>

<p>순서 보장을 위해 원래 배열 그대로 탐색을 하며 answer 리스트에 arr 배열의 첫 번째 값(인덱스 = 0)을 넣어 준 후, 1부터 마지막 인덱스까지 전 후 값을 비교하여 다르다면 answer의 append 해주는 방법으로 풀었습니다.</p>

<p><br /></p>

<h1 id="-내-풀이">📝 내 풀이</h1>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">solution</span><span class="p">(</span><span class="n">arr</span><span class="p">):</span>
    <span class="n">answer</span> <span class="o">=</span> <span class="p">[</span><span class="n">arr</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="c1"># arr의 첫 번째 원소
</span>    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">arr</span><span class="p">)):</span> <span class="c1"># 1 ~ arr의 길이 만큼 반복 (길이가 n이라면 n-1 반복)
</span>        <span class="k">if</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span> <span class="c1"># arr배열의 전,후 값 비교 (1,0) (2,1) (3,2) ...
</span>            <span class="n">answer</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="c1"># 같지 않다면 answer 리스트에 원소 추가
</span>    <span class="k">return</span> <span class="n">answer</span>
</code></pre></div></div>
<p><br /></p>

<h1 id="-다른-풀이">😳 다른 풀이</h1>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">diff_solution</span><span class="p">(</span><span class="n">arr</span><span class="p">):</span>
    <span class="n">answer</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">arr</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">answer</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">:]</span> <span class="o">!=</span> <span class="p">[</span><span class="n">i</span><span class="p">]:</span>
            <span class="n">answer</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">answer</span>
</code></pre></div></div>

<p>answer의 마지막 원소와 현재 i와 비교를 하며 같지 않을 경우, 즉, 중복되지 않을 경우 answer 리스트에 원소를 추가하는 방법입니다.</p>]]></content><author><name>지지형</name></author><category term="Programmers" /><summary type="html"><![CDATA[🔎 난이도 Lv.01 ✏️ 문제 https://school.programmers.co.kr/learn/courses/30/lessons/12906 ✒️ 문제 설명 배열 arr가 주어집니다. 배열 arr의 각 원소는 숫자 0부터 9까지로 이루어져있습니다. 이때, 배열 arr에서 연속적으로 나타나는 숫자는 하나만 남기고 전부 제거하려고 합니다. 단, 제거 된 후 남은 수들을 반환할 때는 배열 arr의 원소들의 순서를 유지해야 합니다. arr = [1, 1, 3, 3, 0, 1, 1] 이면 [1, 3, 0, 1] 을 return 합니다. arr = [4, 4, 4, 3, 3] 이면 [4, 3]을 return 합니다. 배열 arr 에서 연속적으로 나타나는 숫자는 제거하고 남은 수들을 return 하는 solution 함수를 완성해 주세요. 🙅‍♂️ 제한사항 배열 arr의 크기 : 1,000,000 이하의 자연수 배열 arr의 원소의 크기 : 0보다 크거나 같고 9보다 작거나 같은 정수 🤖 입출력 예 arr answer [1, 1, 3, 3, 0, 1 ,1] [1, 3, 0, 1] [4, 4, 4, 3, 3] [4, 3] 🤖 입출력 예 설명 입출력 예 # 1,2 문제의 예시와 같습니다. 🧐 아이디어 단순히 연속된 숫자의 중복을 제거하는 문제였다면, Set 자료형을 통해 손 쉽게 풀 수 있었을 겁니다. 하지만 기존에 제시한 배열 arr의 순서를 보장해야하기 때문에 Set 자료형을 쓸 수 없습니다. example = [1,1,6,6,2,2,3,3,3,4,5,5] set_example = set(example) print(set_example) # {1, 2, 3, 4, 5, 6} 순서 보장을 위해 원래 배열 그대로 탐색을 하며 answer 리스트에 arr 배열의 첫 번째 값(인덱스 = 0)을 넣어 준 후, 1부터 마지막 인덱스까지 전 후 값을 비교하여 다르다면 answer의 append 해주는 방법으로 풀었습니다. 📝 내 풀이 def solution(arr): answer = [arr[0]] # arr의 첫 번째 원소 for i in range(1,len(arr)): # 1 ~ arr의 길이 만큼 반복 (길이가 n이라면 n-1 반복) if arr[i] != arr[i-1]: # arr배열의 전,후 값 비교 (1,0) (2,1) (3,2) ... answer.append(arr[i]) # 같지 않다면 answer 리스트에 원소 추가 return answer 😳 다른 풀이 def diff_solution(arr): answer = [] for i in arr: if answer[-1:] != [i]: answer.append(i) return answer answer의 마지막 원소와 현재 i와 비교를 하며 같지 않을 경우, 즉, 중복되지 않을 경우 answer 리스트에 원소를 추가하는 방법입니다.]]></summary></entry><entry><title type="html">[이산수학] 관계(Relation)</title><link href="http://localhost:4000/discrete%20mathematics/DM-05/" rel="alternate" type="text/html" title="[이산수학] 관계(Relation)" /><published>2023-10-20T00:00:00+09:00</published><updated>2023-10-29T00:00:00+09:00</updated><id>http://localhost:4000/discrete%20mathematics/DM-05</id><content type="html" xml:base="http://localhost:4000/discrete%20mathematics/DM-05/"><![CDATA[<h1 id="관계relation란">관계(Relation)란?</h1>
<blockquote>
  <p>객체들 간의 연관성을 표현하는 구조이다.</p>
  <ul>
    <li>집합론에서는 곱집합의 부분집합이다.</li>
    <li>다른 두 집합에 속하는 서로 다른 두 원소의 관계를 나타낸 것.</li>
  </ul>
</blockquote>

<h2 id="이항관계-binary-relations">이항관계 (binary relations)</h2>
<blockquote>
  <p>집합 $A$ 와 $B$ 가 있을 때, $A$ 와 $B$ 의 곱집합 ($A \times B$)의 부분집합 $R$ 을 $A$ 에서 $B$ 로 가는 관계라고 한다.</p>
</blockquote>

<ul>
  <li>$a \in A$ 고, $b \in B$ 일 때, $(a ,b) \in A \times B$ 이면 ${a}\mathrm{R}{b}$</li>
</ul>

<h3 id="순서쌍ordered-pair">순서쌍(ordered pair)</h3>
<blockquote>
  <p>어떠한 원소 $a \in A, b \in B$ 와 같이 순서를 가진 쌍을 순서쌍이라고 한다. $a$ 를 첫 번째, $b$ 를 두 번째 원소라고 한다.</p>
</blockquote>

<h4 id="순서쌍-예시">순서쌍 예시</h4>
<p>$A$ = {$(x | 1 \le x  \le 3 , x는 정수)$} $A$ 에서 $A$ 로 가는 관계 $R$ 은 다음과 같을 때,<br />
관계 $R$ 을 순서쌍으로 나타내시오.<br />
<br />
    $R$ = {$((a,b)|a \times b 는 홀수, a \in A, b \in A )$}<br />
    $R$ = {$(1,1), (1,3), (3,1), (3,3)$}</p>

<h3 id="곱집합cartesian-product">곱집합(cartesian product)</h3>
<blockquote>
  <p><a href="https://wlgudths.github.io/discrete%20mathematics/DM-02/#4-%EA%B3%B1%EC%A7%91%ED%95%A9-product-set">이산수학 04.집합 참고</a></p>
</blockquote>

<h3 id="정의역domain--domr">정의역(Domain : $dom(R)$)</h3>
<blockquote>
  <p>집합 $A$ 에서 집합 $B$로 가는 이항관계 $R$에 속한 순서쌍의 <u>첫 번째 원소가 포함되어</u>있는 집합.</p>
</blockquote>

<ul>
  <li>$dom(R)$ = {$a$ : $a$ $\in$ $R$}</li>
</ul>

<h3 id="공역-공번역codomain--codomr">공역, 공번역(Codomain : $codom(R$))</h3>
<blockquote>
  <p>집합 $A$ 에서 집합 $B$로 가는 이항관계 $R$ 에 속한 순서쌍의 <u>두 번째 원소가 포함되어</u>있는 집합.</p>
</blockquote>

<ul>
  <li>$codom(R)$ = {$b$ : $b$ $\in$ $R$}</li>
</ul>

<h3 id="치역range--ranr">치역(Range : $ran(R)$)</h3>
<blockquote>
  <p>집합 $A$ 에서 집합 $B$로 가는 관계 $R$에 속한 순서쌍의 <u>두 번째 원소들을 모아놓은 집합</u>있는 집합.</p>
</blockquote>

<ul>
  <li>$ran(R)$ = {$b$ : $(a,b)$ $\in$ $R$} $\subseteq B$</li>
</ul>

<h2 id="역관계inverse-relation">역관계(Inverse relation)</h2>
<blockquote>
  <p>집합 $A$ 에서 $B$로의 이항관계 $R$ 의 역관계 $R^{-1}$ = {$(b,a)\in B \times A | (a,b) \in R$ }</p>
  <ul>
    <li>예시 ($A$ = {$1,3$}, $B$ = {$2,4$})
      <ul>
        <li>$R$ = {$(1,2), (1,4), (3,2), (3,4)$}</li>
        <li>$R^{-1}$ = {$(2,1), (4,1), (2,3), (4,3)$}</li>
      </ul>
    </li>
  </ul>
</blockquote>

<h1 id="관계의-표현-방법">관계의 표현 방법</h1>

<h2 id="화살표-도표">화살표 도표</h2>
<blockquote>
  <p>두 집합 원소 사이의 관계를 화살표로 나타내는 방법</p>
</blockquote>

<p><img src="/assets/images/Math/dm/dm_example_5_1.png" /></p>

<h2 id="좌표-도표">좌표 도표</h2>
<blockquote>
  <p>집합 $A$ 에서 집합 $B$로 가는 관계 $R$이 있을 때, 집합 $A$ (정의역)의 원소들을 $x$ 축에, 집합 $B$ (공역)의 원소들을  $y$축에 표시하여 관계 $R$을 나타내는 방법</p>
</blockquote>

<p><img src="/assets/images/Math/dm/dm_example_5_2.png" /></p>

<h2 id="방향-그래프">방향 그래프</h2>
<blockquote>
  <p>하나의 집합 $A$에서 집합 $A$로 가는 관계 $R$을 꼭짓점과 화살표를 이용해 나타낸 그래프</p>
  <ul>
    <li>루프(loop) : 특정 원소에서 시작해서 그 원소로 끝나는 화살표</li>
  </ul>
</blockquote>

<p><img src="/assets/images/Math/dm/dm_example_5_3.png" /></p>

<h2 id="관계-행렬">관계 행렬</h2>
<blockquote>
  <p>집합 $A$ 에서 집합 $B$로 가는 관계 $R$이 있을 때, 관계를 행렬로 표현한 방법</p>
  <ul>
    <li>$A$의 원소들을 행에 배치, $B$의 원소들을 열에 배치한 후 관계가 있으면 1, 없으면 0으로 행렬의 원소를 나타낸다.</li>
  </ul>
</blockquote>

<p><img src="/assets/images/Math/dm/dm_example_5_4.png" /></p>

<h1 id="관계의-성질">관계의 성질</h1>

<h2 id="반사성reflexive-relation">반사성(Reflexive Relation)</h2>
<blockquote>
  <p>집합 $A$ 에서 집합 $B$로 가는 관계 $R$이 있을 때, 모든 $a \in A$ 에 대해 $(a,a) \in R$ 인 관계</p>
</blockquote>

<h3 id="반사성-예시">반사성 예시</h3>

<ul>
  <li>
    <p>대각원소들이 모두 1인 관계행렬<br />
\(\begin{bmatrix}  
1 &amp; 0 &amp; 0 &amp; 0\\
0 &amp; 1 &amp; 0 &amp; 0\\
0 &amp; 0 &amp; 1 &amp; 0\\
0 &amp; 0 &amp; 0 &amp; 1\\
\end{bmatrix}\)</p>
  </li>
  <li>
    <p>모든 원소에 대해 루프<br />
<img src="/assets/images/Math/dm/dm_example_5_5.png" /></p>
  </li>
</ul>

<h2 id="대칭성symmetric-relation">대칭성(symmetric relation)</h2>
<blockquote>
  <p>집합 $A$ 에 대한 관계 $R$ 이 있을 때, 어떤 $a,b \in A$ 에 대해 $(a,b) \in R$ 이면 $(b,a) \in R$인 관계</p>
</blockquote>

<h3 id="대칭성-예시">대칭성 예시</h3>
<blockquote>
  <p>$M_r = [m_{ij}]$ 에서 $m_{ij} = m_{ji}$ 이다.</p>
</blockquote>

\[\begin{bmatrix}
0 &amp; 1 &amp; 0 &amp; 1\\
1 &amp; 0 &amp; 1 &amp; 0\\
0 &amp; 1 &amp; 0 &amp; 0\\
1 &amp; 0 &amp; 0 &amp; 1\\
\end{bmatrix}\]

<ul>
  <li>방향그래프 (양방향 화살표)<br />
<img src="/assets/images/Math/dm/dm_example_5_6.png" /></li>
</ul>

<h2 id="반대칭성antisymmetric">반대칭성(antisymmetric)</h2>
<blockquote>
  <p>집합 $A$ 에 대한 관계 $R$ 이 있을 때, 어떤 $(a,b) \in A$ 에 대해 $(a,b) \in R$ 이면 $(b,a) \in R$ 이고, $a = b$ 인 관계</p>
</blockquote>

<h3 id="반대칭성-예시">반대칭성 예시</h3>
<blockquote>
  <p>$M_r = [m_{ij}]$ 에서 $i \ne j $ 일 때, $m_{ij} = 0$ 또는 $m_{ji} = 0$ 이다.</p>
</blockquote>

\[\begin{bmatrix}
0 &amp; 0 &amp; 0 &amp; 0 \\
1 &amp; 0 &amp; 0 &amp; 0 \\
1 &amp; 1 &amp; 0 &amp; 0 \\
1 &amp; 1 &amp; 1 &amp; 0 \\
\end{bmatrix}\]

<h2 id="추이성transitive">추이성(Transitive)</h2>
<blockquote>
  <p>집합 $A$에 대한 관계 $R$이 있을 때, 어떤 $a,b,c \in A$에 대해 $(a,b) \in R$ 이고 $(b,c) \in R$ 이면 $(a,c) \in R$ 인 관계</p>
</blockquote>

<h3 id="추이성-예시">추이성 예시</h3>

\[\begin{bmatrix}
1 &amp; 1 &amp; 1 &amp; 1 \\
0 &amp; 1 &amp; 1 &amp; 1 \\
0 &amp; 0 &amp; 1 &amp; 1 \\
0 &amp; 0 &amp; 0 &amp; 1 \\
\end{bmatrix}\]

<h1 id="참조">참조</h1>
<p><a href="http://bigdata.dongguk.ac.kr/lectures/disc_math/_book/%EA%B4%80%EA%B3%84.html">http://bigdata.dongguk.ac.kr/lectures/disc_math/_book/%EA%B4%80%EA%B3%84.html</a><br />
<a href="https://ko.wikipedia.org/wiki/%EA%B4%80%EA%B3%84_(%EC%88%98%ED%95%99)">https://ko.wikipedia.org/wiki/%EA%B4%80%EA%B3%84_(%EC%88%98%ED%95%99)</a><br />
<a href="https://ko.wikipedia.org/wiki/%EC%A0%95%EC%9D%98%EC%97%AD">https://ko.wikipedia.org/wiki/%EC%A0%95%EC%9D%98%EC%97%AD</a><br />
<a href="https://johngrib.github.io/wiki/relations/#%EB%8C%80%EC%B9%AD-%EB%B0%98%EB%8C%80%EC%B9%AD-%EA%B4%80%EA%B3%84">https://johngrib.github.io/wiki/relations/#%EB%8C%80%EC%B9%AD-%EB%B0%98%EB%8C%80%EC%B9%AD-%EA%B4%80%EA%B3%84</a></p>]]></content><author><name>지지형</name></author><category term="Discrete Mathematics" /><summary type="html"><![CDATA[관계(Relation)란? 객체들 간의 연관성을 표현하는 구조이다. 집합론에서는 곱집합의 부분집합이다. 다른 두 집합에 속하는 서로 다른 두 원소의 관계를 나타낸 것. 이항관계 (binary relations) 집합 $A$ 와 $B$ 가 있을 때, $A$ 와 $B$ 의 곱집합 ($A \times B$)의 부분집합 $R$ 을 $A$ 에서 $B$ 로 가는 관계라고 한다. $a \in A$ 고, $b \in B$ 일 때, $(a ,b) \in A \times B$ 이면 ${a}\mathrm{R}{b}$ 순서쌍(ordered pair) 어떠한 원소 $a \in A, b \in B$ 와 같이 순서를 가진 쌍을 순서쌍이라고 한다. $a$ 를 첫 번째, $b$ 를 두 번째 원소라고 한다. 순서쌍 예시 $A$ = {$(x | 1 \le x \le 3 , x는 정수)$} $A$ 에서 $A$ 로 가는 관계 $R$ 은 다음과 같을 때, 관계 $R$ 을 순서쌍으로 나타내시오. $R$ = {$((a,b)|a \times b 는 홀수, a \in A, b \in A )$} $R$ = {$(1,1), (1,3), (3,1), (3,3)$} 곱집합(cartesian product) 이산수학 04.집합 참고 정의역(Domain : $dom(R)$) 집합 $A$ 에서 집합 $B$로 가는 이항관계 $R$에 속한 순서쌍의 첫 번째 원소가 포함되어있는 집합. $dom(R)$ = {$a$ : $a$ $\in$ $R$} 공역, 공번역(Codomain : $codom(R$)) 집합 $A$ 에서 집합 $B$로 가는 이항관계 $R$ 에 속한 순서쌍의 두 번째 원소가 포함되어있는 집합. $codom(R)$ = {$b$ : $b$ $\in$ $R$} 치역(Range : $ran(R)$) 집합 $A$ 에서 집합 $B$로 가는 관계 $R$에 속한 순서쌍의 두 번째 원소들을 모아놓은 집합있는 집합. $ran(R)$ = {$b$ : $(a,b)$ $\in$ $R$} $\subseteq B$ 역관계(Inverse relation) 집합 $A$ 에서 $B$로의 이항관계 $R$ 의 역관계 $R^{-1}$ = {$(b,a)\in B \times A | (a,b) \in R$ } 예시 ($A$ = {$1,3$}, $B$ = {$2,4$}) $R$ = {$(1,2), (1,4), (3,2), (3,4)$} $R^{-1}$ = {$(2,1), (4,1), (2,3), (4,3)$} 관계의 표현 방법 화살표 도표 두 집합 원소 사이의 관계를 화살표로 나타내는 방법 좌표 도표 집합 $A$ 에서 집합 $B$로 가는 관계 $R$이 있을 때, 집합 $A$ (정의역)의 원소들을 $x$ 축에, 집합 $B$ (공역)의 원소들을 $y$축에 표시하여 관계 $R$을 나타내는 방법 방향 그래프 하나의 집합 $A$에서 집합 $A$로 가는 관계 $R$을 꼭짓점과 화살표를 이용해 나타낸 그래프 루프(loop) : 특정 원소에서 시작해서 그 원소로 끝나는 화살표 관계 행렬 집합 $A$ 에서 집합 $B$로 가는 관계 $R$이 있을 때, 관계를 행렬로 표현한 방법 $A$의 원소들을 행에 배치, $B$의 원소들을 열에 배치한 후 관계가 있으면 1, 없으면 0으로 행렬의 원소를 나타낸다. 관계의 성질 반사성(Reflexive Relation) 집합 $A$ 에서 집합 $B$로 가는 관계 $R$이 있을 때, 모든 $a \in A$ 에 대해 $(a,a) \in R$ 인 관계 반사성 예시 대각원소들이 모두 1인 관계행렬 \(\begin{bmatrix} 1 &amp; 0 &amp; 0 &amp; 0\\ 0 &amp; 1 &amp; 0 &amp; 0\\ 0 &amp; 0 &amp; 1 &amp; 0\\ 0 &amp; 0 &amp; 0 &amp; 1\\ \end{bmatrix}\) 모든 원소에 대해 루프 대칭성(symmetric relation) 집합 $A$ 에 대한 관계 $R$ 이 있을 때, 어떤 $a,b \in A$ 에 대해 $(a,b) \in R$ 이면 $(b,a) \in R$인 관계 대칭성 예시 $M_r = [m_{ij}]$ 에서 $m_{ij} = m_{ji}$ 이다. \[\begin{bmatrix} 0 &amp; 1 &amp; 0 &amp; 1\\ 1 &amp; 0 &amp; 1 &amp; 0\\ 0 &amp; 1 &amp; 0 &amp; 0\\ 1 &amp; 0 &amp; 0 &amp; 1\\ \end{bmatrix}\] 방향그래프 (양방향 화살표) 반대칭성(antisymmetric) 집합 $A$ 에 대한 관계 $R$ 이 있을 때, 어떤 $(a,b) \in A$ 에 대해 $(a,b) \in R$ 이면 $(b,a) \in R$ 이고, $a = b$ 인 관계 반대칭성 예시 $M_r = [m_{ij}]$ 에서 $i \ne j $ 일 때, $m_{ij} = 0$ 또는 $m_{ji} = 0$ 이다. \[\begin{bmatrix} 0 &amp; 0 &amp; 0 &amp; 0 \\ 1 &amp; 0 &amp; 0 &amp; 0 \\ 1 &amp; 1 &amp; 0 &amp; 0 \\ 1 &amp; 1 &amp; 1 &amp; 0 \\ \end{bmatrix}\] 추이성(Transitive) 집합 $A$에 대한 관계 $R$이 있을 때, 어떤 $a,b,c \in A$에 대해 $(a,b) \in R$ 이고 $(b,c) \in R$ 이면 $(a,c) \in R$ 인 관계 추이성 예시 \[\begin{bmatrix} 1 &amp; 1 &amp; 1 &amp; 1 \\ 0 &amp; 1 &amp; 1 &amp; 1 \\ 0 &amp; 0 &amp; 1 &amp; 1 \\ 0 &amp; 0 &amp; 0 &amp; 1 \\ \end{bmatrix}\] 참조 http://bigdata.dongguk.ac.kr/lectures/disc_math/_book/%EA%B4%80%EA%B3%84.html https://ko.wikipedia.org/wiki/%EA%B4%80%EA%B3%84_(%EC%88%98%ED%95%99) https://ko.wikipedia.org/wiki/%EC%A0%95%EC%9D%98%EC%97%AD https://johngrib.github.io/wiki/relations/#%EB%8C%80%EC%B9%AD-%EB%B0%98%EB%8C%80%EC%B9%AD-%EA%B4%80%EA%B3%84]]></summary></entry><entry><title type="html">[백준] 7568 : 덩치 (파이썬)</title><link href="http://localhost:4000/boj/BOJ-7568/" rel="alternate" type="text/html" title="[백준] 7568 : 덩치 (파이썬)" /><published>2023-10-20T00:00:00+09:00</published><updated>2023-10-20T00:00:00+09:00</updated><id>http://localhost:4000/boj/BOJ-7568</id><content type="html" xml:base="http://localhost:4000/boj/BOJ-7568/"><![CDATA[<h1 id="-난이도">🔎 난이도</h1>
<blockquote>
  <p>⚪️ <strong>실버 5</strong></p>
</blockquote>

<h1 id="️-문제">✏️ 문제</h1>
<blockquote>
  <p><a href="https://www.acmicpc.net/problem/7568">https://www.acmicpc.net/problem/7568</a></p>
</blockquote>

<p><img src="/assets/images/Coding_test/Boj/BOJ_7568_1.png" />
<img src="/assets/images/Coding_test/Boj/BOJ_7568_2.png" />
<br /></p>

<h1 id="-예제-입력-및-출력">🤖 예제 입력 및 출력</h1>

<p><img src="/assets/images/Coding_test/Boj/BOJ_7568_3.png" /></p>

<p><br /></p>

<h1 id="-알고리즘-분류">📑 알고리즘 분류</h1>

<ul>
  <li>구현</li>
  <li>브루트포스 알고리즘</li>
</ul>

<p><br /></p>

<h1 id="-아이디어">🧐 아이디어</h1>

<blockquote>
  <p>처음에 다양한 정렬을 해보며 시도하였지만, 풀수가 없었다. 하지만 문제를 다시 살펴보니 문제 안에   답이 있었다.</p>
  <ul>
    <li>N명의 집단에서 각 사람의 덩치 등수는 자신보다 더 “큰 덩치”의 사람의 수로 정해진다.</li>
    <li>즉, 몸무게와 키 모두 큰 사람이 덩치 등수가 높다.</li>
    <li>만약 몸무게와 키 둘 중 하나만 큰 상태에서는 덩치 등수를 매길 수 없다.
      <ul>
        <li>같은 덩치 등수를 가진 사람은 여러명이다.</li>
      </ul>
    </li>
  </ul>
</blockquote>

<blockquote>
  <p>결론은 각 몸무게와 키를 비교하면 전체 사람의 덩치 등수를 구할 수 있다.</p>
</blockquote>

<p><br /></p>

<h1 id="-내-풀이">📝 내 풀이</h1>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># 입력
</span><span class="n">n</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">input</span><span class="p">())</span>

<span class="c1"># (몸무게, 덩체) 튜플 형식을 입력 받기
</span><span class="n">lst</span> <span class="o">=</span> <span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">input</span><span class="p">().</span><span class="n">split</span><span class="p">()))</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)]</span> 

<span class="c1"># print(lst) - [(55, 185), (58, 183), (88, 186), (60, 175), (46, 155)]
</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">lst</span><span class="p">:</span>
    <span class="n">rank</span> <span class="o">=</span> <span class="mi">1</span> <span class="c1"># 순위 초기화
</span>    <span class="n">w</span><span class="p">,</span><span class="n">h</span> <span class="o">=</span> <span class="n">i</span> <span class="c1"># 순위를 매길 몸무게와 키;
</span>    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">lst</span><span class="p">:</span>
        <span class="n">w1</span><span class="p">,</span> <span class="n">h1</span> <span class="o">=</span> <span class="n">j</span> <span class="c1"># 비교할 몸무게와 키
</span>
        <span class="c1"># 비교할 몸무게와 키가 모두 크다면, 즉 순위를 매길 몸무게가 더 작다면 순위 증가
</span>        <span class="k">if</span> <span class="n">w</span> <span class="o">&lt;</span> <span class="n">w1</span> <span class="ow">and</span> <span class="n">h</span> <span class="o">&lt;</span> <span class="n">h1</span><span class="p">:</span> 
            <span class="n">rank</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="k">print</span><span class="p">(</span><span class="n">rank</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s">' '</span><span class="p">)</span> <span class="c1"># 순위 이어서 출력하기
</span>
</code></pre></div></div>
<p><br /></p>

<h1 id="-풀이-리뷰">😳 풀이 리뷰</h1>

<blockquote>
  <p>이중 반복문을 통해 w,h에 순위를 매길 몸무게와 키를 w1, h1에는 비교할 몸무게와 키를 담고 비교하여 덩치 등수를 매겼다.</p>
</blockquote>]]></content><author><name>지지형</name></author><category term="BOJ" /><summary type="html"><![CDATA[🔎 난이도 ⚪️ 실버 5 ✏️ 문제 https://www.acmicpc.net/problem/7568 🤖 예제 입력 및 출력 📑 알고리즘 분류 구현 브루트포스 알고리즘 🧐 아이디어 처음에 다양한 정렬을 해보며 시도하였지만, 풀수가 없었다. 하지만 문제를 다시 살펴보니 문제 안에 답이 있었다. N명의 집단에서 각 사람의 덩치 등수는 자신보다 더 “큰 덩치”의 사람의 수로 정해진다. 즉, 몸무게와 키 모두 큰 사람이 덩치 등수가 높다. 만약 몸무게와 키 둘 중 하나만 큰 상태에서는 덩치 등수를 매길 수 없다. 같은 덩치 등수를 가진 사람은 여러명이다. 결론은 각 몸무게와 키를 비교하면 전체 사람의 덩치 등수를 구할 수 있다. 📝 내 풀이 # 입력 n = int(input()) # (몸무게, 덩체) 튜플 형식을 입력 받기 lst = [tuple(map(int, input().split())) for _ in range(n)] # print(lst) - [(55, 185), (58, 183), (88, 186), (60, 175), (46, 155)] for i in lst: rank = 1 # 순위 초기화 w,h = i # 순위를 매길 몸무게와 키; for j in lst: w1, h1 = j # 비교할 몸무게와 키 # 비교할 몸무게와 키가 모두 크다면, 즉 순위를 매길 몸무게가 더 작다면 순위 증가 if w &lt; w1 and h &lt; h1: rank += 1 print(rank, end=' ') # 순위 이어서 출력하기 😳 풀이 리뷰 이중 반복문을 통해 w,h에 순위를 매길 몸무게와 키를 w1, h1에는 비교할 몸무게와 키를 담고 비교하여 덩치 등수를 매겼다.]]></summary></entry><entry><title type="html">[백준] 4673 : 셀프 넘버 (파이썬)</title><link href="http://localhost:4000/boj/BOJ-4673/" rel="alternate" type="text/html" title="[백준] 4673 : 셀프 넘버 (파이썬)" /><published>2023-10-20T00:00:00+09:00</published><updated>2023-10-20T00:00:00+09:00</updated><id>http://localhost:4000/boj/BOJ-4673</id><content type="html" xml:base="http://localhost:4000/boj/BOJ-4673/"><![CDATA[<h1 id="-난이도">🔎 난이도</h1>
<blockquote>
  <p>⚪️ <strong>실버 5</strong></p>
</blockquote>

<h1 id="️-문제">✏️ 문제</h1>
<blockquote>
  <p><a href="https://www.acmicpc.net/problem/4673">https://www.acmicpc.net/problem/4673</a></p>
</blockquote>

<p><img src="/assets/images/Coding_test/Boj/BOJ_4673_1.png" /></p>

<p><br /></p>

<h1 id="-예제-입력-및-출력">🤖 예제 입력 및 출력</h1>

<p><img src="/assets/images/Coding_test/Boj/BOJ_4673_2.png" /></p>

<p><br /></p>

<h1 id="-알고리즘-분류">📑 알고리즘 분류</h1>

<ul>
  <li>수학</li>
  <li>구현</li>
  <li>브루트포스 알고리즘</li>
</ul>

<p><br /></p>

<h1 id="-아이디어">🧐 아이디어</h1>

<blockquote>
  <p>10,000 보다 작거나 같은 <strong>셀프 넘버</strong> 를 출력하는 문제이다.</p>
  <ul>
    <li>생성자 : 양의 정수 $n$ 에 대해서 $n$ 과 $n$ 의 각 자리수를 더하는 함수라고 정의해보면 $d(75) = 75 + 7 + 5 = 87$
      <ul>
        <li>$75$ 는 $d(75) = 87$ 의 생성자이다.</li>
      </ul>
    </li>
    <li>셀프넘버 : 위의 경우처럼 생성자가 있는 것이 아니라 생성자가 없을 경우 셀프 넘버라고 한다.
      <ul>
        <li>각 자리수를 더하여 $31$ 을 만들 수 있는 숫자는 없기에, $31$ 은 셀프 넘버이다.</li>
      </ul>
    </li>
  </ul>
</blockquote>

<p><br /></p>

<h1 id="-내-풀이">📝 내 풀이</h1>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># 생성자 함수
</span><span class="k">def</span> <span class="nf">d</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">:</span> <span class="c1"># 한 자리 수일 경우
</span>        <span class="k">return</span> <span class="n">n</span> <span class="o">+</span> <span class="n">n</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">n</span> <span class="o">+</span> <span class="nb">sum</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">n</span><span class="p">)))</span> <span class="c1"># n과 각 자리수의 합 더하기
</span>
<span class="n">self_num</span> <span class="o">=</span> <span class="p">[</span><span class="bp">True</span><span class="p">]</span> <span class="o">*</span> <span class="mi">10001</span> <span class="c1"># 셀프넘버 리스트
</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">self_num</span><span class="p">)):</span> <span class="c1"># 1 ~ 10000
</span>    <span class="k">if</span> <span class="n">d</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">10000</span><span class="p">:</span> <span class="c1"># 10000보다 작거나 같을 경우
</span>        <span class="n">self_num</span><span class="p">[</span><span class="n">d</span><span class="p">(</span><span class="n">i</span><span class="p">)]</span> <span class="o">=</span> <span class="bp">False</span> <span class="c1"># 생성자일 경우 False 처리 (셀프넘버가 아닐 경우)
</span>
<span class="c1"># 출력
</span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">self_num</span><span class="p">)):</span>
    <span class="k">if</span> <span class="n">self_num</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="bp">True</span><span class="p">:</span> <span class="k">print</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="c1"># 셀프넘버(True)일 경우 출력
</span></code></pre></div></div>
<p><br /></p>

<h1 id="-풀이-리뷰">😳 풀이 리뷰</h1>
<blockquote>
  <p>위 아이디어에서 정리한 개념을 이해 한 후</p>
</blockquote>

<ol>
  <li>인덱스를 통해 문제를 풀어야겠다고 생각했다.</li>
  <li>True로 이루어진 10001개의 셀프넘버 리스트</li>
  <li>반복문을 통해 생성자가 있을 경우 False 처리를 해주는 함수 정의.</li>
  <li>셀프넘버 리스트 True로 남아있는 원소(셀프넘버)의 인덱스를 출력해줌으로써 문제를 해결하였다.</li>
</ol>]]></content><author><name>지지형</name></author><category term="BOJ" /><summary type="html"><![CDATA[🔎 난이도 ⚪️ 실버 5 ✏️ 문제 https://www.acmicpc.net/problem/4673 🤖 예제 입력 및 출력 📑 알고리즘 분류 수학 구현 브루트포스 알고리즘 🧐 아이디어 10,000 보다 작거나 같은 셀프 넘버 를 출력하는 문제이다. 생성자 : 양의 정수 $n$ 에 대해서 $n$ 과 $n$ 의 각 자리수를 더하는 함수라고 정의해보면 $d(75) = 75 + 7 + 5 = 87$ $75$ 는 $d(75) = 87$ 의 생성자이다. 셀프넘버 : 위의 경우처럼 생성자가 있는 것이 아니라 생성자가 없을 경우 셀프 넘버라고 한다. 각 자리수를 더하여 $31$ 을 만들 수 있는 숫자는 없기에, $31$ 은 셀프 넘버이다. 📝 내 풀이 # 생성자 함수 def d(n): if n &lt; 10: # 한 자리 수일 경우 return n + n else: return n + sum(map(int, str(n))) # n과 각 자리수의 합 더하기 self_num = [True] * 10001 # 셀프넘버 리스트 for i in range(1,len(self_num)): # 1 ~ 10000 if d(i) &lt;= 10000: # 10000보다 작거나 같을 경우 self_num[d(i)] = False # 생성자일 경우 False 처리 (셀프넘버가 아닐 경우) # 출력 for i in range(1,len(self_num)): if self_num[i] == True: print(i) # 셀프넘버(True)일 경우 출력 😳 풀이 리뷰 위 아이디어에서 정리한 개념을 이해 한 후 인덱스를 통해 문제를 풀어야겠다고 생각했다. True로 이루어진 10001개의 셀프넘버 리스트 반복문을 통해 생성자가 있을 경우 False 처리를 해주는 함수 정의. 셀프넘버 리스트 True로 남아있는 원소(셀프넘버)의 인덱스를 출력해줌으로써 문제를 해결하였다.]]></summary></entry><entry><title type="html">[백준] 2309 : 일곱 난쟁이 (파이썬)</title><link href="http://localhost:4000/boj/BOJ-2309/" rel="alternate" type="text/html" title="[백준] 2309 : 일곱 난쟁이 (파이썬)" /><published>2023-10-19T00:00:00+09:00</published><updated>2023-10-19T00:00:00+09:00</updated><id>http://localhost:4000/boj/BOJ-2309</id><content type="html" xml:base="http://localhost:4000/boj/BOJ-2309/"><![CDATA[<h1 id="-난이도">🔎 난이도</h1>
<blockquote>
  <p>🟤 <strong>브론즈 1</strong></p>
</blockquote>

<h1 id="️-문제">✏️ 문제</h1>
<blockquote>
  <p><a href="https://www.acmicpc.net/problem/2309">https://www.acmicpc.net/problem/2309</a></p>
</blockquote>

<p><img src="/assets/images/Coding_test/Boj/BOJ_2309_1.png" />
<br /></p>

<h1 id="-예제-입력-및-출력">🤖 예제 입력 및 출력</h1>

<p><img src="/assets/images/Coding_test/Boj/BOJ_2309_2.png" /></p>

<p><br /></p>

<h1 id="-알고리즘-분류">📑 알고리즘 분류</h1>

<ul>
  <li>브루트포스 알고리즘</li>
  <li>정렬</li>
</ul>

<p><br /></p>

<h1 id="-아이디어">🧐 아이디어</h1>
<blockquote>
  <p>문제를 보자마자 순열과 조합이 떠올랐다.</p>
  <ul>
    <li>순열과 조합은 서로 다른 n개에서 r개를 고르는 경우의 수이다. 간단하게 순열은 순서를 고려한 것, 조합은 순서를 고려하지 않는다.
      <ul>
        <li>자세한 설명은 <a href="[wlgudths](https://wlgudths.github.io/)">이산수학파트에서 업로드 예정</a></li>
      </ul>
    </li>
  </ul>
</blockquote>

<blockquote>
  <p>9명의 난쟁이 중에 7명을 뽑아 키의 총합이 100이되면 <u>진짜 난쟁이 7명</u>을 찾을 수 있다.<br />
하지만 for문을 7번 쓸 수도 없고 매우 복잡해질 것이다.<br />
난쟁이 9명 중에서 진짜 난쟁이를 찾는 것보다 <u>가짜 난쟁이 2명</u>을 찾는 것이 더 효율적일 것이다.<br />
가짜 난쟁이 2명의 합은 9명의 합 - 100을 하면 구할 수 있다.</p>
</blockquote>

<p><br /></p>

<h1 id="-첫-풀이">📝 첫 풀이</h1>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># 입력
</span><span class="n">dwarf</span> <span class="o">=</span> <span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="nb">input</span><span class="p">())</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">9</span><span class="p">)]</span>

<span class="c1"># 총합 - 100
</span><span class="n">fake</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">dwarf</span><span class="p">)</span> <span class="o">-</span> <span class="mi">100</span>

<span class="c1"># 9명의 난쟁이 중 가짜 난쟁이 뽑기
</span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">dwarf</span><span class="p">)):</span>
    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">dwarf</span><span class="p">)):</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">dwarf</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">dwarf</span><span class="p">[</span><span class="n">j</span><span class="p">])</span> <span class="o">==</span> <span class="n">fake</span><span class="p">:</span>
            <span class="n">fake_1</span><span class="p">,</span> <span class="n">fake_2</span> <span class="o">=</span> <span class="n">dwarf</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">dwarf</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
            <span class="k">break</span>


<span class="c1"># 오름차순 정렬
</span><span class="n">dwarf</span><span class="p">.</span><span class="n">sort</span><span class="p">()</span>

<span class="c1"># 출력
</span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">dwarf</span><span class="p">:</span>
    <span class="k">if</span> <span class="n">fake_1</span> <span class="o">!=</span> <span class="n">i</span> <span class="ow">and</span> <span class="n">fake_2</span> <span class="o">!=</span> <span class="n">i</span><span class="p">:</span> <span class="c1"># 가짜 난쟁이를 제외하고 print
</span>        <span class="k">print</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
</code></pre></div></div>

<p><br /></p>

<h1 id="-풀이-리뷰">😳 풀이 리뷰</h1>
<blockquote>
  <p>fake라는 변수에 가짜 난쟁이의 합을 담고, 이중반복문을 통해 36가지 가짜 난쟁이 조합의 합이 fake와 같을 경우 반복문을 탈출 한 후 정렬, 출력하였다.</p>
</blockquote>

<h1 id="-두-번째-풀이">📝 두 번째 풀이</h1>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">itertools</span> <span class="kn">import</span> <span class="n">combinations</span>

<span class="c1"># 입력
</span><span class="n">dwarf</span> <span class="o">=</span> <span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="nb">input</span><span class="p">())</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">9</span><span class="p">)]</span>

<span class="c1"># 의심 난쟁이 두 명씩 뽑기
</span><span class="n">fake_lst</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">combinations</span><span class="p">(</span><span class="n">dwarf</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span>

<span class="c1"># 가짜 난쟁이 키의 합
</span><span class="n">fake_num</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">dwarf</span><span class="p">)</span> <span class="o">-</span> <span class="mi">100</span>

<span class="c1"># 가짜 난쟁이 찾아내기
</span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">fake_lst</span><span class="p">:</span>
    <span class="k">if</span> <span class="nb">sum</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">==</span> <span class="n">fake_num</span><span class="p">:</span>
        <span class="n">fake</span> <span class="o">=</span> <span class="n">i</span>
        <span class="k">break</span>

<span class="c1"># 오름차순 정렬
</span><span class="n">dwarf</span><span class="p">.</span><span class="n">sort</span><span class="p">()</span>

<span class="c1"># 가짜 난쟁이를 제외한 진짜 난쟁이들 출력
</span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">dwarf</span><span class="p">:</span>
    <span class="k">if</span> <span class="n">i</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">fake</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
</code></pre></div></div>

<h1 id="-풀이-리뷰-1">😳 풀이 리뷰</h1>
<blockquote>
  <p>첫 번째 풀이와 방식은 비슷하지만, itertools 모듈의 combinations를 활용하여 36가지의 의심 난쟁이들을 fake_lst에 담았다. 이후 첫 번째 풀이와 같다.</p>
</blockquote>]]></content><author><name>지지형</name></author><category term="BOJ" /><summary type="html"><![CDATA[🔎 난이도 🟤 브론즈 1]]></summary></entry><entry><title type="html">[이산수학] 증명(Proofs)</title><link href="http://localhost:4000/discrete%20mathematics/DM-04/" rel="alternate" type="text/html" title="[이산수학] 증명(Proofs)" /><published>2023-10-19T00:00:00+09:00</published><updated>2023-10-19T00:00:00+09:00</updated><id>http://localhost:4000/discrete%20mathematics/DM-04</id><content type="html" xml:base="http://localhost:4000/discrete%20mathematics/DM-04/"><![CDATA[<h1 id="증명proofs이란">증명(Proofs)이란?</h1>
<blockquote>
  <p>특정한 공리(Axiom)들을 가정하고, 그 가정 하에서 어떤 명제가 참이라는 것을 보여주는 것이다.</p>
</blockquote>

<hr />

<h1 id="증명관련-용어">증명관련 용어</h1>
<h2 id="정리-theorem">정리 (Theorem)</h2>
<blockquote>
  <p>정리란 공리와 정의를 통해 참(True)으로 증명된 명제이다.</p>
  <ul>
    <li>피타고라스의 정리 (Pythagorean theorem)</li>
  </ul>
</blockquote>

<h2 id="정의-definition">정의 (Definition)</h2>
<blockquote>
  <p>용어 또는 기호의 의미를 확실하게 규정한 문장이나 식, 용어의 뜻에 대한 약속</p>
  <ul>
    <li>삼각형 : 세 개의 선분으로 둘러싸인 다각형</li>
  </ul>
</blockquote>

<h2 id="공리-axiom">공리 (Axiom)</h2>
<blockquote>
  <p>증명이 불필요한 명제</p>
  <ul>
    <li>페아노의 공리 : 어떤 자연수에 대해서도, 그 수의 ‘다음’ 자연수(따름수)가 존재한다.
      <ul>
        <li>자연수 N에 대하여, N + 1 이 존재한다.</li>
      </ul>
    </li>
  </ul>
</blockquote>

<h2 id="가설-conjecture">가설 (Conjecture)</h2>
<blockquote>
  <p>증명되지는 않았지만 참으로 믿어지는 명제</p>
</blockquote>

<h2 id="이론-theory">이론 (Theory)</h2>
<blockquote>
  <p>공리(axiom)로부터 증명이 가능한 모든 정리(theorem)의 집합</p>
</blockquote>

<hr />

<h1 id="방법론">방법론</h1>

<h2 id="연역법deduction">연역법(deduction)</h2>
<blockquote>
  <p>주어진 사실(facts)들과 공리(axioms)들에 입각하여 추론(inference)을 통하여 새로운 사실을 도출하는 것</p>
</blockquote>

<ul>
  <li>예시(일반적)
    <ul>
      <li>모든 사람은 죽는다. 소크라테스는 사람이다. 그러므로 소크라테스는 죽는다.</li>
    </ul>
  </li>
</ul>

<h2 id="귀납법induction">귀납법(induction)</h2>
<blockquote>
  <p>관찰과 실험에 기반한 가설을 귀납 추론을 통하여 일반적인 규칙을 입증하는 것</p>
</blockquote>

<ul>
  <li>예시(일반적)
    <ul>
      <li>A새는 난다. B새도 난다. C새도 난다. 그러므로 모든 새는 날 수있다.</li>
    </ul>
  </li>
</ul>

<h2 id="수학적-귀납법">수학적 귀납법</h2>
<blockquote>
  <p>명제 $p_1, p_2, p_3, \cdots, p_n$ 이 참이라고 할 때, $p_n+1$의 경우에도 성립함을 보이면 된다.</p>
</blockquote>

<h3 id="수학적-귀납법-예시">수학적 귀납법 예시</h3>
<blockquote>
  <p>가우스 식</p>
  <ul>
    <li>$1 + 2 + 3 \cdots + n = \frac{n \times (n+1)}{2}$
      <ol>
        <li>$P(n) = \frac{n \times (n+1)}{2}$</li>
        <li>$P(1) = \frac{1 \times (1+1)}{2} = 1 \rightarrow True$ <br /></li>
        <li>귀납 가정 : $P(k) = \frac{k \times (k+1)}{2}$ ($n$이 $k$일 경우도 성립) <br /></li>
        <li>귀납 단계 : $P(k+1) = \frac{(k+1) \times (k+2)}{2}$  <br />
          <ul>
            <li>$P(k+1) = P(k) + (k+1)$  <br /><br />
   $= \frac{k \times (k+1)}{2} + (k+1)$  <br /><br />
   $= \frac{k^2 + k + 2k + 2}{2}$  <br /><br />
   $= \frac{k^2 + 3k + 2}{2}$  <br /><br />
   $= \frac{(k+1)(k+2)}{2}$</li>
          </ul>
        </li>
      </ol>
    </li>
  </ul>
</blockquote>

<h1 id="다양한-증명법">다양한 증명법</h1>

<h2 id="1직접-증명법-direct-proof">1.직접 증명법 (Direct Proof)</h2>
<blockquote>
  <p>주어진 명제를 참이라고 가정하고, 정리와 공리를 이용해서 명제가 참이 됨을 증명하는 방법이다.<br />
명제 $p \rightarrow q$ 의 직접증명은 논리적으로 $p$의 진리값이 참일 때 $q$도 참임을 보이는 증명 방법이다.</p>
</blockquote>

<h3 id="예시">예시</h3>
<blockquote>
  <p>두 홀수의 곱이 홀수임을 증명하라</p>
  <ul>
    <li>$p$ : 두 수 $a,b$은 홀수이다.</li>
    <li>$q$ : $a$ 와 $b$ 의 곱은 홀수이다.</li>
    <li>$p \rightarrow q$ : 두 홀수 $a,b$ 의 곱은 홀수이다.</li>
    <li>증명
      <ul>
        <li>두 정수 $k$ 와 $j$ 가 있을 때, 홀수 $a,b$ 는 각각 $a = 2k + 1, b = 2j + 1$ 로 표현할 수 있다.</li>
        <li>$a \times b = (2k + 1) \times (2j + 1) = 4kj + 2k + 2j + 1 = 2(2kj + k + j) + 1$</li>
        <li>$k$ 와 $j$ 는 정수이므로 $2kj + k + j$ 은 정수가되어 $2(2kj + k + j)$ 는 반드시 짝수가 되고, $2(2kj + k + j) + 1$ 은 반드시 홀수가 된다.</li>
        <li>따라서 두 홀수 $a,b$의 곱은 홀수이다 라는 명제는 참이 된다.</li>
      </ul>
    </li>
  </ul>
</blockquote>

<h2 id="2반례-증명법-proof-by-counter-example">2.반례 증명법 (Proof by Counter-example)</h2>
<blockquote>
  <p>$P(x)$ 가 명제함수라고 할 때, $\forall P(x)$ 중 단 하나의 값이라도 $P(x)$를 거짓으로 만드는 반례(counterexample)찾아서 명제가 거짓임을 증명하는 방법이다.</p>
</blockquote>

<h3 id="예시-1">예시</h3>
<blockquote>
  <p>모든 실수 $x$ 에 대하여 $x^2 &gt; 0$이 성립하는가?</p>
</blockquote>

<ul>
  <li>증명
    <ul>
      <li>$x = 0$ 이면 $x^2 = 0$ 이 되어, $x^2 &gt; 0$ 을 만족하지 않는다.</li>
      <li>따라서, 명제는 거짓이 되고, 반례는 $x = 0$이 된다.</li>
    </ul>
  </li>
</ul>

<h2 id="3모순-증명법-proof-by-contradiction">3.모순 증명법 (Proof by Contradiction)</h2>
<blockquote>
  <p>주어진 명제를 부정하면 모순(contradiction)이 된다는 것을 입증하는 방법이다.<br />
즉, 모순 증명법은 결론을 거짓이라고 가정할 경우, 모순이 도출되도록 하는 증명법이다.</p>
</blockquote>

<h3 id="예시-2">예시</h3>
<blockquote>
  <p>$\sqrt{2}$ 는 무리수이다.</p>
</blockquote>

<ul>
  <li>증명
    <ul>
      <li>$p : \sqrt{2}$ 이다.</li>
      <li>$\lnot p$ : $\sqrt{2}$ 는 무리수가 아니다. = $\sqrt{2}$ 는 유리수이다.</li>
      <li>유리수의 정의에 의하여 어떤 서로소인 정수 $a,b$가 존재하여 $\sqrt{2}$ = ${a}\over{b}$ 이다.</li>
      <li>양변에 $b$ 를 곱한 후 제곱을 하면 $2b^2 = a^2$ 이 된다.</li>
      <li>$a^2$ 이 2의 배수이므로 $a$ 는 짝수이다.</li>
      <li>$a$ 를 2로 나눈 몫을 $k$ 라고 하면, $a = 2k$ 가 되고 $2b^2 = a^2$ 에 대입하면 $2b^2 = 4k^2$ 이므로 $b^2 = 2k^2$이 되어 $b$ 도 2의 배수가 된다.</li>
      <li>$a$ 와 $b$ 는 서로소 이므로 둘이 동시에 2의 배수인 것은 가정에 모순이다.</li>
      <li>$\therefore$ $\sqrt{2}$ 는 무리수이다.</li>
    </ul>
  </li>
</ul>

<h2 id="4대우-증명법-contrapositive-proof">4.대우 증명법 (Contrapositive Proof)</h2>
<blockquote>
  <p>$p \rightarrow q$ 와 $\lnot p \rightarrow \lnot q$ 가 대우 관계 논리적 동치가 됨을 이용하여<br />
$p \rightarrow q$ 가 참이 되는 것을 간접적으로 보여주는 증명 방법이다.</p>
</blockquote>

<h3 id="예시-3">예시</h3>
<blockquote>
  <p>$3n + 2$ 가 홀수이면 $n$ 은 홀수이다.</p>
</blockquote>

<ul>
  <li>증명
    <ul>
      <li>$p : 3n + 2 = 2k + 1$</li>
      <li>$q : n = 2k’ + 1$</li>
      <li>대우 관계를 이용하여 $n$ 이 짝수이면 $3n + 2$ 도 짝수이다.</li>
      <li>$n = 2k$이면 $3n + 2 = 3(2k) + 2 = 2(3k + 1)$</li>
      <li>따라서, $n$ 이 짝수이면 $3n + 2$ 도 짝수이고, 대우관계에 의해 $3n + 2$ 가 홀수이면 $n$ 은 홀수이다.</li>
    </ul>
  </li>
</ul>

<h2 id="5동치-증명법-필요충분조건-증명법-if-and-only-if-proof">5.동치 증명법, 필요충분조건 증명법 (if and only if proof)</h2>
<blockquote>
  <p>$p \leftrightarrow q$ 를 증명하기 위해 $p \rightarrow q$ 와 $q \rightarrow p$ 두 가지를 증명하는 방법이다.</p>
</blockquote>

<h3 id="예시-4">예시</h3>
<blockquote>
  <p>$n$ 이 홀수이면 $n^2$ 은 홀수이다. ($p$ : $n$ 이 홀수이다. , $q$ : $n^2$ 은 홀수이다.)</p>
</blockquote>

<ul>
  <li>증명
    <ul>
      <li>$p \rightarrow q$ : $n$ 이 홀수이면 $n^2$ 은 홀수이다.
        <ul>
          <li>$n = 2k + 1$, $n^2 = 4k^2 + 4k + 1 = 2(2k^2 + 2k) + 1$ 이므로 $n^2$ 은 홀수이다.</li>
        </ul>
      </li>
      <li>$q \rightarrow p$ : $n^2$ 이 홀수이면 $n$ 은 홀수이다. (직접 증명이 어렵기 때문에 대우증명을 이용하여 증명)</li>
      <li>$\lnot q \rightarrow \lnot p$ : $n$ 이 짝수이면, $n^2$ 은 짝수이다.
        <ul>
          <li>$n = 2k$ 이면 $n^2 = 4k^2 = 2(2k^2)$ 이므로 $n^2$ 은 짝수이다.</li>
        </ul>
      </li>
      <li>$p \rightarrow q$ 는 직접증명법에 의해 참이고, $q \rightarrow p$ 는 대우증명법에 의해 참이므로<br />
  $\therefore q \leftrightarrow p$는  참이다.</li>
    </ul>
  </li>
</ul>

<h2 id="6존재-증명법-existence-proof">6.존재 증명법 (Existence Proof)</h2>
<blockquote>
  <p>$P(x)$ 라는 명제함수에서 $P(x)$ 가 참인 $x$ 가 적어도 하나가 존재한다는 것을 보이는 증명 방법이다.</p>
</blockquote>

<h3 id="예시-5">예시</h3>
<blockquote>
  <p>$x^2 + y^2 = z^2$ 인 정수 $x,y,z$ 가 존재함을 보여라</p>
</blockquote>

<ul>
  <li>증명
    <ul>
      <li>$x = 3, y = 4, z = 5$ 라고 할 때, $3^2 + 4^2 = 9 + 16 = 25 = 5^2$</li>
    </ul>
  </li>
</ul>

<hr />

<p><br />
<br /></p>

<h1 id="참조">참조</h1>
<p><a href="https://ko.wikipedia.org/wiki/%EC%A6%9D%EB%AA%85_(%EC%88%98%ED%95%99)">https://ko.wikipedia.org/wiki/%EC%A6%9D%EB%AA%85_(%EC%88%98%ED%95%99)</a><br />
<a href="http://bigdata.dongguk.ac.kr/lectures/disc_math/_book/%EC%A6%9D%EB%AA%85.html#%EC%A6%9D%EB%AA%85%EA%B4%80%EB%A0%A8-%EC%9A%A9%EC%96%B4">http://bigdata.dongguk.ac.kr/lectures/disc_math/_book/%EC%A6%9D%EB%AA%85.html#%EC%A6%9D%EB%AA%85%EA%B4%80%EB%A0%A8-%EC%9A%A9%EC%96%B4</a><br />
<a href="https://mathbang.net/121#gsc.tab=0">https://mathbang.net/121#gsc.tab=0</a>
<a href="https://ko.wikipedia.org/wiki/%EA%B3%B5%EB%A6%AC">https://ko.wikipedia.org/wiki/%EA%B3%B5%EB%A6%AC</a>
<a href="https://m.blog.naver.com/junhyuk7272/221961339600">https://m.blog.naver.com/junhyuk7272/221961339600</a></p>]]></content><author><name>지지형</name></author><category term="Discrete Mathematics" /><summary type="html"><![CDATA[증명(Proofs)이란? 특정한 공리(Axiom)들을 가정하고, 그 가정 하에서 어떤 명제가 참이라는 것을 보여주는 것이다.]]></summary></entry><entry><title type="html">[백준] 2231 : 분해합 (파이썬)</title><link href="http://localhost:4000/boj/BOJ-2231/" rel="alternate" type="text/html" title="[백준] 2231 : 분해합 (파이썬)" /><published>2023-10-19T00:00:00+09:00</published><updated>2023-10-19T00:00:00+09:00</updated><id>http://localhost:4000/boj/BOJ-2231</id><content type="html" xml:base="http://localhost:4000/boj/BOJ-2231/"><![CDATA[<h1 id="-난이도">🔎 난이도</h1>
<blockquote>
  <p>🟤 <strong>브론즈 2</strong></p>
</blockquote>

<h1 id="️-문제">✏️ 문제</h1>
<blockquote>
  <p><a href="https://www.acmicpc.net/problem/2231">https://www.acmicpc.net/problem/2231</a></p>
</blockquote>

<p><img src="/assets/images/Coding_test/Boj/BOJ_2231_1.png" />
<br /></p>

<h1 id="-예제-입력-및-출력">🤖 예제 입력 및 출력</h1>

<p><img src="/assets/images/Coding_test/Boj/BOJ_2231_2.png" /></p>

<p><br /></p>

<h1 id="-알고리즘-분류">📑 알고리즘 분류</h1>

<ul>
  <li>브루트포스 알고리즘</li>
</ul>

<p><br /></p>

<h1 id="-아이디어">🧐 아이디어</h1>
<blockquote>
  <p>이 문제의 핵심은 분해합과 생성자에 대한 이해, N의 가장 작은 생성자 출력! 이라고 할 수 있다.</p>
  <ul>
    <li>분해합 : 자연수 N과 N을 이루는 각 자리수의 합
      <ul>
        <li>N = 123, N을 이루는 각 자리수 1, 2, 3 의 합이다. (123 + 1 + 2 + 3)</li>
      </ul>
    </li>
    <li>생성자 : 자연수 M의 분해합이 N인 경우, M은 생성자이다.
      <ul>
        <li>M = 120, N = 123 M의 분해합은 (120 + 1 + 2 + 0) = 123 = N 이다.<br />
즉, 120은 123의 생성자이다.</li>
      </ul>
    </li>
    <li>어떠한 자연수의 생성자가 없을 수도 있고, 여러 개일 수도 있다.
      <ul>
        <li>출력 : 생성자가 없을 경우 <strong>0</strong> / 생성자가 여러 개일 경우 <strong>가장 작은 생성자</strong></li>
      </ul>
    </li>
  </ul>
</blockquote>

<blockquote>
  <p>문제에서 요구한 개념들을 이해한 후에는 각 자리수를 더하는 과정을 코드로 구현하는 것이 포인트라고 생각한다.</p>
</blockquote>

<p><br /></p>

<h1 id="-첫-풀이">📝 첫 풀이</h1>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># 입력
</span><span class="n">n</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">input</span><span class="p">())</span>

<span class="c1"># 생성자를 받을 리스트
</span><span class="n">ans_lst</span> <span class="o">=</span> <span class="p">[]</span>

<span class="c1"># 정답 비교용
</span><span class="n">num</span> <span class="o">=</span> <span class="n">n</span>

<span class="k">while</span> <span class="n">n</span><span class="p">:</span> <span class="c1"># n이 0이 될 때까지 반복
</span>
    <span class="n">lst</span> <span class="o">=</span> <span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="c1"># 각 자리수의 합을 위한 리스트
</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">str</span><span class="p">(</span><span class="n">n</span><span class="p">):</span> <span class="c1"># 각 자리 수 반복 
</span>        <span class="n">lst</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">i</span><span class="p">))</span> <span class="c1"># 리스트에 각 자리수 담기
</span>
    <span class="k">if</span> <span class="nb">sum</span><span class="p">(</span><span class="n">lst</span><span class="p">)</span> <span class="o">==</span> <span class="n">num</span><span class="p">:</span> <span class="c1"># 각 자리수의 합이 생성자일 경우 
</span>        <span class="n">ans_lst</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="c1"># 결과값(생성자)을 담을 리스트에 담기
</span>    
    <span class="n">n</span> <span class="o">-=</span> <span class="mi">1</span> <span class="c1"># n에서 1씩 줄여가며 반복
</span>

<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ans_lst</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span> <span class="c1"># 결과 리스트에 원소가 있을 경우 가장 작은 생성자 출력
</span>    <span class="k">print</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">ans_lst</span><span class="p">))</span>

<span class="k">else</span><span class="p">:</span> <span class="c1"># 원소가 들어있지않으면 0을 출력
</span>    <span class="k">print</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
</code></pre></div></div>
<p><br /></p>

<h1 id="-풀이-리뷰">😳 풀이 리뷰</h1>
<p>물론 정답이 인정된 코드지만, 다시봐도 복잡하고 가독성이 떨어진다…<br />
while문을 통해 자연수 N을 하나씩 줄여가며 각 자리수를 더하고 num과 같은 지 비교하였다.<br />
while문을 빠져 나온 후 정답리스트에 원소가 있을 경우 min을 통해 가장 작은 숫자를 출력하고, 원소가 없을 경우 생성자가 없기 때문에 0을 출력하게 하였다.<br />
문제에서는 가장 작은 생성자를 출력하거나 없을 경우 0을 출력하는 것이다. 위 코드에서는 가장 큰 숫자인 N에서 1씩 빼며 반복하기에 가장 큰 생성자가 먼저 담기는 문제가 생겼다.</p>

<p><br /></p>

<h1 id="-두-번째-풀이">📝 두 번째 풀이</h1>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># 입력
</span><span class="n">n</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">input</span><span class="p">())</span> 

<span class="c1"># 결과를 담을 변수
</span><span class="n">ans</span> <span class="o">=</span> <span class="mi">0</span>

<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span> <span class="c1"># 1 ~ n 까지
</span>    <span class="n">num</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="nb">sum</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)))</span> <span class="c1"># i의 분해합
</span>
    <span class="k">if</span> <span class="n">num</span> <span class="o">==</span> <span class="n">n</span><span class="p">:</span> <span class="c1"># 생성자의 분해합과 N이 같을 경우
</span>        <span class="n">ans</span> <span class="o">=</span> <span class="n">i</span> <span class="c1"># 결과에 생성자 i를 담고 반복문 종료!
</span>        <span class="k">break</span>

<span class="c1"># for문을 1부터 n까지 돌며 생성자를 찾게되면 가장 작은 생성자를 찾게 된다.
# 만약 n까지 돌고 나서 생성자가 없을 경우 결과는 그래로 0을 출력하게 된다.
</span>
<span class="c1"># 결과 출력
</span><span class="k">print</span><span class="p">(</span><span class="n">ans</span><span class="p">)</span>
</code></pre></div></div>

<h1 id="-풀이-리뷰-1">😳 풀이 리뷰</h1>

<p>첫 번째 풀이 이후, 문제가 요구하는 사항에 맞춰 코드를 개선하였다.<br />
각 자리수의 합을 구할 때 리스트를 만들고 append시키며 복잡헀던 것이 map, sum을 통해 간략화 했다.<br />
이후 1 ~ N까지 반복문을 돌며 생성자를 생성하고 분해합과 같을 때 반복문을 탈출하도록 하였다.</p>]]></content><author><name>지지형</name></author><category term="BOJ" /><summary type="html"><![CDATA[🔎 난이도 🟤 브론즈 2]]></summary></entry><entry><title type="html">[백준] 1065 : 한수 (파이썬)</title><link href="http://localhost:4000/boj/BOJ-1065/" rel="alternate" type="text/html" title="[백준] 1065 : 한수 (파이썬)" /><published>2023-10-17T00:00:00+09:00</published><updated>2023-10-18T00:00:00+09:00</updated><id>http://localhost:4000/boj/BOJ-1065</id><content type="html" xml:base="http://localhost:4000/boj/BOJ-1065/"><![CDATA[<h1 id="-난이도">🔎 난이도</h1>
<blockquote>
  <p>⚪️ <strong>실버 4</strong></p>
</blockquote>

<h1 id="️-문제">✏️ 문제</h1>
<blockquote>
  <p><a href="https://www.acmicpc.net/problem/1065">https://www.acmicpc.net/problem/1065</a></p>
</blockquote>

<p><img src="/assets/images/Coding_test/Boj/BOJ_1065_1.png" />
<br /></p>

<h1 id="-예제-입력-및-출력">🤖 예제 입력 및 출력</h1>

<p><img src="/assets/images/Coding_test/Boj/BOJ_1065_2.png" /></p>

<p><br /></p>

<h1 id="-알고리즘-분류">📑 알고리즘 분류</h1>

<ul>
  <li>수학</li>
  <li>브루트포스 알고리즘</li>
</ul>

<p><br /></p>

<h1 id="-아이디어">🧐 아이디어</h1>

<blockquote>
  <p>문제에서 정의한 한수의 뜻을 이해하는데 많은 시간이 걸렸다.<br />
문제의 포인트는 이 두가지를 잘 파악하는데 있다고 생각한다.</p>
</blockquote>

<h2 id="1-한수의-정의">1. 한수의 정의</h2>

<blockquote>
  <p>어떤 양의 정수 X의 <strong>각 자리</strong>가 등차수열을 이루면 그 수를 <strong>한수</strong>라고 한다.</p>
  <ul>
    <li>등차 수열은 연속된 두 개의 수의 차이가 일정한 수열이다.
      <ul>
        <li><a href="https://wlgudths.github.io/">이산수학 파트에서 업로드 예정</a></li>
      </ul>
    </li>
  </ul>
</blockquote>

<h3 id="예시">예시</h3>
<blockquote>
  <p>이 문제는 N의 범위가 정해져있다. (1 &lt;= N &lt;= 1000)<br />
일, 십, 백, 천 각 자리수마다 한수의 유무를 다음과 같이 파악할 수 있다.</p>
</blockquote>

<ol>
  <li>N이 일의 자리일 경우 공차가 0인 등차수열이므로 모든 일의 자리의 자연수는 한수이다.
    <ul>
      <li>N = 2, 수열 S = {2}</li>
    </ul>
  </li>
  <li>N이 십의자리 수일 경우 연속된 두 수의 차이(공차)가 존재하므로 모든 십의 자리의 자연수도 한수이다.
    <ul>
      <li>N = 24, 수열 S = {2, 4} (공차가 2인 수열)</li>
    </ul>
  </li>
  <li>N이 백의 자리일 경우 연속된 두 수는 다음과 나타낼 수 있다.
    <ul>
      <li>N = 135, <u>13</u> 5 , 1 <u>35</u><br />
 135의 연속된 두 수는 1 , 3 과 3 , 5이다. 이 두 수의 공차가 같을 경우 135 는 한수이다.<br />
 1 - 3 = 3 - 5 = -2 로 같으므로 한수이다.</li>
    </ul>
  </li>
  <li>N이 1000인 경우
    <ul>
      <li>N = 1000, <u>10</u> 00, 1 <u>00</u> 0, 10 <u>00</u> 와 같이 연속된 두 수들로 나타낼 수 있다.<br />
 3번 경우와 같이 공차를 구하면 1, 0, 0 같지 않으므로 한수가 아니다.</li>
    </ul>
  </li>
</ol>

<h2 id="2-한수의-개수">2. <strong>한수</strong>의 <strong>개수</strong></h2>
<blockquote>
  <p>문제의 정답은 한수의 유무를 파악하는 것이 아닌 <u>한수의 개수</u>를 구하는 것이다.<br />
양의 정수 N이 주어질 경우 1부터 N까지 각각의 숫자의 한수 유무를 파악하여 한수의 개수를 출력해주면 된다.</p>
</blockquote>

<p><br />
<br /></p>

<h1 id="-내-풀이">📝 내 풀이</h1>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># 백준 1065 한수
</span>
<span class="c1"># 100의 자리 한수 판별 함수
</span><span class="k">def</span> <span class="nf">hansu</span> <span class="p">(</span><span class="n">n</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">&gt;=</span> <span class="mi">1000</span><span class="p">:</span> <span class="c1"># 천의 자리숫자가 들어올 경우 False 반환
</span>        <span class="k">return</span> <span class="bp">False</span>
    
    <span class="n">temp</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">n</span><span class="p">)))</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">temp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">temp</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">temp</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">temp</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
    
    <span class="c1"># 한수일 경우 True 반환 / 아닐 경우 False 반환
</span>    <span class="k">if</span> <span class="n">a</span> <span class="o">==</span> <span class="n">b</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">True</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">False</span>

<span class="c1"># 입력
</span><span class="n">n</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">input</span><span class="p">())</span>

<span class="c1"># 출력 / 한수 개수 카운트
</span><span class="n">cnt</span> <span class="o">=</span> <span class="mi">0</span>


<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span> <span class="c1"># 1 ~ N 까지 반복
</span>    <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">100</span><span class="p">:</span> <span class="c1"># 100보다 작을 경우
</span>        <span class="n">cnt</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">else</span><span class="p">:</span> <span class="c1"># 100과 같거나 큰 경우
</span>        <span class="k">if</span> <span class="n">hansu</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">==</span> <span class="bp">True</span><span class="p">:</span> <span class="c1"># 한수 판별이 True 일 경우 카운트
</span>            <span class="n">cnt</span> <span class="o">+=</span> <span class="mi">1</span>

<span class="k">print</span><span class="p">(</span><span class="n">cnt</span><span class="p">)</span>
</code></pre></div></div>
<p><br /></p>

<h1 id="-다른-사람-풀이">😳 다른 사람 풀이</h1>

<p>출처 : <a href="https://roseline124.github.io/algorithm/2019/03/29/Algorithem-baekjoon-1065.html">https://roseline124.github.io/algorithm/2019/03/29/Algorithem-baekjoon-1065.html</a></p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">num</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">input</span><span class="p">())</span>
<span class="n">hansu</span> <span class="o">=</span> <span class="mi">0</span>

<span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">num</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="p">:</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;=</span> <span class="mi">99</span> <span class="p">:</span> <span class="c1"># 1부터 99까지는 모두 한수
</span>        <span class="n">hansu</span> <span class="o">+=</span> <span class="mi">1</span> 
    
    <span class="k">else</span> <span class="p">:</span>     
        <span class="n">nums</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">n</span><span class="p">)))</span> <span class="c1"># 숫자를 자릿수대로 분리 
</span>        <span class="k">if</span> <span class="n">nums</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">nums</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">nums</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">nums</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="p">:</span> <span class="c1">#등차수열 확인
</span>            <span class="n">hansu</span><span class="o">+=</span><span class="mi">1</span>
</code></pre></div></div>

<blockquote>
  <p>내 풀이와 비교하면 더욱 간결하고 깔끔한 코드로 나타냈다.<br />
오히려 함수를 정의해서 깔끔하게 구현하겠다는 나의 생각을 깨버렸다 ☹️.</p>
</blockquote>]]></content><author><name>지지형</name></author><category term="BOJ" /><summary type="html"><![CDATA[🔎 난이도 ⚪️ 실버 4]]></summary></entry><entry><title type="html">[백준] 1543 : 문서검색 (파이썬)</title><link href="http://localhost:4000/boj/BOJ-1543/" rel="alternate" type="text/html" title="[백준] 1543 : 문서검색 (파이썬)" /><published>2023-10-16T00:00:00+09:00</published><updated>2023-10-16T00:00:00+09:00</updated><id>http://localhost:4000/boj/BOJ-1543</id><content type="html" xml:base="http://localhost:4000/boj/BOJ-1543/"><![CDATA[<h1 id="-난이도">🔎 난이도</h1>
<blockquote>
  <p>⚪️ <strong>실버 5</strong></p>
</blockquote>

<h1 id="️-문제">✏️ 문제</h1>
<blockquote>
  <p><a href="https://www.acmicpc.net/problem/1543">https://www.acmicpc.net/problem/1543</a></p>
</blockquote>

<p><img src="/assets/images/Coding_test/Boj/BOJ_1543_1.png" />
<br /></p>

<h1 id="-예제-입력-및-출력">🤖 예제 입력 및 출력</h1>

<p><img src="/assets/images/Coding_test/Boj/BOJ_1543_2.png" /></p>

<p><br /></p>

<h1 id="-알고리즘-분류">📑 알고리즘 분류</h1>

<ul>
  <li>문자열</li>
  <li>브루트포스 알고리즘</li>
</ul>

<p><br /></p>

<h1 id="-아이디어">🧐 아이디어</h1>

<blockquote>
  <p>문제를 읽자마자 <strong>replace</strong> 함수가 딱 떠올랐다.</p>
</blockquote>

<p><br /></p>

<h1 id="-내-풀이">📝 내 풀이</h1>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># 입력
</span><span class="n">words</span> <span class="o">=</span> <span class="nb">input</span><span class="p">()</span> <span class="c1"># 문서
</span><span class="n">word</span> <span class="o">=</span> <span class="nb">input</span><span class="p">()</span> <span class="c1"># 검색하고 싶은 단어
</span>
<span class="n">change</span> <span class="o">=</span> <span class="n">words</span><span class="p">.</span><span class="n">replace</span><span class="p">(</span><span class="n">word</span><span class="p">,</span> <span class="s">'*'</span><span class="p">)</span> <span class="c1"># 중복되지 않게 단어 &gt; "*" 변환
</span>
<span class="c1"># 출력
</span><span class="k">print</span><span class="p">(</span><span class="n">change</span><span class="p">.</span><span class="n">count</span><span class="p">(</span><span class="s">'*'</span><span class="p">))</span>
</code></pre></div></div>
<p><br /></p>]]></content><author><name>지지형</name></author><category term="BOJ" /><summary type="html"><![CDATA[🔎 난이도 ⚪️ 실버 5]]></summary></entry><entry><title type="html">[이산수학] 논리와 명제 (Logic &amp;amp; Proposition)</title><link href="http://localhost:4000/discrete%20mathematics/DM-03/" rel="alternate" type="text/html" title="[이산수학] 논리와 명제 (Logic &amp;amp; Proposition)" /><published>2023-10-16T00:00:00+09:00</published><updated>2023-10-19T00:00:00+09:00</updated><id>http://localhost:4000/discrete%20mathematics/DM-03</id><content type="html" xml:base="http://localhost:4000/discrete%20mathematics/DM-03/"><![CDATA[<h1 id="명제-proposition">명제 (Proposition)</h1>
<blockquote>
  <p>논리학적으로 뜻이 분명한 문장을 말한다.</p>
</blockquote>

<ul>
  <li>즉, <strong>참(True)</strong> 혹은 <strong>거짓(False)</strong> 으로 구분할 수 있는 문장이나 수식이다.</li>
  <li>명제는 통상 영문 소문자 $p$, $q$, $r$, $\cdots$ 등으로 표기</li>
</ul>

<h2 id="명제-예시">명제 예시</h2>
<ol>
  <li>손흥민이 태어난 년도는 2000년이다.
    <ul>
      <li>손흥민이 태어난 년도는 1992년이므로 거짓인 명제이다.</li>
    </ul>
  </li>
  <li>1 + 2 = 3
    <ul>
      <li>산수에 원리에 따라 객관적으로 참, 거짓을 판달할 수 있으므로 명제이며 참이다.</li>
    </ul>
  </li>
  <li>커피는 달달하다.
    <ul>
      <li>참 또는 거짓을 판단할 수 없으므로 명제가 아니다.</li>
    </ul>
  </li>
</ol>

<h2 id="진리값-truth-value">진리값 (Truth value)</h2>
<blockquote>
  <p>참, 거짓을 가르키는 값을 진리값(truth value)라고 한다.</p>
</blockquote>

<ul>
  <li>프로그래밍 언어에서는 조건이 참인지 거짓인지 표현하는 논리 연산에 사용한다.<br />
참 $\rightarrow$ 1, 거짓 $\rightarrow$ 0</li>
</ul>

<h2 id="진리표-truth-table">진리표 (Truth table)</h2>
<blockquote>
  <p>모든 명제 및 그 조합에 대한 입출력 결과를 기록한 표</p>
</blockquote>

<table>
  <thead>
    <tr>
      <th style="text-align: left">명제 $P$</th>
      <th style="text-align: center">명제 $Q$</th>
      <th style="text-align: right">$P$ $\land$ $Q$</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left">참</td>
      <td style="text-align: center">참</td>
      <td style="text-align: right">참</td>
    </tr>
    <tr>
      <td style="text-align: left">참</td>
      <td style="text-align: center">거짓</td>
      <td style="text-align: right">거짓</td>
    </tr>
    <tr>
      <td style="text-align: left">거짓</td>
      <td style="text-align: center">참</td>
      <td style="text-align: right">거짓</td>
    </tr>
    <tr>
      <td style="text-align: left">거짓</td>
      <td style="text-align: center">거짓</td>
      <td style="text-align: right">거짓</td>
    </tr>
  </tbody>
</table>

<h2 id="명제함수">명제함수</h2>
<blockquote>
  <p>명제변수 $x$ 를 포함하여 진리값을 판별할 수 있는 문장이나 수식</p>
</blockquote>

<h3 id="명제함수-예시">명제함수 예시</h3>
<blockquote>
  <p>$P(x)$ = $x$ &gt; 2  이라는 명제 함수라고 하면 명제변수 $x$의 값에 따라 $P(x)$ 의 진리값을 판별할 수 있다.</p>
</blockquote>

<ul>
  <li>변수에 특정 값을 할당하는 방법
    <ul>
      <li>$x$ = 3이라면 $P(x)$는 참인 명제가 되고, $x$ = 1이라면 $P(x)$는 거짓인 명제가 된다.</li>
    </ul>
  </li>
  <li>변수의 범위를 제한하는 방법
    <ul>
      <li>$x$ $\ge$ 3이라면, $P(x)$는 참이 된다.</li>
    </ul>
  </li>
</ul>

<h3 id="한정자">한정자</h3>
<blockquote>
  <p>명제함수에서 변수의 범위를 제한하는 연산자이다.</p>
</blockquote>

<h4 id="전체한정자-universal-quantifier">전체한정자 (Universal Quantifier)</h4>
<blockquote>
  <p>모든 것에 대하여 <strong>(for all)</strong></p>
</blockquote>

<ul>
  <li>$\forall xP(x)$ : 모든 $x$에 대하여 $P(x)$
    <ul>
      <li>모든 $x$에 대하여 참일 경우 참인 명제이다.</li>
    </ul>
  </li>
  <li>기호
    <ul>
      <li>$\forall$</li>
    </ul>
  </li>
</ul>

<h4 id="존재한정자-existential-quantifier">존재한정자 (existential quantifier)</h4>
<blockquote>
  <p>존재한다 <strong>(there exist)</strong></p>
</blockquote>

<ul>
  <li>$\exists xP(x)$ : 어떤 $x$에 대하여 $P(x)$
    <ul>
      <li>참이되는 $x$가 하나라도 있을 경우 참인 명제이다.</li>
    </ul>
  </li>
  <li>기호
    <ul>
      <li>$\exists$</li>
    </ul>
  </li>
</ul>

<h2 id="논리연산자logical-operator">논리연산자(logical operator)</h2>
<blockquote>
  <p>여러 명제를 결합할 때 사용</p>
</blockquote>

<h3 id="종류">종류</h3>
<h4 id="1-부정-negation">1. 부정 (Negation)</h4>
<blockquote>
  <p>명제 $p$에 대하여 $p$의 진리값을 반대로 갖는 명제</p>
</blockquote>

<ul>
  <li>언어
    <ul>
      <li>$not$</li>
    </ul>
  </li>
  <li>기호
    <ul>
      <li>$\lnot$</li>
      <li>$\sim$</li>
    </ul>
  </li>
  <li>
    <p>진리표 (truth table)</p>

    <table>
      <thead>
        <tr>
          <th style="text-align: center">$p$</th>
          <th style="text-align: center">$\lnot p$</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td style="text-align: center">T</td>
          <td style="text-align: center">F</td>
        </tr>
        <tr>
          <td style="text-align: center">F</td>
          <td style="text-align: center">T</td>
        </tr>
      </tbody>
    </table>
  </li>
</ul>

<h4 id="2-논리곱-conjunction">2. 논리곱 (Conjunction)</h4>
<blockquote>
  <p>명제 $p$, $q$에 대하여 $p$와 $q$가 모두 참일 경우에만 참, 반대일 경우 거짓이 되는 명제</p>
</blockquote>

<ul>
  <li>언어
    <ul>
      <li>$and$</li>
    </ul>
  </li>
  <li>기호
    <ul>
      <li>$\land$</li>
    </ul>
  </li>
  <li>
    <p>진리표 (truth table)</p>

    <table>
      <thead>
        <tr>
          <th style="text-align: center">$p$</th>
          <th style="text-align: center">$q$</th>
          <th style="text-align: center">$p$ $\land$ $p$</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td style="text-align: center">T</td>
          <td style="text-align: center">T</td>
          <td style="text-align: center">T</td>
        </tr>
        <tr>
          <td style="text-align: center">T</td>
          <td style="text-align: center">F</td>
          <td style="text-align: center">F</td>
        </tr>
        <tr>
          <td style="text-align: center">F</td>
          <td style="text-align: center">T</td>
          <td style="text-align: center">F</td>
        </tr>
        <tr>
          <td style="text-align: center">F</td>
          <td style="text-align: center">F</td>
          <td style="text-align: center">T</td>
        </tr>
      </tbody>
    </table>
  </li>
</ul>

<h4 id="3-논리합-disjunction">3. 논리합 (Disjunction)</h4>
<blockquote>
  <p>명제 $p$, $q$에 대하여 $p$와 $q$가 모두 거짓일 경우에만 거짓, 그렇지 않을 경우 참이 되는 명제</p>
</blockquote>

<ul>
  <li>언어
    <ul>
      <li>$or$</li>
    </ul>
  </li>
  <li>기호
    <ul>
      <li>$\lor$</li>
    </ul>
  </li>
  <li>
    <p>진리표 (truth table)</p>

    <table>
      <thead>
        <tr>
          <th style="text-align: center">$p$</th>
          <th style="text-align: center">$q$</th>
          <th style="text-align: center">$p$ $\lor$ $p$</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td style="text-align: center">T</td>
          <td style="text-align: center">T</td>
          <td style="text-align: center">T</td>
        </tr>
        <tr>
          <td style="text-align: center">T</td>
          <td style="text-align: center">F</td>
          <td style="text-align: center">T</td>
        </tr>
        <tr>
          <td style="text-align: center">F</td>
          <td style="text-align: center">T</td>
          <td style="text-align: center">T</td>
        </tr>
        <tr>
          <td style="text-align: center">F</td>
          <td style="text-align: center">F</td>
          <td style="text-align: center">F</td>
        </tr>
      </tbody>
    </table>
  </li>
</ul>

<h4 id="4-배타적-논리합-exclusive-or">4. 배타적 논리합 (Exclusive OR)</h4>
<blockquote>
  <p>명제 $p$, $q$에 대하여 $p$와 $q$ 중 하나만 참일 때 참이되고, 그렇지 않으면 거짓이 되는 명제</p>
</blockquote>

<ul>
  <li>언어
    <ul>
      <li>$X OR$</li>
    </ul>
  </li>
  <li>기호
    <ul>
      <li>$\oplus$</li>
      <li>$\sim$</li>
    </ul>
  </li>
  <li>
    <p>진리표 (truth table)</p>

    <table>
      <thead>
        <tr>
          <th style="text-align: center">$p$</th>
          <th style="text-align: center">$q$</th>
          <th style="text-align: center">$p$ $\oplus$ $p$</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td style="text-align: center">T</td>
          <td style="text-align: center">T</td>
          <td style="text-align: center">F</td>
        </tr>
        <tr>
          <td style="text-align: center">T</td>
          <td style="text-align: center">F</td>
          <td style="text-align: center">T</td>
        </tr>
        <tr>
          <td style="text-align: center">F</td>
          <td style="text-align: center">T</td>
          <td style="text-align: center">T</td>
        </tr>
        <tr>
          <td style="text-align: center">F</td>
          <td style="text-align: center">F</td>
          <td style="text-align: center">F</td>
        </tr>
      </tbody>
    </table>
  </li>
</ul>

<hr />

<h3 id="조건명제-conditional-proposition">조건명제 (Conditional Proposition)</h3>

<blockquote>
  <p>$p \rightarrow q$</p>
  <ul>
    <li>$p$이면 $q$이다. ( $if$  $p$  $then$   $q$ )</li>
    <li>$p$를 가설(hypothesis), 전제(premise) $q$를 결론(conclusion), 결과(consequence)</li>
  </ul>
</blockquote>

<h4 id="조건-명제-진리표">조건 명제 진리표</h4>

<table>
  <thead>
    <tr>
      <th style="text-align: center">$p$</th>
      <th style="text-align: center">$q$</th>
      <th style="text-align: center">$p \rightarrow q$</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">T</td>
      <td style="text-align: center">T</td>
      <td style="text-align: center">T</td>
    </tr>
    <tr>
      <td style="text-align: center">T</td>
      <td style="text-align: center">F</td>
      <td style="text-align: center">F</td>
    </tr>
    <tr>
      <td style="text-align: center">F</td>
      <td style="text-align: center">T</td>
      <td style="text-align: center">T</td>
    </tr>
    <tr>
      <td style="text-align: center">F</td>
      <td style="text-align: center">F</td>
      <td style="text-align: center">T</td>
    </tr>
  </tbody>
</table>

<hr />

<h4 id="역-converse">역 (converse)</h4>
<blockquote>
  <p>$p \rightarrow q$ 에 대하여 $q \rightarrow p$ 가설과 결론이 바뀐 것이다.</p>
</blockquote>

<h4 id="이-inverse">이 (inverse)</h4>
<blockquote>
  <p>$p \rightarrow q$ 에 대하여 $\lnot p \rightarrow \lnot q$ 가설과 결론을 각각 부정한 것이다.</p>
</blockquote>

<h4 id="대우-contrapositive">대우 (contrapositive)</h4>
<blockquote>
  <p>$p \rightarrow q$ 에 대하여 $\lnot q \rightarrow \lnot p$ 가설과 결론이 바뀐 동시에 부정한 것이다.</p>
</blockquote>

<h4 id="역-이-대우-진리표">역, 이, 대우 진리표</h4>

<table>
  <thead>
    <tr>
      <th style="text-align: center">$p$</th>
      <th style="text-align: center">$q$</th>
      <th style="text-align: center">$p \rightarrow q$</th>
      <th style="text-align: center">$q \rightarrow p$</th>
      <th style="text-align: center">$\lnot p \rightarrow \lnot q$</th>
      <th style="text-align: center">$\lnot q \rightarrow \lnot p$</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">T</td>
      <td style="text-align: center">T</td>
      <td style="text-align: center">T</td>
      <td style="text-align: center">T</td>
      <td style="text-align: center">T</td>
      <td style="text-align: center">T</td>
    </tr>
    <tr>
      <td style="text-align: center">T</td>
      <td style="text-align: center">F</td>
      <td style="text-align: center">F</td>
      <td style="text-align: center">T</td>
      <td style="text-align: center">T</td>
      <td style="text-align: center">F</td>
    </tr>
    <tr>
      <td style="text-align: center">F</td>
      <td style="text-align: center">T</td>
      <td style="text-align: center">T</td>
      <td style="text-align: center">F</td>
      <td style="text-align: center">F</td>
      <td style="text-align: center">T</td>
    </tr>
    <tr>
      <td style="text-align: center">F</td>
      <td style="text-align: center">F</td>
      <td style="text-align: center">T</td>
      <td style="text-align: center">T</td>
      <td style="text-align: center">T</td>
      <td style="text-align: center">T</td>
    </tr>
  </tbody>
</table>

<hr />
<p><br /></p>

<h1 id="참조">참조</h1>
<p><a href="https://ko.wikipedia.org/wiki/%EB%AA%85%EC%A0%9C">https://ko.wikipedia.org/wiki/%EB%AA%85%EC%A0%9C</a><br />
<a href="https://ko.wikipedia.org/wiki/%EC%A7%84%EB%A6%BF%EA%B0%92">https://ko.wikipedia.org/wiki/%EC%A7%84%EB%A6%BF%EA%B0%92</a><br />
<a href="http://bigdata.dongguk.ac.kr/lectures/disc_math/_book/%EB%85%BC%EB%A6%AC%EC%99%80-%EB%AA%85%EC%A0%9C-logic-propositions.html">http://bigdata.dongguk.ac.kr/lectures/disc_math/_book/%EB%85%BC%EB%A6%AC%EC%99%80-%EB%AA%85%EC%A0%9C-logic-propositions.html</a><br />
<a href="https://ko.wikipedia.org/wiki/%EC%A7%84%EB%A6%AC%ED%91%9C">https://ko.wikipedia.org/wiki/%EC%A7%84%EB%A6%AC%ED%91%9C</a></p>]]></content><author><name>지지형</name></author><category term="Discrete Mathematics" /><summary type="html"><![CDATA[명제 (Proposition) 논리학적으로 뜻이 분명한 문장을 말한다.]]></summary></entry></feed>