<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.9.3">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2024-03-30T18:12:49+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">느려도 괜찮아</title><author><name>지지형</name></author><entry><title type="html">[이산수학] 부울대수(Boolean algebra) : 03. 논리 게이트</title><link href="http://localhost:4000/discrete%20mathematics/DM-31/" rel="alternate" type="text/html" title="[이산수학] 부울대수(Boolean algebra) : 03. 논리 게이트" /><published>2024-02-21T00:00:00+09:00</published><updated>2024-02-21T00:00:00+09:00</updated><id>http://localhost:4000/discrete%20mathematics/DM-31</id><content type="html" xml:base="http://localhost:4000/discrete%20mathematics/DM-31/"><![CDATA[<h1 id="논리-게이트">논리 게이트</h1>

<p>건물을 짓기 위해 설계도가 필요하듯이, 디지털 회로를 만들기 위해서는 정확한 연산 과정을 표현하는 논리회로가 필요하다.</p>

<blockquote>
  <p>연산 과정은 이전 장에서 배운 부울함수를 이용해 정의하며 이를 논리회로로 표현할 때 논리 게이트를 이용한다.</p>
</blockquote>

<h2 id="용어-정리">용어 정리</h2>

<ol>
  <li>
    <p>게이트 (Gate) : 정보 흐름의 허용 및 저지를 결정하는 단자 또는 소자</p>
  </li>
  <li>
    <p>논리 소자 (Logic Element) : 다수의 입력 논리값들로부터 새로운 논리 결과 값을 결정하는 소자</p>
  </li>
</ol>

<h2 id="정의--논리-게이트-logic-gate">정의 : 논리 게이트 (logic gate)</h2>

<blockquote>
  <p>부울대수를 물리적 장치로 구현한 것</p>
</blockquote>

<h3 id="not-게이트">NOT 게이트</h3>

<blockquote>
  <p>하나의 입력을 받아 부울보수 연산 후 하나의 출력을 낸다.</p>
</blockquote>

<p><img src="/assets/images/Math/dm/dm_example_31_01.png" /></p>

<p><br /></p>

<h3 id="and-게이트">AND 게이트</h3>

<blockquote>
  <p>두 개의 입력을 받아 부울곱 연산 후 하나의 출력을 낸다.</p>
</blockquote>

<p><img src="/assets/images/Math/dm/dm_example_31_02.png" /></p>

<p><br /></p>

<h3 id="or-게이트">OR 게이트</h3>

<blockquote>
  <p>두 개의 입력을 받아 부울합 연산 후 하나의 출력을 낸다.</p>
</blockquote>

<p><img src="/assets/images/Math/dm/dm_example_31_03.png" /></p>

<p><br /></p>

<h3 id="nand-게이트">NAND 게이트</h3>

<blockquote>
  <p>AND 게이트와 NOT 게이트를 결합한 논리소자이다.</p>
</blockquote>

<blockquote>
  <p>두 개의 입력을 받아 부울곱 연산 후 부울보수한 결과를 출력한다.</p>
</blockquote>

<p><img src="/assets/images/Math/dm/dm_example_31_04.png" /></p>

<p><br /></p>

<h3 id="nor-게이트">NOR 게이트</h3>

<blockquote>
  <p>OR 게이트와 NOT 게이트를 결합한 논리소자이다.</p>
</blockquote>

<blockquote>
  <p>두 개의 입력을 받아 부울합 연산 후 부울보수한 결과를 출력한다.</p>
</blockquote>

<p><img src="/assets/images/Math/dm/dm_example_31_05.png" /></p>

<p><br /></p>

<h3 id="xor-게이트">XOR 게이트</h3>

<blockquote>
  <p>eXclusive OR 연산자 $\oplus$ 에 대한 논리소자이다.</p>
</blockquote>

<blockquote>
  <p>XOR은 다음과 같은 연산식을 표현하는 연산자이다.</p>
</blockquote>

<ul>
  <li>$X \oplus Y = X’Y + XY’$</li>
</ul>

<blockquote>
  <p>두 개의 같은 값을 입력하면 <strong>0</strong> 을, 다른 값을 입력하면 <strong>1</strong> 을 출력한다.</p>
</blockquote>

<p><img src="/assets/images/Math/dm/dm_example_31_06.png" /></p>

<p><br /></p>

<h3 id="xnor-게이트">XNOR 게이트</h3>

<blockquote>
  <p>XOR 게이트와 NOT 게이트를 결합한 논리소자이다.</p>
</blockquote>

<blockquote>
  <p>두 개의 입력을 받아 XOR 연산 후 부울보수한 결과를 출력한다.</p>
</blockquote>

<p>$X \odot Y = (X \odot Y)’ = (X’Y + XY’)’$<br />
<br /></p>

<p>$\quad \quad \quad = (X’Y)’ \cdot (XY’)’\quad \ $ ($\because$ 드 모르간의 법칙)<br />
<br /></p>

<p>$\quad \quad \quad = (X + Y’)(X’ + Y)$ ($\because$ 드 모르간의 법칙)<br />
<br /></p>

<p>$\quad \quad \quad = XX’ + XY + X’Y’ + Y’Y$ ($\because$ 분배법칙)<br />
<br /></p>

<p>$\quad \quad \quad = 0 + XY + X’Y’ + 0$ ($\because$ 보수법칙)<br />
<br /></p>

<p>$\quad \quad \quad = XY + X’Y’$ ($\because$ 항등법칙)</p>

<p><img src="/assets/images/Math/dm/dm_example_31_07.png" /></p>

<p><br /></p>

<h3 id="예시">예시</h3>

<ul>
  <li>부울함수 $f(x, y) = (x + \bar{y})(\bar{x} + y)$ 를 논리회로로 나타내보자.</li>
</ul>

<ol>
  <li>
    <p>괄호 안에 있는 각 변수 $x, y$에 대한 부울보수 연산을 게이트로 표시한다.</p>

    <p><img src="/assets/images/Math/dm/dm_example_31_08.png" width="500" /></p>

    <p><br /></p>
  </li>
  <li>
    <p>괄호 안의 각 리터럴들의 부울합 연산에 대한 게이트를 표시한다.<br />
각 부울변수 $x, y$에 대한 리터럴의 입력선은 다음 그림과 같이 점을 이용해 연결선으로 표시할 수 있다.</p>

    <p><img src="/assets/images/Math/dm/dm_example_31_09.png" width="600" /></p>

    <p><br /></p>
  </li>
  <li>
    <p>부울합으로 연산한 두 최대항의 부울곱 연산에 대한 게이트를 표시하고 출력 $f$ 로 마무리한다.</p>

    <p><img src="/assets/images/Math/dm/dm_example_31_10.png" width="700" /></p>

    <p><br /></p>
  </li>
</ol>

<ul>
  <li>
    <p>부울함수 $f(x, y) = (x + \bar{y})(\bar{x} + y)$ 를 부울대수법칙을 이용해 DNF로 표현한 뒤 논리회로로 나타내보자.</p>

    <ul>
      <li>$f(x, y) = (x + \bar{y})(\bar{x} + y)$<br />
  $\qquad \quad = x\bar{x} + \bar{y}\bar{x} + xy + \bar{y}y \quad$ ($\because$ 분배법칙)<br />
  $\qquad \quad = \ 0 + \bar{y}\bar{x} + xy + 0\  \quad \ \ $ ($\because$ 보수법칙)<br />
  $\qquad \quad = \bar{y}\bar{x} + xy \qquad \qquad \quad \ $ ($\because$ 항등법칙)<br />
  $\qquad \quad = \bar{x}\bar{y} + xy \qquad \qquad \quad \ $ ($\because$ 교환법칙)</li>
    </ul>

    <p><img src="/assets/images/Math/dm/dm_example_31_11.png" width="700" /></p>

    <p><br /></p>
  </li>
  <li>
    <p>또한 $f(x, y) = \bar{x}\bar{y} + xy = x \odot y$ 이므로 다음과 같이 나타낼 수도 있다.</p>

    <p><img src="/assets/images/Math/dm/dm_example_31_12.png" width="500" /></p>
  </li>
</ul>

<p><br /></p>]]></content><author><name>지지형</name></author><category term="Discrete Mathematics" /><summary type="html"><![CDATA[논리 게이트]]></summary></entry><entry><title type="html">[이산수학] 부울대수(Boolean algebra) : 02. 부울함수의 표현</title><link href="http://localhost:4000/discrete%20mathematics/DM-30/" rel="alternate" type="text/html" title="[이산수학] 부울대수(Boolean algebra) : 02. 부울함수의 표현" /><published>2024-02-20T00:00:00+09:00</published><updated>2024-02-20T00:00:00+09:00</updated><id>http://localhost:4000/discrete%20mathematics/DM-30</id><content type="html" xml:base="http://localhost:4000/discrete%20mathematics/DM-30/"><![CDATA[<h1 id="부울함수의-표현">부울함수의 표현</h1>

<p>부울함수는 $n$ 개의 부울변수와 부울 연산자로 구성되어있다.</p>

<p>부울변수에 $2$ 진의 값 $0$ 또는 $1$ 이 입력되고 출력되는 식이다.</p>

<blockquote>
  <p>부울함수는 디지털 논리회로를 수식적으로 표현하여 논리회로를 설계하는 데 활용된다.</p>
</blockquote>

<ul>
  <li>이 부울함수를 최소항 또는 최대항으로 구성된 정규식으로 표준화하면 설계의 활용도를 더욱 높일 수 있다.</li>
</ul>

<p><br /></p>

<h1 id="정규식-이해를-위한-몇-가지-용어">정규식 이해를 위한 몇 가지 용어</h1>

<h2 id="정의--리터럴-literal">정의 : 리터럴 (literal)</h2>

<blockquote>
  <p>부울변수와 부울보수 연산을 한 부울변수 모두를 일컫는 말</p>
</blockquote>

<h3 id="예시">예시</h3>

<p>부울함수 $f(x, y)$는 부울변수 $x, y$ 로 구성되는 2차 부울함수로 $x,y$ 외에 $\bar{x}$ 와 $\bar{y}$ 가 리터럴이 될 수 있다.</p>

<blockquote>
  <p>그러므로 $n$개의 부울변수로 구성되는 $n$차 부울함수에서 사용할 수 있는 리터럴은 $2n$ 개다.</p>
</blockquote>

<p><br /></p>

<ul>
  <li>
    <p>$f(x, y) = \bar{x} + y$</p>

    <ul>
      <li>
        <p>2차 부울함수의 경우 사용가능한 리터럴이 $x, y, \bar{x}, \bar{y}$ 로 4개가 있다.</p>
      </li>
      <li>
        <p>이 중 $\bar{x}, y$ 가 이 부울함수의 리터럴로 사용되었다.</p>
      </li>
    </ul>
  </li>
</ul>

<p><br /></p>

<h2 id="정의--정규형-normal-form">정의 : 정규형 (normal form)</h2>

<blockquote>
  <p>부울함수를 구성하는 항을 부울합이나 부울곱으로 나타낸 함수 형태</p>
</blockquote>

<ol>
  <li>
    <p>논리합 정규형 (DNF, Disjunctive Normal Form)</p>

    <ul>
      <li>부울곱으로 연산된 항을 부울합으로 연산하는 함수 형태</li>
    </ul>
  </li>
  <li>
    <p>논리곱 정규형 (CNF, Conjunctive Normal Form)</p>

    <ul>
      <li>부울합으로 연산된 항을 부울곱으로 연산하는 함수 형태</li>
    </ul>
  </li>
</ol>

<h3 id="예시-1">예시</h3>

<ol>
  <li>
    <p>$f(x, y, z) = xy + \bar{x}yz + x\bar{y} + \bar{z}$</p>

    <ul>
      <li>
        <p>리터럴을 부울곱으로 연산한 항들을 부울합으로 연결하여 표현한 것</p>
      </li>
      <li>
        <p>DNF</p>
      </li>
    </ul>
  </li>
  <li>
    <p>$f(x, y, z) = (x + \bar{z})(\bar{x} + y + z)\bar{y}$</p>

    <ul>
      <li>
        <p>리터럴을 부울합으로 연산한 항을 부울곱으로 연견하여 표현한 것</p>
      </li>
      <li>
        <p>CNF</p>
      </li>
    </ul>
  </li>
</ol>

<p><br /></p>

<h2 id="정의--최소항-minterm">정의 : 최소항 (minterm)</h2>

<blockquote>
  <p>DNF인 $n$차 부울함수 $f(x_{1}, x_{2}, \cdots , x_{n})$를 구성하는 항들 중에서 리터럴 $n$개의 부울곱으로 구성된 항</p>
</blockquote>

<h2 id="정의--최대항-maxterm">정의 : 최대항 (maxterm)</h2>

<blockquote>
  <p>CNF인 $n$차 부울함수 $f(x_{1}, x_{2}, \cdots , x_{n})$를 구성하는 항들 중에서 리터럴 $n$개의 부울합으로 구성된 항</p>
</blockquote>

<h3 id="예시-2">예시</h3>

<p>$n$차 부울함수의 최소항이나 최대항을 구성하는 리터럴은 서로 다른 부울변수에 대한 것이어야 한다.</p>

<ul>
  <li>
    <p>$xx, \ \ x\bar{x}, \ \ \bar{x}\bar{x}, \ \ x + x, \ \ x + \bar{x},\ \  \bar{x} + \bar{x} \ \rightarrow$ X</p>
  </li>
  <li>
    <p>부울함수 $f(x, y)$ 를 구성할 수 있는 최소항과 최대항</p>

    <ol>
      <li>
        <p>$xy, \ \ x\bar{y}, \ \ \bar{x}y, \ \ \bar{x}\bar{y}$</p>
      </li>
      <li>
        <p>$x + y, \ \ x + \bar{y}, \ \ \bar{x} + y, \ \ \bar{x} + \bar{y}$</p>
      </li>
    </ol>
  </li>
</ul>

<blockquote>
  <p>$n$차 부울함수에서 사용될 수 있는 최소항 또는 최대항의 개수는 $2^{n}$개 이다.</p>
</blockquote>]]></content><author><name>지지형</name></author><category term="Discrete Mathematics" /><summary type="html"><![CDATA[부울함수의 표현]]></summary></entry><entry><title type="html">[이산수학] 부울대수(Boolean algebra) : 01. 부울대수의 개념</title><link href="http://localhost:4000/discrete%20mathematics/DM-29/" rel="alternate" type="text/html" title="[이산수학] 부울대수(Boolean algebra) : 01. 부울대수의 개념" /><published>2024-02-15T00:00:00+09:00</published><updated>2024-02-15T00:00:00+09:00</updated><id>http://localhost:4000/discrete%20mathematics/DM-29</id><content type="html" xml:base="http://localhost:4000/discrete%20mathematics/DM-29/"><![CDATA[<h1 id="부울대수">부울대수</h1>

<p>컴퓨터 시스템은 0과 1로 표현되는 비트의 집합을 연산하는 방식으로 운영된다.</p>

<p>그래서 컴퓨터 시스템을 구성하는 여러 물리 장치는 이러한 비트를 저장하고 연산하는 데 적합하도록 회로가 구성된다.</p>

<p>컴퓨터 시스템이 연산하는 것을 함수로 표현하고 그 함수를 회로로 설계하기 위해서는 특별한 연산과 표현 방식이 필요하다.</p>

<blockquote>
  <p>컴퓨터 시스템을 포함한 여러 디지털 장치의 회로를 분석하고 설계하기위해 회로의 기능을 함수로 표현하는 것을 <span style="background-color: #fff5b1">부울대수</span>라고 한다.</p>
</blockquote>

<p><br /></p>

<h1 id="부울대수의-개념">부울대수의 개념</h1>

<ul>
  <li>부울(Boolean)은 $0 / 1$ , 참($T$) / 거짓($F$), ON / OFF 와 같이 2진의 값을 표현하는 용어다.</li>
</ul>

<h2 id="정의--부울대수-boolean-algebra--논리대수-logic-algebra">정의 : 부울대수 (Boolean algebra) / 논리대수 (logic algebra)</h2>

<blockquote>
  <p>2진의 값인 부울값(0 또는 1)을 이용해 논리 동작을 표현하는 대수</p>
</blockquote>

<ul>
  <li>부울대수는 부울값, 부울변수, 부울 연산자를 이용해 부울함수로 회로의 동작을 형식화한다.</li>
</ul>

<h2 id="정의--부울값-boolean-value">정의 : 부울값 (Boolean value)</h2>

<blockquote>
  <p>디지털신호, $0$ 또는 $1$</p>
</blockquote>

<h2 id="정의--부울변수-boolean-variable">정의 : 부울변수 (Boolean variable)</h2>

<blockquote>
  <p>부울값을 받는 변수</p>
</blockquote>

<h2 id="정의--부울함수-boolean-function-n-차-부울함수--fx_1-x_2-cdots--x_n">정의 : 부울함수 (Boolean function, $n$ 차 부울함수 : $f(x_{1}, x_{2}, \cdots , x_{n})$)</h2>

<blockquote>
  <p>$n$ 개의 부울변수와 부울 연산자로 구성된 식</p>
</blockquote>

<ul>
  <li>부울 연산자에는 부울보수, 부울합, 부울곱이 있다.</li>
</ul>

<h2 id="정의--부울보수-boolean-complement--a-또는-bara">정의 : 부울보수 (Boolean complement : $A’$ 또는 $\bar{A}$)</h2>

<blockquote>
  <p>부울변수의 값을 반전시키는 단항 연산자</p>
</blockquote>

<ul>
  <li>
    <p>$0’ = \bar{0} = 1$</p>
  </li>
  <li>
    <p>$1’ = \bar{1} = 0$</p>
  </li>
</ul>

<h2 id="정의--부울합-boolean-addition--a--b">정의 : 부울합 (Boolean addition : $A + B$)</h2>

<blockquote>
  <p>부울변수의 값을 더하는 이항 연산자<br />
부울변수의 값 중 하나라도 1이면 그 결과는 1이 되는 연산</p>
</blockquote>

<ul>
  <li>
    <p>$0 + 0 = 0$</p>
  </li>
  <li>
    <p>$0 + 1 = 1$</p>
  </li>
  <li>
    <p>$1 + 0 = 1$</p>
  </li>
  <li>
    <p>$1 + 1 = 1$</p>
  </li>
</ul>

<h2 id="정의--부울곱-boolean-mutiplication--a-cdot-b-또는-ab">정의 : 부울곱 (Boolean mutiplication : $A \cdot B$ 또는 $AB$)</h2>

<blockquote>
  <p>부울변수의 값을 곱하는 이항 연산자<br />
부울변수의 값이 모두 1인 경우에만 그 결과가 1이 되는 연산</p>
</blockquote>

<ul>
  <li>
    <p>$0 \cdot 0 = 0$</p>
  </li>
  <li>
    <p>$0 \cdot 1 = 0$</p>
  </li>
  <li>
    <p>$1 \cdot 0 = 0$</p>
  </li>
  <li>
    <p>$1 \cdot 1 = 1$</p>
  </li>
</ul>

<p><br /></p>

<ul>
  <li>
    <p>부울 연산자의 정의를 살펴보면 논리 연산자와 유사하다는 것을 알 수 있다.</p>

    <ul>
      <li>
        <p>부울보수는 논리 연산자의 부정 연산자($NOT$)</p>
      </li>
      <li>
        <p>부울합은 논리합 연산자 ($OR$)</p>
      </li>
      <li>
        <p>부울곱은 논리곱 연산자 ($AND$)</p>
      </li>
    </ul>
  </li>
</ul>

<p><br /></p>

<ul>
  <li>
    <p>부울 연산자의 우선순위</p>

    <table>
      <thead>
        <tr>
          <th style="text-align: center">우선순위</th>
          <th style="text-align: center">연산자</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td style="text-align: center">최고</td>
          <td style="text-align: center">부울보수($’ / \bar{}$)</td>
        </tr>
        <tr>
          <td style="text-align: center">$\updownarrow$</td>
          <td style="text-align: center">부울곱($\cdot$)</td>
        </tr>
        <tr>
          <td style="text-align: center">최저</td>
          <td style="text-align: center">부울합(+)</td>
        </tr>
      </tbody>
    </table>
  </li>
</ul>

<p><br /></p>

<ul>
  <li>
    <p>부울변수로 구성된 부울함수는 입력한 값에 따라 출력되는 값이 달라질 수 있으므로 결과를 진리표로 확인한다.</p>
  </li>
  <li>
    <p>2차 부울함수 $f(x,y) = xy + \bar{x}y$ 에 대하여 부울변수 $x, y$에 입력한 값에 따른 결과를 확인하는 진리표는 다음과 같다.</p>

    <table>
      <thead>
        <tr>
          <th style="text-align: center"> </th>
          <th style="text-align: center"> </th>
          <th style="text-align: center"> </th>
          <th style="text-align: center"> </th>
          <th style="text-align: center"> </th>
          <th style="text-align: center"> </th>
          <th style="text-align: center"> </th>
          <th> </th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td style="text-align: center">$x$</td>
          <td style="text-align: center">$y$</td>
          <td style="text-align: center">$\bar{x}$</td>
          <td style="text-align: center">$xy$</td>
          <td style="text-align: center">$\bar{x}y$</td>
          <td style="text-align: center">$f(x, y) = xy + \bar{x}y$</td>
          <td style="text-align: center"> </td>
          <td> </td>
        </tr>
        <tr>
          <td style="text-align: center">0</td>
          <td style="text-align: center">0</td>
          <td style="text-align: center">1</td>
          <td style="text-align: center">0</td>
          <td style="text-align: center">0</td>
          <td style="text-align: center">0</td>
          <td style="text-align: center"> </td>
          <td> </td>
        </tr>
        <tr>
          <td style="text-align: center">0</td>
          <td style="text-align: center">1</td>
          <td style="text-align: center">1</td>
          <td style="text-align: center">0</td>
          <td style="text-align: center">1</td>
          <td style="text-align: center">1</td>
          <td style="text-align: center"> </td>
          <td> </td>
        </tr>
        <tr>
          <td style="text-align: center">1</td>
          <td style="text-align: center">0</td>
          <td style="text-align: center">0</td>
          <td style="text-align: center">0</td>
          <td style="text-align: center">0</td>
          <td style="text-align: center">0</td>
          <td style="text-align: center"> </td>
          <td> </td>
        </tr>
        <tr>
          <td style="text-align: center">1</td>
          <td style="text-align: center">1</td>
          <td style="text-align: center">0</td>
          <td style="text-align: center">1</td>
          <td style="text-align: center">0</td>
          <td style="text-align: center">1</td>
          <td style="text-align: center"> </td>
          <td> </td>
        </tr>
      </tbody>
    </table>
  </li>
</ul>

<p><br />
<br /></p>

<h1 id="부울대수의-법칙">부울대수의 법칙</h1>

<ol>
  <li>
    <p><strong>멱등법칙</strong>(idempotent law)</p>

    <ul>
      <li>
        <p>$x + x = x$</p>
      </li>
      <li>
        <p>$x \cdot x = x$</p>
      </li>
    </ul>
  </li>
  <li>
    <p><strong>항등법칙</strong>(identity law)</p>

    <ul>
      <li>
        <p>$x + 0 = x$</p>
      </li>
      <li>
        <p>$x \cdot 1 = x$</p>
      </li>
    </ul>
  </li>
  <li>
    <p><strong>지배법칙</strong>(domination law)</p>

    <ul>
      <li>
        <p>$x + 1 = 1$</p>
      </li>
      <li>
        <p>$x \cdot 0 = 0$</p>
      </li>
    </ul>
  </li>
  <li>
    <p><strong>교환법칙</strong>(commutative law)</p>

    <ul>
      <li>
        <p>$x + y = y + x$</p>
      </li>
      <li>
        <p>$xy = yx$</p>
      </li>
    </ul>
  </li>
  <li>
    <p><strong>이중 보수법칙</strong>(double complement law)</p>

    <ul>
      <li>$\overline{\bar{(x)}}$</li>
    </ul>

    <p><br /></p>
  </li>
  <li>
    <p><strong>보수법칙</strong>(complement law)</p>

    <ul>
      <li>
        <p>$x + \bar{x} = 1$</p>
      </li>
      <li>
        <p>$x \cdot \bar{x} = 0$</p>
      </li>
    </ul>
  </li>
  <li>
    <p><strong>결합법칙</strong>(associative law)</p>

    <ul>
      <li>
        <p>$(x + y) + z = x + (y + z)$</p>
      </li>
      <li>
        <p>$(xy)z = x(yz)$</p>
      </li>
    </ul>
  </li>
  <li>
    <p><strong>분배법칙</strong>(distributive law)</p>

    <ul>
      <li>
        <p>$x \cdot (y + z) = xy + xz$</p>
      </li>
      <li>
        <p>$x + yz = (x + y) \cdot (x + z)$</p>
      </li>
    </ul>
  </li>
  <li>
    <p><strong>드 모르간의 법칙</strong>(De Morgan’s law)</p>

    <ul>
      <li>
        <p>$\overline{x + y} = \bar{x} \bar{y}$</p>
      </li>
      <li>
        <p>$\overline{xy} = \bar{x} + \bar{y}$</p>
      </li>
    </ul>
  </li>
  <li>
    <p><strong>흡수법칙</strong>(absorption law)</p>

    <ul>
      <li>
        <p>$x + xy = x$</p>
      </li>
      <li>
        <p>$x(x + y) = x$</p>
      </li>
    </ul>
  </li>
  <li>
    <p><strong>1과 0의 법칙</strong></p>

    <ul>
      <li>
        <p>$\bar{0} = 1$</p>
      </li>
      <li>
        <p>$\bar{1} = 0$</p>
      </li>
    </ul>
  </li>
</ol>]]></content><author><name>지지형</name></author><category term="Discrete Mathematics" /><summary type="html"><![CDATA[부울대수]]></summary></entry><entry><title type="html">[이산수학] 트리(Tree) : 09. 허프만 알고리즘</title><link href="http://localhost:4000/discrete%20mathematics/DM-28/" rel="alternate" type="text/html" title="[이산수학] 트리(Tree) : 09. 허프만 알고리즘" /><published>2024-02-14T00:00:00+09:00</published><updated>2024-02-14T00:00:00+09:00</updated><id>http://localhost:4000/discrete%20mathematics/DM-28</id><content type="html" xml:base="http://localhost:4000/discrete%20mathematics/DM-28/"><![CDATA[<h1 id="허프만-알고리즘">허프만 알고리즘</h1>

<ul>
  <li>
    <p>컴퓨터에서 문자 데이터를 표현할 때 7 비트의 ASCII코드를 사용한다.</p>
  </li>
  <li>
    <p>컴퓨터에서 별다른 조치 없이 문자열을 저장한다면, 문자의 발생 빈도와 상관없이 각 문자는 언제다 동일한 길이의 비트를 사용한다.</p>
  </li>
  <li>
    <p>그러므로 하나의 파일 내에서 문자 수만큼  비트 수가 늘어난다.</p>
  </li>
  <li>
    <p>즉, 파일 안에 문자가 10개 있으면 70비트, 20개 있으면 140비트를 차지한다.</p>
  </li>
  <li>
    <p>만약 문자의 발생 빈도에 따라 할당하는 비트 수를 조절한다면 차지하는 메모리 공간을 줄일 수 있지 않을까?</p>
  </li>
  <li>
    <p>다시 말해 파일 내에서 발생 빈도가 높은 문자에 적은 비트를 할당, 발생 빈도가 낮은 문자에 많은 비트를 할당한다면 파일의 용량을 줄일 수 있을 것이다.</p>
  </li>
</ul>

<blockquote>
  <p>이렇게 파일 크기를 줄이는 방법을 데이터 압축(data compression)이라고 한다.</p>
</blockquote>

<blockquote>
  <p>이번 절에서는 대표적인 데이터 압축 방법인 허프만 알고리즘을 살펴본다.</p>
</blockquote>

<p><br /></p>

<h2 id="정의--허프만-알고리즘huffman-algorithm">정의 : 허프만 알고리즘(Huffman algorithm)</h2>

<blockquote>
  <p>발생 빈도가 높은 문자에서는 적은 비트를 할당하고 발생 빈도가 낮은 문자에는 많은 비트를 할당하는 알고리즘</p>
</blockquote>

<ol>
  <li>
    <p>발생 빈도가 가장 낮은 두 문자를 선택하여 하나의 이진트리를 생성한다.</p>

    <ol>
      <li>
        <p>왼쪽 노드에 빈도 수가 낮은 문자를, 오른쪽 노드에 빈도 수가 높은 문자를 위치시킨다.</p>
      </li>
      <li>
        <p>빈도 수가 같은 경우는 사전적으로 앞에 오는 문자를 왼쪽에 위치시킨다.</p>
      </li>
      <li>
        <p>두 문자의 빈도 수의 합을 그 문자들의 부모노드로 한다.</p>
      </li>
    </ol>
  </li>
  <li>
    <p>1번의 과정을 모든 문자가 하나의 이진트리로 묶일 때까지 반복한다.</p>
  </li>
  <li>
    <p>생성된 이진트리의 왼쪽 노드에서는 $0$, 오른쪽 노드에는 $1$ 을 부여한다.</p>
  </li>
  <li>
    <p>루트부터 해당 문자까지의 $0$ 또는 $1$ 을 순서대로 나열한다.</p>
  </li>
</ol>

<p><br /></p>

<h3 id="예시">예시</h3>

<p><br /></p>

<ul>
  <li>다음 문자의 빈도 수 표를 허프만 알고리즘을 이용해 압축해보자.</li>
</ul>

<p><img src="/assets/images/Math/dm/dm_example_28_01.png" /></p>

<ul>
  <li>만약 문자들을 허프만 알고리즘을 통한 압축 없이 메모리에 저장하면 $(15 + 8 + 23 + 8 + 30 + 2 + 17 + 5 + 2) \times 7 = 770$ 비트가 필요할 것이다.</li>
</ul>

<hr />

<ol>
  <li>
    <p>빈도 수가 가장 낮은 문자는 $o$ 와 $z$ 이다.</p>

    <ul>
      <li>두 문자의 빈도 수가 같고 $o$ 가 $z$ 보다 사전적 순서가 앞이므로 $o$ 를 왼쪽 노드, $z$ 를 오른쪽 노드로 한다.</li>
    </ul>

    <p><img src="/assets/images/Math/dm/dm_example_28_02.png" width="500" />
 <img src="/assets/images/Math/dm/dm_example_28_03.png" /></p>

    <p><br /></p>
  </li>
  <li>
    <p>다음으로 빈도 수가 가장 낮은 문자는 1번에서 만든 $o/z$ 서브트리와 $u$ 이다.</p>

    <ul>
      <li>$u$ 의 빈도 수가 $o/z$ 서브트리보다 높으므로 오른쪽 노드로 한다.</li>
    </ul>

    <p><img src="/assets/images/Math/dm/dm_example_28_04.png" width="500" />
 <img src="/assets/images/Math/dm/dm_example_28_05.png" /></p>

    <p><br /></p>
  </li>
  <li>
    <p>다음으로 빈도 수가 낮은 문자는 $e$ 와 $j$ 이다.</p>

    <ul>
      <li>그러므로 2번에서 만든 $o/z/u$ 서브트리와 별도로 서브트리가 만들어진다.</li>
    </ul>

    <p><img src="/assets/images/Math/dm/dm_example_28_06.png" width="500" />
 <img src="/assets/images/Math/dm/dm_example_28_07.png" /></p>

    <p><br /></p>
  </li>
  <li>
    <p>다음으로 빈도 수가 낮은 문자는 $b$ 와 $o/z/u$ 서브트리이다.</p>

    <ul>
      <li>$b$의 빈도 수가 $o/z/u$ 서브트리보다 높으므로 오른쪽 노드에 위치시킨다.</li>
    </ul>

    <p><img src="/assets/images/Math/dm/dm_example_28_08.png" width="500" />
 <img src="/assets/images/Math/dm/dm_example_28_09.png" /></p>

    <p><br /></p>
  </li>
  <li>
    <p>다음으로 빈도 수가 낮은 문자는 $s$ 와 $e/j$ 서브트리이다.</p>

    <ul>
      <li>$e/j$ 서브트리의 빈도 수가 더 낮으므로 왼쪽 서브트리로 하고 $s$ 를 오른쪽 노드에 위치시킨다.</li>
    </ul>

    <p><img src="/assets/images/Math/dm/dm_example_28_10.png" width="500" />
 <img src="/assets/images/Math/dm/dm_example_28_11.png" /></p>

    <p><br /></p>
  </li>
  <li>
    <p>다음으로 빈도 수가 낮은 문자는 $g$ 와 $o/z/u/b$ 서브트리이다.</p>

    <ul>
      <li>$g$ 의 빈도 수가 더 낮으므로 왼쪽 노드에 위치시키고 $o/z/u/b$ 서브트리는 오른쪽 서브트리로 한다.</li>
    </ul>

    <p><img src="/assets/images/Math/dm/dm_example_28_12.png" width="500" />
 <img src="/assets/images/Math/dm/dm_example_28_13.png" /></p>

    <p><br /></p>
  </li>
  <li>
    <p>다음으로 빈도 수가 낮은 문자는 $l$ 과 $e/j/s$ 서브트리이다.</p>

    <ul>
      <li>$l$ 의 빈도 수가 더 낮으므로 $l$ 을 왼쪽 노드에 위치시키고, $e/j/s$ 서브트리를 오른쪽 서브트리로 한다.</li>
    </ul>

    <p><img src="/assets/images/Math/dm/dm_example_28_14.png" width="500" />
 <img src="/assets/images/Math/dm/dm_example_28_15.png" /></p>

    <p><br /></p>
  </li>
  <li>
    <p>이제 두 서브트리를 하나의 루트노드로 연결한다.</p>

    <p><img src="/assets/images/Math/dm/dm_example_28_16.png" /></p>

    <p><br /></p>
  </li>
  <li>
    <p>각 서브트리마다 왼쪽 노드를 $0$ 을, 오른쪽 노드는 $1$ 을 부여한다.</p>

    <p><img src="/assets/images/Math/dm/dm_example_28_17.png" /></p>

    <p><br /></p>
  </li>
  <li>
    <p>9번의 결과를 이용해 각 문자에 코드를 부여한다.</p>

    <ul>
      <li>이러한 원리로 각 문자에 부여된 코드를 허프만 코드라고 하고 결과는 다음과 같다.</li>
    </ul>

    <p><img src="/assets/images/Math/dm/dm_example_28_18.png" /></p>

    <p><br /></p>
  </li>
</ol>

<ul>
  <li>
    <p>앞에서 압축 전에 주어진 빈도 수대로 메모리에 저장하면 $770$ 비트를 차지하는 것을 확인했다.</p>
  </li>
  <li>
    <p>허프만 알고리즘을 이용해 구한 허프만 코드로 저장할 때 치지하는 메모리 공간은 거의 반으로 줄어든다.</p>

    <p><img src="/assets/images/Math/dm/dm_example_28_19.png" /></p>

    <p><br /></p>
  </li>
  <li>
    <p>그러면 위에서 구한 허프만 코드를 이용해 문자열 $jguejozglbszesu$ 를 코드로 작성해보면 다음과 같다.</p>

    <ul>
      <li>$1101000101110011010100001000100100111110100111001110101$</li>
    </ul>

    <p><br /></p>
  </li>
  <li>
    <p>또한 허프만 코드만 주어질 경우 어떤 문자열로 구성되는지도 허프만 코드표를 참고하며 문자를 찾을 수 있다.</p>
  </li>
</ul>]]></content><author><name>지지형</name></author><category term="Discrete Mathematics" /><summary type="html"><![CDATA[허프만 알고리즘]]></summary></entry><entry><title type="html">[이산수학] 트리(Tree) : 06. 트리의 활용</title><link href="http://localhost:4000/discrete%20mathematics/DM-25/" rel="alternate" type="text/html" title="[이산수학] 트리(Tree) : 06. 트리의 활용" /><published>2024-02-13T00:00:00+09:00</published><updated>2024-02-13T00:00:00+09:00</updated><id>http://localhost:4000/discrete%20mathematics/DM-25</id><content type="html" xml:base="http://localhost:4000/discrete%20mathematics/DM-25/"><![CDATA[<h1 id="트리의-활용">트리의 활용</h1>

<ul>
  <li>
    <p>트리는 그래프의 한 종류이다.</p>
  </li>
  <li>
    <p>그래프에서 공부한 깊이 우선 탐색 및 너비 우선 탐색 방법을 활용하거나 그래프의 신장부분그래프 개념과 최단 경로 문제를 트리에 적용하여 탐색할 수 있다.</p>
  </li>
  <li>
    <p>그뿐 아니라 트리는 데이터를 압축하기 위한 방법으로 사용된다.</p>
  </li>
  <li>
    <p>이 절에서는 트리 탐색의 새로운 방법인 최소신장트리와 데이터 압축 방법인 허프만 알고리즘을 알아본다.</p>
  </li>
</ul>

<p><br /></p>

<h1 id="최소신장트리">최소신장트리</h1>

<h2 id="정의--신장트리-spanning-tree">정의 : 신장트리 (spanning tree)</h2>

<blockquote>
  <p>그래프 $G$ 의 모든 정점을 노드로 포함하는 트리 $T$</p>
</blockquote>

<h3 id="예시">예시</h3>

<ul>
  <li>
    <p>신장트리 $T$ 는 하나의 그래프 $G$ 에서 유도될 수 있는 다양한 형태의 트리로,<br />
그래프를 구성하는 모든 정점은 루트노드가 될 수 있으며 부모노드와 자식노드를 연결하는 변을 그래프 $G$ 에도 포함되는 변이어야 한다.</p>
  </li>
  <li>
    <p>다음 그림은 그래프 $G$ 에서 노드 $A$ 를 루트노드로 선택할 때 만들 수 있는 신장트리의 예이다.</p>
  </li>
  <li>
    <p>그래프 $G$</p>

    <p><img src="/assets/images/Math/dm/dm_example_25_01.png" width="500" /></p>
  </li>
</ul>

<p><br /></p>

<ul>
  <li>그래프 $G$ 에 대한 신장트리 $T$ 의 예</li>
</ul>

<p><img src="/assets/images/Math/dm/dm_example_25_01.png" width="350" /> $\qquad$ <img src="/assets/images/Math/dm/dm_example_25_01.png" width="350" /></p>

<p><br /></p>

<ul>
  <li>
    <p>이처럼 주어진 그래프에서 트리를 유도할 때 트리가 활용되는 목적에 따라 다양한 형태의 트리가 만들어질 수 있다.</p>
  </li>
  <li>
    <p>특히 가중치그래프가 주어진 경우에는 각 노드를 탐색하는 비용이 최소가 되는 변들을 선택하여 트리를 구성할 수 있다.</p>
  </li>
</ul>

<p><br /></p>

<h2 id="정의--최소신장트리-minimum-spanning-tree">정의 : 최소신장트리 (minimum spanning tree)</h2>

<blockquote>
  <p>그래프 $G$ 의 모든 정점을 노드로 포함하면서 노드 간의 비용을 최소로 하는 트리 $T$</p>
</blockquote>

<ul>
  <li>
    <p>그래프에서 최소 비용을 갖는 트리를 구성하는 대표적인 알고리즘으로 프림 알고리즘과 크루스칼 알고리즘이 있다.</p>
  </li>
  <li>
    <p>프림 알고리즘과 크루스칼 알고리즘에 대한 자세한 설명은 다음 장인 6-1 과 6-2 에서 다루겠습니다.</p>

    <ul>
      <li>
        <p>프림알고리즘 (링크 예정)</p>
      </li>
      <li>
        <p>크루스칼 알고리즘 (링크 예정)</p>
      </li>
    </ul>
  </li>
</ul>]]></content><author><name>지지형</name></author><category term="Discrete Mathematics" /><summary type="html"><![CDATA[트리의 활용]]></summary></entry><entry><title type="html">[이산수학] 트리(Tree) : 08. 크루스칼 알고리즘</title><link href="http://localhost:4000/discrete%20mathematics/DM-27/" rel="alternate" type="text/html" title="[이산수학] 트리(Tree) : 08. 크루스칼 알고리즘" /><published>2024-02-13T00:00:00+09:00</published><updated>2024-02-13T00:00:00+09:00</updated><id>http://localhost:4000/discrete%20mathematics/DM-27</id><content type="html" xml:base="http://localhost:4000/discrete%20mathematics/DM-27/"><![CDATA[<h1 id="크루스칼-알고리즘-kruskal-algorithm">크루스칼 알고리즘 (Kruskal algorithm)</h1>

<ul>
  <li>크루스칼 알고리즘의 실행 규칙은 다음과 같다.</li>
</ul>

<blockquote>
  <ol>
    <li>노드 수가 $v$ 개인 그래프에서 가중치가 가장 작은 변을 차례로 선택한다.</li>
    <li>가중치가 같은 변은 모두 선택한다.</li>
    <li>노드 사시에 순환이 형성되는 경우 그 변을 선택하지 않는다.</li>
    <li>선택된 변이 $v - 1$ 개가 되면 종료한다.</li>
  </ol>
</blockquote>

<p><br /></p>

<ul>
  <li>다음 그림의 노드가 $6$ 개인 그래프 $G$ 를 크루스칼 알고리즘을 이용해 최소신장트리로 만들기 위해 각 변의 가중치를 정리하면 다음 표와 같다.</li>
</ul>

<p><img src="/assets/images/Math/dm/dm_example_26_01.png" width="400" /> $\ \ $ <img src="/assets/images/Math/dm/dm_example_27_01.png" width="400" /></p>

<p><br /></p>

<ol>
  <li>
    <p>표에서 가중치가 가장 작은 변인 노드 $A, C$ 를 연결하는 변을 선택한다.</p>

    <ul>
      <li>
        <p>노드 : $2$ 개</p>
      </li>
      <li>
        <p>변 : $1$ 개</p>
      </li>
    </ul>

    <p><img src="/assets/images/Math/dm/dm_example_27_02.png" width="400" /> $\ \ $ <img src="/assets/images/Math/dm/dm_example_27_03.png" width="400" /></p>
  </li>
  <li>
    <p>남은 변 중 가중치가 가장 작은 변인 노드 $A, D$ 를 연결하는 변과 노드 $E, F$ 를 연결하는 변을 선택한다.</p>

    <ul>
      <li>
        <p>노드 : $5$ 개</p>
      </li>
      <li>
        <p>변 : $3$ 개</p>
      </li>
    </ul>

    <p><img src="/assets/images/Math/dm/dm_example_27_04.png" width="400" /> $\ \ $ <img src="/assets/images/Math/dm/dm_example_27_05.png" width="400" /></p>
  </li>
  <li>
    <p>남은 변 중 가중치가 가장 작은 변은 노드 $B, C$ 를 연결하는 변과 노드 $C, D$ 를 연결하는 변이다.</p>
  </li>
</ol>

<ul>
  <li>
    <p>노드 $C, D$ 를 연결하는 변은 노드 $A, C, D$ 사이에 순환을 형성하므로 선택하지 않는다.</p>
  </li>
  <li>
    <p>그러므로 노드 $B, C$를 연결하는 변을 선택한다.</p>

    <ul>
      <li>
        <p>노드 : $6$ 개</p>
      </li>
      <li>
        <p>변 : $4$ 개</p>
      </li>
    </ul>

    <p><img src="/assets/images/Math/dm/dm_example_27_06.png" width="400" /> $\ \ $ <img src="/assets/images/Math/dm/dm_example_27_07.png" width="400" /></p>
  </li>
</ul>

<ol>
  <li>
    <p>남은 변 중 가중치가 가장 작은 변인 노드 $B, E$ 를 연결하는 변을 선택한다.</p>

    <ul>
      <li>
        <p>노드 : $6$ 개</p>
      </li>
      <li>
        <p>변 : $5$ 개</p>
      </li>
    </ul>

    <p><img src="/assets/images/Math/dm/dm_example_27_08.png" width="400" /> $\ \ $ <img src="/assets/images/Math/dm/dm_example_27_09.png" width="400" /></p>
  </li>
  <li>
    <p>최소신장트리의 변의 수가 노드 수 - 1 이므로 실행을 종료한다. (변의 수 : $5$, 노드 수 - 1 : $6 - 1$)</p>
  </li>
</ol>

<ul>
  <li>완성된 최소신장트리의 가중치는 $9 + 10 + 12 + 13 + 10 = 54$ 이다.</li>
</ul>]]></content><author><name>지지형</name></author><category term="Discrete Mathematics" /><summary type="html"><![CDATA[크루스칼 알고리즘 (Kruskal algorithm)]]></summary></entry><entry><title type="html">[이산수학] 트리(Tree) : 07. 프림 알고리즘</title><link href="http://localhost:4000/discrete%20mathematics/DM-26/" rel="alternate" type="text/html" title="[이산수학] 트리(Tree) : 07. 프림 알고리즘" /><published>2024-02-13T00:00:00+09:00</published><updated>2024-02-13T00:00:00+09:00</updated><id>http://localhost:4000/discrete%20mathematics/DM-26</id><content type="html" xml:base="http://localhost:4000/discrete%20mathematics/DM-26/"><![CDATA[<h1 id="프림-알고리즘-prim-algorithm">프림 알고리즘 (Prim algorithm)</h1>

<h2 id="프림-알고리즘의-과정">프림 알고리즘의 과정</h2>

<ol>
  <li>
    <p>$v$ 개의 정점을 포함하는 그래프 $G$ 에서 가중치가 가장 작은 변과 그 변에 연결된 정점을 노드로 선택한다.</p>

    <ul>
      <li>가중치가 같은 변이 $2$ 개 이상 있을 경우 임의로 하나를 선택한다.</li>
    </ul>

    <p><br /></p>
  </li>
  <li>
    <p>선택한 노드에 연결된 모든 변들 중 가중치가 가장 작은 변을 선택한다.</p>

    <ul>
      <li>
        <p>가중치가 같은 변이 $2$ 개 이상 있을 경우 임의로 하나를 선택한다.</p>
      </li>
      <li>
        <p>순환이 형성되는 경우에는 그 변을 선택하지 않는다.</p>
      </li>
    </ul>

    <p><br /></p>
  </li>
  <li>
    <p>선택한 변이 $v - 1$ 개가 될 때까지 2번의 과정을 반복한다.</p>
  </li>
</ol>

<p><br /></p>

<h3 id="예시">예시</h3>

<ul>
  <li>
    <p>다음 그림과 같이 $6$ 개의 노드를 갖는 그래프 $G$ 를 프림 알고리즘의 규칙을 이용해 최소신장트리로 만드는 과정이다.</p>
  </li>
  <li>
    <p>각 변에 부여된 가중치는 비용이다.</p>
  </li>
</ul>

<p><img src="/assets/images/Math/dm/dm_example_26_01.png" width="500" /> <img src="/assets/images/Math/dm/dm_example_26_02.png" width="350" /></p>

<p><br /></p>

<ol>
  <li>
    <p>가중치가 가장 작은 변인 노드 $A, C$ 를 연결하는 변과 해당 노드를 선택한다.</p>

    <ul>
      <li>
        <p>노드 : $2$ 개</p>
      </li>
      <li>
        <p>변 : $1$ 개</p>
      </li>
    </ul>

    <p><img src="/assets/images/Math/dm/dm_example_26_03.png" width="250" /></p>

    <p><br /></p>
  </li>
  <li>
    <p>노드 $A, C$ 와 연결된 노드 중 ($B, D, E, F$) 가중치가 가장 작은 변인 노드 $A, D$ 를 연결한다.</p>

    <ul>
      <li>
        <p>노드 : $3$ 개</p>
      </li>
      <li>
        <p>변 : $2$ 개</p>
      </li>
    </ul>

    <p><img src="/assets/images/Math/dm/dm_example_26_04.png" width="500" /> <img src="/assets/images/Math/dm/dm_example_26_05.png" width="250" /></p>

    <p><br /></p>
  </li>
  <li>
    <p>노드 $A, C, D$ 와 연결된 노드 중 ($B, E, F$) 가중치가 가장 작은 변은 $12$ 로 $(C, B)$ 와 $(C, D)$ 가 있다.</p>

    <ul>
      <li>
        <p>$(C, D)$ 를 연결할 경우 노드 $A, C, D$ 사이에 순환이 형성되므로 선택할 수 없다.</p>
      </li>
      <li>
        <p>따라서 노드 $C, B$ 를 연결하는 변을 선택해 노드 $A, B, C, D$ 를 연결한다.</p>
      </li>
      <li>
        <p>노드 : $4$ 개</p>
      </li>
      <li>
        <p>변 : $3$ 개</p>
      </li>
    </ul>

    <p><img src="/assets/images/Math/dm/dm_example_26_06.png" width="500" /> <img src="/assets/images/Math/dm/dm_example_26_07.png" width="300" /></p>

    <p><br /></p>
  </li>
  <li>
    <p>노드 $A, B, C, D$ 와 연결된 노드 중 ($E, F$) 가중치가 가장 작은 변인 노드 $(B, E)$ 를 연결한다.</p>

    <ul>
      <li>
        <p>노드 : $5$ 개</p>
      </li>
      <li>
        <p>변 : $4$ 개</p>
      </li>
    </ul>

    <p><img src="/assets/images/Math/dm/dm_example_26_08.png" width="500" /> <img src="/assets/images/Math/dm/dm_example_26_09.png" width="300" /></p>

    <p><br /></p>
  </li>
  <li>
    <p>노드 $A, B, C, D, E$ 와 연결된 변과 노드 중 가중치가 가장 작은 변인 노드 $(E, F)$ 를 연결한다.</p>

    <ul>
      <li>
        <p>노드 : $6$ 개</p>
      </li>
      <li>
        <p>변 : $5$ 개</p>
      </li>
    </ul>

    <p><img src="/assets/images/Math/dm/dm_example_26_10.png" width="500" /> <img src="/assets/images/Math/dm/dm_example_26_11.png" width="330" /></p>

    <p><br /></p>
  </li>
  <li>
    <p>최소신장트리의 변의 수 $(5)$ 가 노드 수 $- 1$ $(6 - 1)$ 이므로 실행을 종료한다.</p>
  </li>
  <li>
    <p>완성된 최소신장트리의 가중치는 $9 + 10 + 12 + 13 + 10 = 54$ 이다.</p>
  </li>
</ol>]]></content><author><name>지지형</name></author><category term="Discrete Mathematics" /><summary type="html"><![CDATA[프림 알고리즘 (Prim algorithm)]]></summary></entry><entry><title type="html">[이산수학] 트리(Tree) : 05. 이진탐색트리</title><link href="http://localhost:4000/discrete%20mathematics/DM-24/" rel="alternate" type="text/html" title="[이산수학] 트리(Tree) : 05. 이진탐색트리" /><published>2024-02-12T00:00:00+09:00</published><updated>2024-02-12T00:00:00+09:00</updated><id>http://localhost:4000/discrete%20mathematics/DM-24</id><content type="html" xml:base="http://localhost:4000/discrete%20mathematics/DM-24/"><![CDATA[<h1 id="이진탐색트리">이진탐색트리</h1>

<ul>
  <li>
    <p><strong>탐색(search)</strong> : 수많은 데이터 중 원하는 데이터를 찾아가는 과정</p>
  </li>
  <li>
    <p>탐색은 데이터의 정렬 방식이나 탐색 기준에 따라 그 방법이 달라진다.</p>
  </li>
  <li>
    <p>어떤 기준 또는 <strong>키(key)</strong>를 정하고 그 키를 이용해 탐색해가는 방법을 이진탐색이라 한다.</p>
  </li>
  <li>
    <p>이 탐색을 도와주는 트리를 <strong>이진탐색트리</strong>라고 한다.</p>
  </li>
</ul>

<p><br /></p>

<h2 id="정의--이진탐색-binary-search">정의 : 이진탐색 (binary search)</h2>

<blockquote>
  <p>탐색을 위한 일정 기준을 가지고 대상 데이터를 탐색하는 방법</p>
</blockquote>

<p><br /></p>

<h2 id="정의--이진탐색트리-binary-search-tree">정의 : 이진탐색트리 (binary search tree)</h2>

<blockquote>
  <p>노드로 표현되는 데이터에 대한 기준에 따라 노드의 위치를 탐색할 수 있는 트리</p>
</blockquote>

<h3 id="예시">예시</h3>

<ul>
  <li>
    <p>탐색을 위해 이진탐색트리를 구현하는 규칙은 다음과 같다.</p>

    <ol>
      <li>
        <p>트리에서 탐색되는 모든 원소는 서로 다른 유일키를 갖는다.</p>
      </li>
      <li>
        <p>왼쪽 서브트리에 있는 원소들의 키는 그 루트의 키보다 작거나 앞선 순서를 갖는다.</p>
      </li>
      <li>
        <p>오른쪽 서브트리에 있는 원소들의 키는 그 루트의 키보다 크거나 뒤의 순서를 갖는다.</p>
      </li>
    </ol>
  </li>
</ul>

<p><br /></p>

<ul>
  <li>
    <p>$15, 12, 13, 21, 18, 10, 24, 22, 7, 11, 25$ 가 주어질 때 이 값들을 탐색하기 위해 이진탐색트리로 구성해보자.</p>

    <ol>
      <li>
        <p>$15$ 입력 : 루트노드</p>

        <p><img src="/assets/images/Math/dm/dm_example_24_01.png" width="300" /></p>
      </li>
      <li>$12$ 입력
        <ul>
          <li>
            <p>트리의 유일키인 루트노드($15$) 보다 작다.</p>
          </li>
          <li>
            <p>루트노드($15$)의 왼쪽 자식노드</p>
          </li>
        </ul>

        <p><img src="/assets/images/Math/dm/dm_example_24_02.png" width="300" /></p>
      </li>
      <li>$13$ 입력
        <ul>
          <li>
            <p>트리의 유일키인 루트노드($15$) 보다 작다.</p>
          </li>
          <li>
            <p>$15$ 의 왼쪽 서브트리 탐색</p>
          </li>
          <li>
            <p>왼쪽 서브트리의 유일키인 $12$ 보다 크다.</p>
          </li>
          <li>
            <p>$12$ 의 오른쪽 자식노드</p>
          </li>
        </ul>

        <p><img src="/assets/images/Math/dm/dm_example_24_03.png" width="300" /></p>
      </li>
      <li>$21$ 입력
        <ul>
          <li>
            <p>트리의 유일키인 루트노드 $15$ 보다 크다.</p>
          </li>
          <li>
            <p>$15$ 의 오른쪽 자식노드</p>
          </li>
        </ul>

        <p><img src="/assets/images/Math/dm/dm_example_24_04.png" width="300" /></p>
      </li>
      <li>$18$ 입력
        <ul>
          <li>
            <p>트리의 유일키인 루트노드($15$) 보다 작다.</p>
          </li>
          <li>
            <p>$15$의 오른쪽 서브트리 탐색</p>
          </li>
          <li>
            <p>오른쪽 서브트리의 유일키인 $21$ 보다 작다.</p>
          </li>
          <li>
            <p>$21$ 의 왼쪽 자식노드</p>
          </li>
        </ul>

        <p><img src="/assets/images/Math/dm/dm_example_24_05.png" width="300" /></p>
      </li>
      <li>$10$ 입력
        <ul>
          <li>
            <p>트리의 유일키인 루트노드 $15$ 보다 작다.</p>
          </li>
          <li>
            <p>$15$ 의 왼쪽 서브트리 탐색</p>
          </li>
          <li>
            <p>왼쪽 서브트리인 유일키인 $12$ 보다 작다.</p>
          </li>
          <li>
            <p>$12$ 의 왼쪽 자식노드</p>
          </li>
        </ul>

        <p><img src="/assets/images/Math/dm/dm_example_24_06.png" width="300" /></p>
      </li>
      <li>$24$ 입력
        <ul>
          <li>
            <p>트리의 유일키인 루트노드 $15$ 보다 크다.</p>
          </li>
          <li>
            <p>$15$ 의 오른쪽 서브트리 탐색</p>
          </li>
          <li>
            <p>오른쪽 서브트리의 유일키인 $21$ 보다 크다.</p>
          </li>
          <li>
            <p>$21$ 의 오른쪽 자식노드</p>
          </li>
        </ul>

        <p><img src="/assets/images/Math/dm/dm_example_24_07.png" width="300" /></p>
      </li>
      <li>$22$ 입력
        <ul>
          <li>
            <p>트리의 유일키인 루트노드 $15$ 보다 크다.</p>
          </li>
          <li>
            <p>$15$ 의 오른쪽 서브트리 탐색</p>
          </li>
          <li>
            <p>오른쪽 서브트리의 유일키인 $21$ 보다 크다.</p>
          </li>
          <li>
            <p>$21$ 의 오른쪽 서브트리 탐색</p>
          </li>
          <li>
            <p>오른쪽 서브트리의 유일키인 $24$ 보다 작다.</p>
          </li>
          <li>
            <p>$24$ 의 왼쪽 자식노드</p>
          </li>
        </ul>

        <p><img src="/assets/images/Math/dm/dm_example_24_08.png" width="300" /></p>
      </li>
      <li>$7$ 입력
        <ul>
          <li>
            <p>트리의 유일키인 루트노드 $15$ 보다 작다.</p>
          </li>
          <li>
            <p>$15$ 의 왼쪽 서브트리 탐색</p>
          </li>
          <li>
            <p>왼쪽 서브트리의 유일키인 $12$ 보다 작다.</p>
          </li>
          <li>
            <p>$12$ 의 왼쪽 서브트리 탐색</p>
          </li>
          <li>
            <p>왼쪽 서브트리의 유일키인 $10$ 보다 작다.</p>
          </li>
          <li>
            <p>$10$ 의 왼쪽 자식노드</p>
          </li>
        </ul>

        <p><img src="/assets/images/Math/dm/dm_example_24_09.png" width="300" /></p>
      </li>
      <li>$11$ 입력
        <ul>
          <li>
            <p>트리의 유일키인 루트노드 $15$ 보다 작다.</p>
          </li>
          <li>
            <p>$15$ 의 왼쪽 서브트리 탐색</p>
          </li>
          <li>
            <p>왼쪽 서브트리의 유일키인 $12$ 보다 작다.</p>
          </li>
          <li>
            <p>$12$ 의 왼쪽 서브트리 탐색</p>
          </li>
          <li>
            <p>왼쪽 서브트리의 유일키인 $10$ 보다 크다.</p>
          </li>
          <li>
            <p>$10$ 의 오른쪽 자식노드</p>
          </li>
        </ul>

        <p><img src="/assets/images/Math/dm/dm_example_24_10.png" width="300" /></p>
      </li>
      <li>$25$ 입력
        <ul>
          <li>
            <p>트리의 유일키인 루트노드 $15$ 보다 크다.</p>
          </li>
          <li>
            <p>$15$ 의 오른쪽 서브트리 탐색</p>
          </li>
          <li>
            <p>오른쪽 서브트리의 유일키인 $21$ 보다 크다.</p>
          </li>
          <li>
            <p>$21$ 의 오른쪽 서브트리 탐색</p>
          </li>
          <li>
            <p>오른쪽 서브트리의 유일키인 $24$ 보다 크다.</p>
          </li>
          <li>
            <p>$24$ 의 오른쪽 자식노드</p>
          </li>
        </ul>

        <p><img src="/assets/images/Math/dm/dm_example_24_11.png" width="300" /></p>
      </li>
    </ol>

    <p><br /></p>

    <ul>
      <li>
        <p>이렇게 완성된 이진탐색트리는 루트노드 $15$ 는 $15$ 보다 작은 값들로 구성된 왼쪽 서브트리, $15$ 보다 큰 값들로 구성된 오른쪽 서브트리를 갖는다.</p>
      </li>
      <li>
        <p>그래서 $15$ 는 두 서브트리를 구분하는 유일키이다.</p>
      </li>
      <li>
        <p>왼쪽 서브트리의 경우 서브트리의 루트노드인 $12$ 는 $12$ 보다 작은 값들로 구성된 왼쪽 서브트리와 $12$ 보다 큰 값들로 구성된 오른쪽 서브트리를 갖는다.</p>
      </li>
      <li>
        <p>그러므로 $12$ 는 이 두 서브트리를 구분하는 유일키이고 $15$ 보다 작은 값들을 탐색할 수 있다.</p>
      </li>
      <li>
        <p>반대로 $15$ 보다 큰 값들은 $21$ 이 유일키일 것이다.</p>
      </li>
    </ul>
  </li>
</ul>

<p><br /></p>

<ul>
  <li>
    <p>이진탐색트리에서 $18$ 을 탐색하는 과정</p>

    <ol>
      <li>$18$ 은 이 트리의 루트노드이면서 유일키인 $15$ 보다 크다.
        <ul>
          <li>$15$ 오른쪽 서브트리 탐색</li>
        </ul>
      </li>
      <li>$18$ 은 오른쪽 서브트리의 루트노드이면서 유일키인 $21$ 보다 작다.
        <ul>
          <li>$21$ 의 왼쪽 서브트리 탐색</li>
        </ul>
      </li>
      <li>
        <p>$18$ 은 오른쪽 서브트리의 루트노드이다.</p>
      </li>
      <li>탐색을 종료</li>
    </ol>
  </li>
</ul>]]></content><author><name>지지형</name></author><category term="Discrete Mathematics" /><summary type="html"><![CDATA[이진탐색트리]]></summary></entry><entry><title type="html">[이산수학] 트리(Tree) : 04. 이진트리 순회</title><link href="http://localhost:4000/discrete%20mathematics/DM-23/" rel="alternate" type="text/html" title="[이산수학] 트리(Tree) : 04. 이진트리 순회" /><published>2024-02-10T00:00:00+09:00</published><updated>2024-02-11T00:00:00+09:00</updated><id>http://localhost:4000/discrete%20mathematics/DM-23</id><content type="html" xml:base="http://localhost:4000/discrete%20mathematics/DM-23/"><![CDATA[<h1 id="이진트리의-순회">이진트리의 순회</h1>

<blockquote>
  <p>트리를 구성하는 모든 노드를 한 번씩 방문하는 방법을 <strong>순회(traversal)</strong>라고 한다.</p>
</blockquote>

<ul>
  <li>
    <p>트리는 다음과 같은 규칙을 따른다.</p>

    <ol>
      <li>
        <p>항상 루트노드에서 시작한다.</p>
      </li>
      <li>
        <p>노드의 데이터를 읽기 전에 노드가 존재하는지 먼저 탐색한다.</p>
      </li>
      <li>
        <p>형제노드 중 왼쪽 노드를 먼저 탐색한다.</p>
      </li>
    </ol>
  </li>
  <li>
    <p>순회하는 서브트리의 루트노드를 언제 방문하느냐에 따라 전위순회, 중위순회, 후위순회로 구분한다.</p>
  </li>
</ul>

<p><br /></p>

<h2 id="정의--전위순회-preorder-traversal">정의 : 전위순회 (preorder traversal)</h2>

<blockquote>
  <p>부모노드 - 왼쪽 자식노드 - 오른쪽 자식노드 순으로 탐색하는 순회 방식</p>
</blockquote>

<h3 id="예시">예시</h3>

<p><img src="/assets/images/Math/dm/dm_example_23_01.png" width="400" /></p>

<p><br /></p>

<table>
  <thead>
    <tr>
      <th style="text-align: left"> </th>
      <th style="text-align: center"> </th>
      <th style="text-align: center"> </th>
      <th style="text-align: center"> </th>
      <th style="text-align: center"> </th>
      <th style="text-align: center"> </th>
      <th style="text-align: center"> </th>
      <th style="text-align: center"> </th>
      <th style="text-align: center"> </th>
      <th style="text-align: center"> </th>
      <th style="text-align: center"> </th>
      <th style="text-align: center"> </th>
      <th style="text-align: center"> </th>
      <th style="text-align: center"> </th>
      <th style="text-align: center"> </th>
      <th> </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left">노드</td>
      <td style="text-align: center">$1$</td>
      <td style="text-align: center">$2$</td>
      <td style="text-align: center">$3$</td>
      <td style="text-align: center">$4$</td>
      <td style="text-align: center">$5$</td>
      <td style="text-align: center">$6$</td>
      <td style="text-align: center">$7$</td>
      <td style="text-align: center">$8$</td>
      <td style="text-align: center">$9$</td>
      <td style="text-align: center">$10$</td>
      <td style="text-align: center">$11$</td>
      <td style="text-align: center">$12$</td>
      <td style="text-align: center">$13$</td>
      <td style="text-align: center">$14$</td>
      <td>$15$</td>
    </tr>
    <tr>
      <td style="text-align: left">데이터</td>
      <td style="text-align: center">$A$</td>
      <td style="text-align: center">$B$</td>
      <td style="text-align: center">$C$</td>
      <td style="text-align: center">$D$</td>
      <td style="text-align: center">$E$</td>
      <td style="text-align: center">$null$</td>
      <td style="text-align: center">$F$</td>
      <td style="text-align: center">$null$</td>
      <td style="text-align: center">$null$</td>
      <td style="text-align: center">$null$</td>
      <td style="text-align: center">$null$</td>
      <td style="text-align: center">$null$</td>
      <td style="text-align: center">$null$</td>
      <td style="text-align: center">$null$</td>
      <td>$null$</td>
    </tr>
  </tbody>
</table>

<p><br /></p>

<details>
<summary>[자세히] 전위순회 과정</summary>
<div>

    <ol>
      <li>루트노드 $1$ 탐색 - 데이터 존재 확인 및 방문 - 노드 $1$애 데이터 $A$ 읽기
        <ul>
          <li>$A$</li>
        </ul>
      </li>
      <li>노드 $1$의 왼쪽 자식노드 $2$탐색 - 데이터 존재 확인 및 방문 - 노드 $2$에 데이터 읽기
        <ul>
          <li>$A - B$</li>
        </ul>
      </li>
      <li>노드 $2$의 왼쪽 자식노드 $4$탐색 - 데이터 존재 확인 및 방문 - 노드 $4$에 데이터 읽기
        <ul>
          <li>$A - B - D$</li>
        </ul>
      </li>
      <li>노드 $4$의 왼쪽 자식노드 $8$ 탐색 - 데이터 없음을 확인</li>
      <li>노드 $4$의 오른쪽 자식노드 $9$ 탐색 - 데이터 없음을 확인</li>
      <li>노드 $4$의 부모노드 $2$로 백트래킹</li>
      <li>노드 $2$의 오른쪽 자식노드 $5$ 탐색 - 데이터 존재 확인 및 방문 - 노드 $5$에 데이터 $E$ 읽기
        <ul>
          <li>$A - B - D - E$</li>
        </ul>
      </li>
      <li>노드 $5$의 왼쪽 자식노드 $10$ 탐색 - 데이터 없음을 확인</li>
      <li>노드 $5$의 오른쪽 자식노드 $11$ 탐색 - 데이터 없음을 확인</li>
      <li>노드 $5$의 부모노드 $2$로 백트래킹</li>
      <li>노드 $2$의 부모노드 $1$로 백트래킹</li>
      <li>노드 $1$의 오른쪽 자식노드 $3$ 탐색 - 데이터 존재 확인 및 방문 - 노드 $3$에 데이터 $C$ 읽기
        <ul>
          <li>$A - B - D - E - C$</li>
        </ul>
      </li>
      <li>노드 $3$의 왼쪽 자식노드 $6$ 탐색 - 데이터 없음을 확인</li>
      <li>노드 $3$의 오른쪽 자식노드 $7$ 탐색 - 데이터 존재 확인 및 방문 - 노드 $7$에 데이터 $F$ 읽기
        <ul>
          <li>$A - B - D - E - C - F$</li>
        </ul>
      </li>
      <li>노드 $7$의 왼쪽 자식노드 $14$ 탐색 - 데이터 없음을 확인</li>
      <li>노드 $7$의 오른쪽 자식노드 $15$ 탐색 - 데이터 없음을 확인</li>
      <li>노드 $7$의 부모노드 $3$으로 백트래킹</li>
      <li>노드 $3$의 부모노드 $1$으로 백트래킹</li>
      <li>순회종료</li>
    </ol>

  </div>
</details>

<blockquote>
  <p>전위순회 결과는 $A - B - D - E - C - F$이다.</p>
</blockquote>

<p><br /></p>

<h2 id="정의--중위순회-inorder-traversal">정의 : 중위순회 (inorder traversal)</h2>

<blockquote>
  <p>왼쪽 자식노드 - 부모노드 - 오른쪽 자식노드 순으로 탐색하는 순회 방식</p>
</blockquote>

<h3 id="예시-1">예시</h3>

<p><img src="/assets/images/Math/dm/dm_example_23_01.png" width="400" /></p>

<p><br /></p>

<table>
  <thead>
    <tr>
      <th style="text-align: left"> </th>
      <th style="text-align: center"> </th>
      <th style="text-align: center"> </th>
      <th style="text-align: center"> </th>
      <th style="text-align: center"> </th>
      <th style="text-align: center"> </th>
      <th style="text-align: center"> </th>
      <th style="text-align: center"> </th>
      <th style="text-align: center"> </th>
      <th style="text-align: center"> </th>
      <th style="text-align: center"> </th>
      <th style="text-align: center"> </th>
      <th style="text-align: center"> </th>
      <th style="text-align: center"> </th>
      <th style="text-align: center"> </th>
      <th> </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left">노드</td>
      <td style="text-align: center">$1$</td>
      <td style="text-align: center">$2$</td>
      <td style="text-align: center">$3$</td>
      <td style="text-align: center">$4$</td>
      <td style="text-align: center">$5$</td>
      <td style="text-align: center">$6$</td>
      <td style="text-align: center">$7$</td>
      <td style="text-align: center">$8$</td>
      <td style="text-align: center">$9$</td>
      <td style="text-align: center">$10$</td>
      <td style="text-align: center">$11$</td>
      <td style="text-align: center">$12$</td>
      <td style="text-align: center">$13$</td>
      <td style="text-align: center">$14$</td>
      <td>$15$</td>
    </tr>
    <tr>
      <td style="text-align: left">데이터</td>
      <td style="text-align: center">$A$</td>
      <td style="text-align: center">$B$</td>
      <td style="text-align: center">$C$</td>
      <td style="text-align: center">$D$</td>
      <td style="text-align: center">$E$</td>
      <td style="text-align: center">$null$</td>
      <td style="text-align: center">$F$</td>
      <td style="text-align: center">$null$</td>
      <td style="text-align: center">$null$</td>
      <td style="text-align: center">$null$</td>
      <td style="text-align: center">$null$</td>
      <td style="text-align: center">$null$</td>
      <td style="text-align: center">$null$</td>
      <td style="text-align: center">$null$</td>
      <td>$null$</td>
    </tr>
  </tbody>
</table>

<p><br /></p>

<details>
<summary>[자세히] 중위순회 과정</summary>
<div>

    <ol>
      <li>루트노드 $1$ 방문</li>
      <li>노드 $1$의 왼쪽 자식노드 $2$탐색 - 데이터 존재 확인 및 방문</li>
      <li>노드 $2$의 왼쪽 자식노드 $4$탐색 - 데이터 존재 확인 및 방문</li>
      <li>노드 $4$의 왼쪽 자식노드 $8$ 탐색 - 데이터 없음을 확인</li>
      <li>노드 $4$의 데이터 $D$ 읽기
        <ul>
          <li>$D$</li>
        </ul>
      </li>
      <li>노드 $4$의 오른쪽 자식노드 $9$ 탐색 - 데이터 없음을 확인</li>
      <li>노드 $4$의 부모노드 $2$로 백트래킹 - 노드 $2$의 데이터 $B$ 읽기
        <ul>
          <li>$D - B$</li>
        </ul>
      </li>
      <li>노드 $2$의 오른쪽 자식노드 $5$ 탐색 - 데이터 존재 확인 및 방문</li>
      <li>노드 $5$의 왼쪽 자식노드 $10$ 탐색 - 데이터 없음을 확인</li>
      <li>노드 $5$의 데이터 $E$ 읽기
        <ul>
          <li>$D - B - E$</li>
        </ul>
      </li>
      <li>노드 $5$의 오른쪽 자식노드 $11$ 탐색 - 데이터 없음을 확인</li>
      <li>노드 $5$의 부모노드 $2$로 백트래킹</li>
      <li>노드 $2$의 부모노드 $1$로 백트래킹 - 노드 $1$의 데이터 $A$ 읽기
        <ul>
          <li>$D - B - E - A$</li>
        </ul>
      </li>
      <li>노드 $1$의 오른쪽 자식노드 $3$ 탐색 - 데이터 존재 확인 및 방문</li>
      <li>노드 $3$의 왼쪽 자식노드 $6$ 탐색 - 데이터 없음을 확인</li>
      <li>노드 $3$의 데이터 $C$ 읽기
        <ul>
          <li>$D - B - E - A - C$</li>
        </ul>
      </li>
      <li>노드 $3$의 오른쪽 자식노드 $7$ 탐색 - 데이터 존재 확인 및 방문</li>
      <li>노드 $7$의 왼쪽 자식노드 $14$ 탐색 - 데이터 없음을 확인</li>
      <li>노드 $7$의 데이터 $F$ 읽기
        <ul>
          <li>$D - B - E - A - C - F$</li>
        </ul>
      </li>
      <li>노드 $7$의 오른쪽 자식노드 $15$ 탐색 - 데이터 없음을 확인</li>
      <li>노드 $7$의 부모노드 $3$으로 백트래킹</li>
      <li>노드 $3$의 부모노드 $1$으로 백트래킹</li>
      <li>순회종료</li>
    </ol>

  </div>
</details>

<blockquote>
  <p>중위순회 결과는 $D - B - E - A - C - F$이다.</p>
</blockquote>

<p><br /></p>

<h2 id="정의--후위순회-postorder-traversal">정의 : 후위순회 (postorder traversal)</h2>

<blockquote>
  <p>왼쪽 자식노드 - 오른쪽 자식노드 - 부모노드 순으로 탐색하는 순회 방식</p>
</blockquote>

<h3 id="예시-2">예시</h3>

<p><img src="/assets/images/Math/dm/dm_example_23_01.png" width="400" /></p>

<p><br /></p>

<table>
  <thead>
    <tr>
      <th style="text-align: left"> </th>
      <th style="text-align: center"> </th>
      <th style="text-align: center"> </th>
      <th style="text-align: center"> </th>
      <th style="text-align: center"> </th>
      <th style="text-align: center"> </th>
      <th style="text-align: center"> </th>
      <th style="text-align: center"> </th>
      <th style="text-align: center"> </th>
      <th style="text-align: center"> </th>
      <th style="text-align: center"> </th>
      <th style="text-align: center"> </th>
      <th style="text-align: center"> </th>
      <th style="text-align: center"> </th>
      <th style="text-align: center"> </th>
      <th> </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left">노드</td>
      <td style="text-align: center">$1$</td>
      <td style="text-align: center">$2$</td>
      <td style="text-align: center">$3$</td>
      <td style="text-align: center">$4$</td>
      <td style="text-align: center">$5$</td>
      <td style="text-align: center">$6$</td>
      <td style="text-align: center">$7$</td>
      <td style="text-align: center">$8$</td>
      <td style="text-align: center">$9$</td>
      <td style="text-align: center">$10$</td>
      <td style="text-align: center">$11$</td>
      <td style="text-align: center">$12$</td>
      <td style="text-align: center">$13$</td>
      <td style="text-align: center">$14$</td>
      <td>$15$</td>
    </tr>
    <tr>
      <td style="text-align: left">데이터</td>
      <td style="text-align: center">$A$</td>
      <td style="text-align: center">$B$</td>
      <td style="text-align: center">$C$</td>
      <td style="text-align: center">$D$</td>
      <td style="text-align: center">$E$</td>
      <td style="text-align: center">$null$</td>
      <td style="text-align: center">$F$</td>
      <td style="text-align: center">$null$</td>
      <td style="text-align: center">$null$</td>
      <td style="text-align: center">$null$</td>
      <td style="text-align: center">$null$</td>
      <td style="text-align: center">$null$</td>
      <td style="text-align: center">$null$</td>
      <td style="text-align: center">$null$</td>
      <td>$null$</td>
    </tr>
  </tbody>
</table>

<p><br /></p>

<details>
<summary>[자세히] 후위순회 과정</summary>
<div>

    <ol>
      <li>루트노드 $1$ 방문</li>
      <li>노드 $1$의 왼쪽 자식노드 $2$탐색 - 데이터 존재 확인 및 방문</li>
      <li>노드 $2$의 왼쪽 자식노드 $4$탐색 - 데이터 존재 확인 및 방문</li>
      <li>노드 $4$의 왼쪽 자식노드 $8$ 탐색 - 데이터 없음을 확인</li>
      <li>노드 $4$의 오른쪽 자식노드 $9$ 탐색 - 데이터 없음을 확인</li>
      <li>노드 $4$의 데이터 읽기
        <ul>
          <li>$D$</li>
        </ul>
      </li>
      <li>노드 $4$의 부모노드 $2$로 백트래킹</li>
      <li>노드 $2$의 오른쪽 자식노드 $5$ 탐색 - 데이터 존재 확인 및 방문</li>
      <li>노드 $5$의 왼쪽 자식노드 $10$ 탐색 - 데이터 없음을 확인</li>
      <li>노드 $5$의 오른쪽 자식노드 $11$ 탐색 - 데이터 없음을 확인</li>
      <li>노드 $5$의 데이터 읽기
        <ul>
          <li>$D - E$</li>
        </ul>
      </li>
      <li>노드 $5$의 부모노드 $2$로 백트래킹 - 노드 $2$의 데이터 $B$ 읽기
        <ul>
          <li>$D - E - B$</li>
        </ul>
      </li>
      <li>노드 $2$의 부모노드 $1$로 백트래킹</li>
      <li>노드 $1$의 오른쪽 자식노드 $3$ 탐색 - 데이터 존재 확인 및 방문</li>
      <li>노드 $3$의 왼쪽 자식노드 $6$ 탐색 - 데이터 없음을 확인</li>
      <li>노드 $3$의 오른쪽 자식노드 $7$ 탐색 - 데이터 존재 확인 및 방문</li>
      <li>노드 $7$의 왼쪽 자식노드 $14$ 탐색 - 데이터 없음을 확인</li>
      <li>노드 $7$의 오른쪽 자식노드 $15$ 탐색 - 데이터 없음을 확인</li>
      <li>노드 $7$의 데이터 읽기
        <ul>
          <li>$D - E - B - F$</li>
        </ul>
      </li>
      <li>노드 $7$의 부모노드 $3$으로 백트래킹 - 노드 $3$의 데이터 $C$ 읽기
        <ul>
          <li>$D - E - B - F - C$</li>
        </ul>
      </li>
      <li>노드 $3$의 부모노드 $1$으로 백트래킹 - 노드 $1$의 데이터 $A$ 읽기
        <ul>
          <li>$D - E - B - F - C - A$</li>
        </ul>
      </li>
      <li>순회종료</li>
    </ol>

  </div>
</details>

<blockquote>
  <p>후위순회 결과는 $D - E - B - F - C - A$이다.</p>
</blockquote>

<p><br /></p>

<h2 id="순회를-이용한-수식-표현">순회를 이용한 수식 표현</h2>

<ul>
  <li>
    <p>트리의 순회는 컴퓨터에서 수식을 표기하고 이해하는 데 활용되기도 한다.</p>
  </li>
  <li>
    <p>수식 $(a + b) \times (c - d)$ 는 다음과 같은 순서로 수행한다.</p>

    <ol>
      <li>
        <p>변수 $a, b, c, d$에 값을 입력</p>
      </li>
      <li>
        <p>$a + b$ 를 계산</p>
      </li>
      <li>
        <p>$c - d$ 를 계산</p>
      </li>
      <li>
        <p>$(a + b) \times (c - d)$ 를 계산</p>
      </li>
    </ol>
  </li>
  <li>
    <p>수식을 이진트리로 표현할 때는 가장 먼저 수행하는 작업을 리프노드에 위치, 가장 마지막은 루트노드에 위치시킨다.</p>
  </li>
  <li>
    <p>위 순서와 같이 이진트리를 표현하면 다음 그림과 같다.</p>

    <p><img src="/assets/images/Math/dm/dm_example_23_02.png" width="300" /></p>
  </li>
</ul>

<p><br /></p>

<ul>
  <li>
    <p>트리로 표현된 연산식을 전위순회, 중위순회, 후위순회의 방식으로 읽어낼 수 있다.</p>

    <ul>
      <li>
        <p>전위순회 : $\times \ + \ a \ \ b \ - \ c \ \ d \ $</p>
      </li>
      <li>
        <p>중위순회 : $a \  + \  b \  \times \  c \  - \  d \ $</p>
      </li>
      <li>
        <p>후위순회 : $a \ \   b \  + \  c \ \   d \  - \  \times \ $</p>
      </li>
    </ul>
  </li>
</ul>]]></content><author><name>지지형</name></author><category term="Discrete Mathematics" /><summary type="html"><![CDATA[이진트리의 순회]]></summary></entry><entry><title type="html">[이산수학] 트리(Tree) : 03. 이진트리 구현</title><link href="http://localhost:4000/discrete%20mathematics/DM-22/" rel="alternate" type="text/html" title="[이산수학] 트리(Tree) : 03. 이진트리 구현" /><published>2024-02-09T00:00:00+09:00</published><updated>2024-02-10T00:00:00+09:00</updated><id>http://localhost:4000/discrete%20mathematics/DM-22</id><content type="html" xml:base="http://localhost:4000/discrete%20mathematics/DM-22/"><![CDATA[<h1 id="이진트리의-구현">이진트리의 구현</h1>

<ul>
  <li>그래프 형태로 구현하여 확인할 수 있는 이진트리는 연산을 하거나 시스템으로 구현하기 위해 배열이나 연결리스트와 같은 자료 구조 형태로 표현하기도 한다.</li>
</ul>

<h2 id="배열로-구현한-이진트리">배열로 구현한 이진트리</h2>

<ul>
  <li>높이가 $h$인 완전이진트리는 다음 전제에 따라 1차원 배열로 구현할 수 있다.</li>
</ul>

<blockquote>
  <ol>
    <li>루트노드의 인덱스를 1로 하여 각 노드에 인덱스 번호를 부여한다.</li>
    <li>형제노드 중 왼쪽 노드의 인덱스 번호가 오른쪽 노드보다 앞선다.</li>
  </ol>
</blockquote>

<ul>
  <li>일반적으로 자료구조에서 배열의 인덱스는 0부터 시작이지만,<br />
루트노드의 인덱스는 1이므로 배열에서 인덱스가 0인 자리는 빈자리가 된다.</li>
</ul>

<p><img src="/assets/images/Math/dm/dm_example_22_01.png" width="600" /></p>

<p><br /></p>

<h2 id="정리--노드의-인덱스-index">정리 : 노드의 인덱스 (index)</h2>

<blockquote>
  <ol>
    <li>부모노드의 인덱스가 $n$일 때, 왼쪽 자식노드의 인덱스 : $2n$<br />
$\qquad \qquad \qquad \qquad \qquad \ $오른쪽 자식노드의 인덱스 : $2n + 1$</li>
    <li>자식노드의 인덱스가 $n$일 때, 부모노드의 인덱스 : $\lfloor \ {n \over 2} \ \rfloor$</li>
  </ol>
</blockquote>

<h3 id="예시">예시</h3>

<ul>
  <li>
    <p>정리의 규칙을 이용하면 부모노드나 자식노드의 인덱스를 이용하여 목적하는 노드를 탐색할 수 있다.</p>
  </li>
  <li>
    <p>노드 $B$의 자식노드 탐색</p>

    <ol>
      <li>
        <p>노드 $B$의 인덱스 : $2$</p>
      </li>
      <li>
        <p>노드 $B$의 왼쪽 자식노드의 인덱스 : $2 \times 2 = 4 \ \rightarrow \ D$</p>
      </li>
      <li>
        <p>노드 $B$의 오른쪽 자식노드의 인덱스 : $2 \times 2 + 1 = 5 \ \rightarrow \ E$</p>
      </li>
    </ol>
  </li>
</ul>

<p><br /></p>

<ul>
  <li>
    <p>노드 $G$의 부모노드 인덱스 탐색</p>

    <ol>
      <li>
        <p>노드 $G$의 인덱스 : $7$</p>
      </li>
      <li>
        <p>노드 $G$의 부모노드의 인덱스 : $\lfloor$ ${7 \over 2}$ $\rfloor$ $= 3 \ \rightarrow \ C$</p>
      </li>
    </ol>
  </li>
</ul>

<p><br /></p>

<h2 id="연결리스트로-구현한-이진트리">연결리스트로 구현한 이진트리</h2>

<ul>
  <li>
    <p>부모노드와 자식노드를 포인터로 연결하여 구현하는 것이 이진트리에 대한 <strong>연결리스트</strong>이다.</p>
  </li>
  <li>
    <p>연결리스트를 이용해 이진트리를 구현하면 연속된 메모리 영역에 저장되지 않아도 포인터를 이용해 노드를 연결할 수 있어 배열에서 발생하는 메모리 낭비 문제를 해결할 수 있다.</p>
  </li>
  <li>
    <p>또한 노드의 삽입과 삭제의 경우에도 각 노드의 포인터 정보만 변경하면 되므로 삽입 또는 삭제의 과정이 간단한다.</p>
  </li>
</ul>

<blockquote>
  <p>그러므로 트리를 배열로 구현하는 방법보다 연결리스트로 구현하는 방법을 더 효율적으로 평가한다.</p>
</blockquote>

<p><br /></p>

<h2 id="연결리스트-노드-구성">연결리스트 노드 구성</h2>

<p><img src="/assets/images/Math/dm/dm_example_22_02.png" width="600" /></p>

<ul>
  <li>연결리스트의 노드에서 더 이상 자식노드를 갖지 않을 때는 포인터 영역에 null이 입력된다.</li>
</ul>

<p><br /></p>

<h3 id="예시--완전이진트리-연결리스트">예시 : 완전이진트리 (연결리스트)</h3>

<p><img src="/assets/images/Math/dm/dm_example_22_03.png" width="600" /></p>

<p><br /></p>

<h3 id="예시--편향이진트리-연결리스트">예시 : 편향이진트리 (연결리스트)</h3>

<p><img src="/assets/images/Math/dm/dm_example_22_04.png" width="600" /></p>]]></content><author><name>지지형</name></author><category term="Discrete Mathematics" /><summary type="html"><![CDATA[이진트리의 구현]]></summary></entry></feed>