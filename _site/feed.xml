<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.9.3">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2023-12-14T00:41:56+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">느려도 괜찮아</title><author><name>지지형</name></author><entry><title type="html">[이산수학] 행렬(Matrix) : 05_역행렬</title><link href="http://localhost:4000/discrete%20mathematics/DM-10/" rel="alternate" type="text/html" title="[이산수학] 행렬(Matrix) : 05_역행렬" /><published>2023-12-12T00:00:00+09:00</published><updated>2023-12-12T00:00:00+09:00</updated><id>http://localhost:4000/discrete%20mathematics/DM-10</id><content type="html" xml:base="http://localhost:4000/discrete%20mathematics/DM-10/"><![CDATA[<h1 id="역행렬">역행렬</h1>

<ul>
  <li>행렬에서도 항등원과 역원의 역할을 하는 행렬이 있다.
    <blockquote>
      <p>항등원인 행렬은 <strong>단위행렬 $I$</strong></p>
    </blockquote>

    <blockquote>
      <p>역원인 행렬은 <strong>역행렬</strong></p>
    </blockquote>
  </li>
</ul>

<h2 id="정의--역행렬-inverse-matrix--a-1">정의 : 역행렬 (inverse matrix : $A^{-1}$)</h2>
<blockquote>
  <p>정사각행렬 $A$ 에 대하여, $AB = BA = I$ 를 만족시키는 행렬 B</p>
  <ul>
    <li>$AA^{-1} = A^{-1}A = I$</li>
  </ul>
</blockquote>

<h3 id="예시">예시</h3>

<ul>
  <li>
    <p>$A = $
$\begin{bmatrix}
1 &amp; 2 \\<br />
1 &amp; 3
\end{bmatrix} \quad$
$B = $
$\begin{bmatrix}
3 &amp; -2 \\<br />
-1 &amp; 1
\end{bmatrix}$</p>
  </li>
  <li>
    <p>$AB = $
$\begin{bmatrix}
1 \times 3 + 2 \times (-1) &amp; 1 \times (-2) + 2 \times 1 \\<br />
1 \times 3 + 3 \times (-1) &amp; 1 \times (-2) + 3 \times 1
\end{bmatrix} = $
$\begin{bmatrix}
1 &amp; 0 \\<br />
0 &amp; 1
\end{bmatrix}$</p>
  </li>
  <li>
    <p>$BA = $
$\begin{bmatrix}
3 \times 1 + (-2) \times 1 &amp; 3 \times 2 + (-2) \times 3 \\<br />
1 \times 3 + 3 \times (-1) &amp; 1 \times (-2) + 3 \times 1
\end{bmatrix} = $
$\begin{bmatrix}
1 &amp; 0 \\<br />
0 &amp; 1
\end{bmatrix}$</p>
  </li>
</ul>

<h2 id="정의--행렬식을-이용한-역행렬">정의 : 행렬식을 이용한 역행렬</h2>

<blockquote>
  <p>$A^{-1} = {1 \over det(A)}$ $[A_{ij}]^{T}$ (단, $det(A) \neq 0 $)</p>
</blockquote>

<h2 id="정의--수반행렬-adjoint-matrix--a_ijt">정의 : 수반행렬 (adjoint matrix : $[A_{ij}]^{T}$)</h2>

<blockquote>
  <p>여인수행렬 $[A_{ij}]$ 의 전치행렬</p>
</blockquote>

<ul>
  <li>여인수를 이용한 행렬식과 수반행렬을 이용하면 정사각행렬의 크기가 무엇이든 상관없이 행렬의 역행렬을 구할 수 있다.</li>
</ul>

<h3 id="예시-1">예시</h3>

<p>행렬 $A =$
$\begin{bmatrix}
-2 &amp; 2 &amp; -3 \\<br />
1 &amp; 0 &amp; 1 \\<br />
-4 &amp; 3 &amp; -5
\end{bmatrix}$ 의 역행렬은 구하는 방식은 다음과 같다.</p>

<p>$[A_{ij}] = $
$\begin{bmatrix}
-3 &amp; 1 &amp; 3 \\<br />
1 &amp; -2 &amp; -2 \\<br />
2 &amp; -1 &amp; -2
\end{bmatrix}$ , $det(A) = -1$</p>

<ul>
  <li>여인수행렬의 행과 열을 바꿔서 수반행렬을 구하면 다음과 같다.</li>
</ul>

<p>$[A_{ij}]^{T} = $
$\begin{bmatrix}
-3 &amp; 1 &amp; 2 \\<br />
1 &amp; -2 &amp; -1 \\<br />
3 &amp; -2 &amp; -2
\end{bmatrix}$</p>

<p>$A^{-1} = (-1)$ $\times$
$\begin{bmatrix}
-3 &amp; 1 &amp; 2 \\<br />
1 &amp; -2 &amp; -1 \\<br />
3 &amp; -2 &amp; -2
\end{bmatrix} = $
$\begin{bmatrix}
3 &amp; -1 &amp; -2 \\<br />
-1 &amp; 2 &amp; 1 \\<br />
-3 &amp; 2 &amp; 2
\end{bmatrix}$</p>

<h2 id="정의--가역행렬-invertible-matrix">정의 : 가역행렬 (invertible matrix)</h2>

<blockquote>
  <p>역행렬이 존재하는 행렬, $det(A) \neq 0$ 인 행렬</p>
</blockquote>

<h2 id="정의--특이행렬-singular-matrix">정의 : 특이행렬 (singular matrix)</h2>

<blockquote>
  <p>역행렬이 존재하지 않는 행렬, $det(A) = 0$ 인 행렬</p>
</blockquote>

<h3 id="예시-2">예시</h3>

<ul>
  <li>
    <p>특이행렬</p>

    <p>$[A_{ij}] = $
  $\begin{bmatrix}
  1 &amp; 2 &amp; 3 \\<br />
  4 &amp; 5 &amp; 6 \\<br />
  7 &amp; 8 &amp; 9
  \end{bmatrix}$ , $det(A) = 0$</p>

    <ul>
      <li>
        <p>위 행렬 $A$ 의 행렬식은 0이므로 역행렬을 구할 수 없다.</p>
      </li>
      <li>
        <p>그러므로 행렬 $A$ 는 특이행렬이다.</p>
      </li>
    </ul>
  </li>
</ul>

<p><br /><br /></p>

<h1 id="참고-문헌">참고 문헌</h1>
<ul>
  <li>박주미, ⌜컴퓨팅 사고력을 키우는 이산 수학수학 3판⌟ , 2023 , 한빛아카데미 , p231 ~ p233</li>
</ul>]]></content><author><name>지지형</name></author><category term="Discrete Mathematics" /><summary type="html"><![CDATA[역행렬]]></summary></entry><entry><title type="html">[이산수학] 행렬(Matrix) : 04_행렬식</title><link href="http://localhost:4000/discrete%20mathematics/DM-09/" rel="alternate" type="text/html" title="[이산수학] 행렬(Matrix) : 04_행렬식" /><published>2023-12-01T00:00:00+09:00</published><updated>2023-12-01T00:00:00+09:00</updated><id>http://localhost:4000/discrete%20mathematics/DM-09</id><content type="html" xml:base="http://localhost:4000/discrete%20mathematics/DM-09/"><![CDATA[<h1 id="행렬식">행렬식</h1>

<ul>
  <li>하나 이상의 수로 구성된 $n$ 차 정사각행렬에는 행렬를 대표하는 수를 대응할 수 있는데, 그 수를 구하는 식을 <strong>행렬식</strong>이라고한다.</li>
  <li>역행렬 존재 유무 판별</li>
  <li>연립일차방정식의 해가 유일하게 존재하는지 판단</li>
</ul>

<h2 id="정의">정의</h2>
<blockquote>
  <p>$n$ 차 정사각행렬에 대응하는 수를 구하는 식</p>
</blockquote>

<ul>
  <li>$det(A) = |A| = $
$\begin{bmatrix}
a_{11} &amp; a_{11} &amp; \cdots &amp; a_{1n} \\<br />
a_{21} &amp; a_{22} &amp; \cdots &amp; a_{2n} \\<br />
\cdots &amp; \cdots &amp; \cdots &amp; \cdots \\<br />
a_{n1} &amp; a_{n2} &amp; \cdots &amp; a_{nn}
\end{bmatrix}$</li>
</ul>

<h1 id="2차-3차-정사각행렬의-기본-행렬식">2차, 3차 정사각행렬의 기본 행렬식</h1>

<h2 id="정의-1">정의</h2>

<ul>
  <li>
    <p>2차 정사각행렬 $A =$ 
$\begin{bmatrix}
a_{11} &amp; a_{12}\\<br />
a_{21} &amp; a_{22}
\end{bmatrix}$ 의 행렬식</p>

    <ul>
      <li>$det(A) = $
  $\begin{bmatrix}
  \color{Red}{a_{11}} &amp; \color{Blue}{a_{12}}\\<br />
  \color{Blue}{a_{21}} &amp; \color{Red}{a_{22}}
  \end{bmatrix} = a_{11}a_{22} - a_{12}a_{21}$</li>
    </ul>
  </li>
</ul>

<p><br /></p>

<ul>
  <li>
    <p>3차 정사각행렬 $B = $
$\begin{bmatrix}
b_{11} &amp; b_{12} &amp; b_{13} \\<br />
b_{21} &amp; b_{22} &amp; b_{23} \\<br />
b_{31} &amp; b_{32} &amp; b_{33}
\end{bmatrix}$ 의 행렬식</p>

    <ul>
      <li>$det(B) = $
  $(b_{11}b_{22}b_{33} + b_{12}b_{23}b_{31} + b_{13}b_{21}b_{32}) - (b_{13}b_{22}b_{31} + b_{11}b_{23}b_{32} + b_{12}b_{21}b_{33})$</li>
    </ul>

    <p><img src="/assets/images/Math/dm/dm_example_9_1.png" width="500" /></p>
  </li>
</ul>

<h1 id="3차-이상인-정사각행렬의-행렬식">3차 이상인 정사각행렬의 행렬식</h1>

<ul>
  <li>행렬식을 구하는 다른 방법은 <strong>여인수</strong>라는 개념을 이용하는 것이다.</li>
  <li><strong>여인수</strong>는 행렬의 소행렬을 이용하여 구할 수 있다.</li>
</ul>

<h2 id="소행렬-minor-matrix--m_ij">소행렬 (minor matrix : $M_{ij}$)</h2>

<h3 id="정의-2">정의</h3>

<blockquote>
  <p>$n$ 차 정사각행렬에서 $i$ 행과 $j$ 열을 제거해서 얻은 $(n-1)\times(n-1)$ 행렬</p>
</blockquote>

<h4 id="예시-1">예시 1</h4>

<ul>
  <li>
    <p>행렬 $A = $
$\begin{bmatrix}
1 &amp; 2 &amp; 3 \\<br />
4 &amp; 5 &amp; 6 \\<br />
7 &amp; 8 &amp; 9
\end{bmatrix}$ 이 있다.</p>
  </li>
  <li>
    <p>행렬 $A$ 에서 구할 수 있는 소행렬은 $M_{11},M_{12},M_{13} \cdots , M_{32},M_{33}이 있다.$</p>
  </li>
  <li>
    <p>소행렬 $M_{11}$ 은 1행과 1열을 제외한 나머지 부분이다.</p>
  </li>
  <li>
    <p>$\begin{bmatrix}
5 &amp; 6 \\<br />
8 &amp; 9
\end{bmatrix}$</p>
  </li>
  <li>
    <p>소행렬 $M_{32}$ 은 3행과 2열을 제외한 나머지 부분이다.</p>
  </li>
  <li>
    <p>$\begin{bmatrix}
1 &amp; 3 \\<br />
4 &amp; 6 
\end{bmatrix}$</p>
  </li>
</ul>

<h2 id="소행렬식-minor-determinant--detm_ij">소행렬식 (minor determinant : $det(M_{ij})$)</h2>

<h3 id="정의-3">정의</h3>

<blockquote>
  <p>$n$ 차 정사각행렬의 소행렬 $M_{ij}$ 의 행렬식</p>
</blockquote>

<h4 id="예시-2">예시 2</h4>

<ul>
  <li>
    <p>위 예시1 에서 구한 소행렬로 행렬식을 구할 수 있다.</p>
  </li>
  <li>
    <p>$det(M_{11}) = $
$\begin{bmatrix}
5 &amp; 6 \\<br />
8 &amp; 9
\end{bmatrix} = (5 \times 9) - (6 \times 8) = -3$</p>
  </li>
  <li>
    <p>$det(M_{32}) = $
$\begin{bmatrix}
1 &amp; 3 \\<br />
4 &amp; 6 
\end{bmatrix} = (1 \times 6) - (3 \times 4) = -6$</p>
  </li>
</ul>

<h2 id="여인수-cofactor--a_ij-와-여인수-행렬cofactor-matrix--a_ij">여인수 (cofactor : $A_{ij}$) 와 여인수 행렬(cofactor matrix : $[A_{ij}]$)</h2>

<h3 id="정의-4">정의</h3>
<blockquote>
  <p>$n$ 차 정사각행렬 $A = [a_{ij}]$ 에서 원소 $a_{ij}$ 에 관한 계수와 그 계수를 원소로 갖는 행렬</p>
</blockquote>

<ul>
  <li>
    <p>$A_{ij} = (-1)^{i+j}det(M_{ij})$</p>
  </li>
  <li>
    <p>여인수 구하는 공식에서 알 수 있듯이, 여인수는 각 행렬의 소행렬식 $det(M_{ij})$ 와 각 원소의 위치에 따른 부호 $(-1)^{i+j}$ 에 의해 결정된다.</p>
  </li>
  <li>
    <p>여인수행렬에서 각 원소의 위치에 따른 원소의 부호는 다음과 같다.</p>

    <p>$\begin{bmatrix}
      + &amp; - &amp; + &amp; - &amp; \cdots \\<br />
      - &amp; + &amp; - &amp; + &amp; \cdots \\<br />
      + &amp; - &amp; + &amp; - &amp; \cdots \\<br />
      - &amp; + &amp; - &amp; + &amp; \cdots \\ 
      \cdots  &amp; \cdots  &amp; \cdots  &amp; \cdots &amp; \cdots 
      \end{bmatrix}$</p>
  </li>
</ul>

<h3 id="예시-3">예시 3</h3>

<ul>
  <li>
    <p>행렬 $A = $
$\begin{bmatrix}
1 &amp; 2 &amp; 3 &amp; 4 \\<br />
5 &amp; 6 &amp; 7 &amp; 8 \\<br />
9 &amp; 10 &amp; 11 &amp; 12 \\<br />
13 &amp; 14 &amp; 15 &amp; 16
\end{bmatrix}$ 이 있다.</p>
  </li>
  <li>$a_{33}$ 의 여인수
    <ul>
      <li>여인수 $A_{33}$ 의 부호는 $(-1)^{3+3}$ 이 되어 양수$(+)$</li>
      <li>$A_{33} = (-1)^{3+3}det(M_{33}) = det(M_{33})$</li>
    </ul>
  </li>
  <li>$a_{43}$ 의 여인수
    <ul>
      <li>여인수 $A_{43}$ 의 부호는 $(-1)^{4+3}$ 이 되어 음수$(-)$</li>
      <li>$A_{43} = (-1)^{4+3}det(M_{43}) = -det(M_{43})$</li>
    </ul>
  </li>
</ul>

<p><br /><br /></p>

<ul>
  <li>
    <p>행렬 $B = $ 
$\begin{bmatrix}
1 &amp; 2 &amp; 3 \\<br />
4 &amp; 5 &amp; 6 \\<br />
7 &amp; 8 &amp; 9
\end{bmatrix}$ 의 여인수 행렬</p>
  </li>
  <li>
    <p>$[A_{ij}] = $
$\begin{bmatrix}
-3 &amp; 6 &amp; -3 \\<br />
6 &amp; -12 &amp; 6 \\<br />
-3 &amp; 6 &amp; -3
\end{bmatrix}$</p>
  </li>
</ul>

<h2 id="여인수를-이용한-행렬식">여인수를 이용한 행렬식</h2>

<h3 id="정의-5">정의</h3>
<blockquote>
  <p>$n \ge 3 $ 인 $n$ 차 정사각행렬 $A$ 의 행렬식은 다음과 같다.</p>
</blockquote>

<ul>
  <li>
    <p>$det(A) = a_{i1}A_{i1} + a_{i2}A_{i2} + \cdots + a_{in}A_{in}$ : $i$ 행을 선택한 경우</p>
  </li>
  <li>
    <p>$det(A) = a_{1j}A_{1j} + a_{2j}A_{2j} + \cdots + a_{nj}A_{nj}$ : $j$ 열을 선택한 경우</p>
  </li>
  <li>
    <p>여인수를 이용하여 행렬식을 구할 때는 행렬의 한 행 또는 한 열을 선택하고, 그 행이나 열을 구성하는 각 원소와 그 원소에 대응되는 여인수를 곱한 다음 더하여 행렬식을 구한다.</p>
  </li>
  <li>
    <p>이때 어떤 행 또는 열을 선택하더라도 행렬식의 결과는 같으므로 연산하기 쉬운 행이나 열을 선택한다.</p>
  </li>
</ul>

<h3 id="예시-4">예시 4</h3>

<ul>
  <li>
    <p>위 예시 3의 행렬 $B$ 의 여인수 행렬을 이용하여 행렬식을 구할 수 있다.</p>
  </li>
  <li>
    <p>행렬 $B = $ 
$\begin{bmatrix}
1 &amp; 2 &amp; 3 \\<br />
4 &amp; 5 &amp; 6 \\<br />
7 &amp; 8 &amp; 9
\end{bmatrix}$ 의 여인수 행렬</p>
  </li>
  <li>
    <p>$[A_{ij}] = $
$\begin{bmatrix}
-3 &amp; 6 &amp; -3 \\<br />
6 &amp; -12 &amp; 6 \\<br />
-3 &amp; 6 &amp; -3
\end{bmatrix}$</p>
  </li>
</ul>

<ol>
  <li>
    <p>비교적 숫자가 작은 1행을 선택하여 행렬식 구하기</p>

    <ul>
      <li>$det(B)$<br />
  $= b_{11}A_{11} + b_{12}A_{12} + b_{13}A_{13}$<br />
  $= (1 \times -3) + (2 \times 6) + (3 \times -3)$<br />
  $= 0$</li>
    </ul>
  </li>
  <li>
    <p>1열을 선택하여 행렬식 구하기</p>
    <ul>
      <li>$det(B)$<br />
  $= b_{11}A_{11} + b_{21}A_{21} + b_{31}A_{31}$<br />
  $= (1 \times -3) + (4 \times 6) + (7 \times -3)$<br />
  $= 0$</li>
    </ul>
  </li>
</ol>

<p><br /><br /></p>

<h1 id="참고-문헌">참고 문헌</h1>
<ul>
  <li>박주미, ⌜컴퓨팅 사고력을 키우는 이산 수학수학 3판⌟ , 2023 , 한빛아카데미 , p220 ~ p230</li>
</ul>]]></content><author><name>지지형</name></author><category term="Discrete Mathematics" /><summary type="html"><![CDATA[행렬식]]></summary></entry><entry><title type="html">[이산수학] 행렬(Matrix) : 03_행렬의 종류</title><link href="http://localhost:4000/discrete%20mathematics/DM-08/" rel="alternate" type="text/html" title="[이산수학] 행렬(Matrix) : 03_행렬의 종류" /><published>2023-11-27T00:00:00+09:00</published><updated>2023-11-27T00:00:00+09:00</updated><id>http://localhost:4000/discrete%20mathematics/DM-08</id><content type="html" xml:base="http://localhost:4000/discrete%20mathematics/DM-08/"><![CDATA[<h1 id="행렬의-종류">행렬의 종류</h1>

<ul>
  <li>행렬의 형태 혹은 구성 원소에 따라 다양한 종류의 행렬로 나눌 수 있다.</li>
</ul>

<p><br />
<br /></p>

<h1 id="대각행렬-diagonal-matrix">대각행렬 (diagonal matrix)</h1>

<h2 id="정의">정의</h2>
<blockquote>
  <p>$n$ 차 정사각행렬에서 주대각 원소 $a_{11}, a_{22}, \cdots, a_{nn}$ 을 제외한 나머지 원소가 모두 0 인 행렬</p>
</blockquote>

<ul>
  <li>$A =$
$\begin{bmatrix}
a_{11} &amp; 0 &amp; \cdots &amp; 0 \\<br />
0 &amp; a_{22} &amp; \cdots &amp; 0 \\<br />
\cdots &amp; \cdots &amp; \cdots &amp; \cdots \\<br />
0 &amp; 0 &amp; \cdots &amp; a_{nn}
\end{bmatrix}$</li>
</ul>

<h3 id="예시">예시</h3>
<ul>
  <li>
    <p>다음 행렬 $A,B$ 가 있다.</p>
  </li>
  <li>
    <p>$A =$
$\begin{bmatrix}
1 &amp; 2 &amp; 3 \\<br />
4 &amp; 5 &amp; 6
\end{bmatrix}$</p>
  </li>
  <li>
    <p>$B =$
$\begin{bmatrix}
1 &amp; 0 &amp; 0 \\<br />
0 &amp; 2 &amp; 0 \\<br />
0 &amp; 0 &amp; 3
\end{bmatrix}$</p>
  </li>
  <li>
    <p>행렬 $A$ 는 정사각행렬이 아니다. 즉, 행과 열의 크기가 같지 않으므로 대각행렬이 아니다.</p>
  </li>
  <li>
    <p>반면, 행렬 $B$ 는 정사각행렬이고, 주대각 원소 $1, 2, 3$ 을 제외한 원소가 0이므로 대각행렬이다.</p>
  </li>
</ul>

<p><br /></p>

<h1 id="전치행렬-transpose-matrix--at">전치행렬 (transpose matrix : $A^T$)</h1>

<h2 id="정의-1">정의</h2>

<blockquote>
  <p>$m \times n$ 행렬 $A = [a_{ij}]$ 의 행과 열의 위치를 바꾼 $n \times m$ 행렬</p>
</blockquote>

<ul>
  <li>$A = $
$\begin{bmatrix}
a_{11} &amp; a_{12} &amp; \cdots &amp; a_{1n} \\<br />
a_{21} &amp; a_{22} &amp; \cdots &amp; a_{2n} \\<br />
\cdots &amp; \cdots &amp; \cdots &amp; \cdots \\<br />
a_{m1} a_{m2} &amp; \cdots &amp; a_{mn}
\end{bmatrix} A^T = $
$\begin{bmatrix}
a_{11} &amp; a_{21} &amp; \cdots &amp; a_{m1} \\<br />
a_{12} &amp; a_{22} &amp; \cdots &amp; a_{m2} \\<br />
\cdots &amp; \cdots &amp; \cdots &amp; \cdots \\<br />
a_{1n} &amp; a_{2n} &amp; \cdots &amp; a_{nm}
\end{bmatrix}$</li>
</ul>

<h2 id="예시-1">예시</h2>

<ul>
  <li>
    <p>다음 행렬 $A$ 가 있다.</p>
  </li>
  <li>
    <p>$A =$
$\begin{bmatrix}
1 &amp; 2 &amp; 3 \\<br />
4 &amp; 5 &amp; 6
\end{bmatrix}$</p>
  </li>
  <li>
    <p>$A^T =$
$\begin{bmatrix}
1 &amp; 4 \\ 
2 &amp; 5 \\ 
3 &amp; 6
\end{bmatrix}$</p>
  </li>
  <li>
    <p>전치행렬은 행의 원소와 열의 원소의 위치를 바꾼 행렬로 정사각행렬이 아니어도 전치행렬을 구할 수 있다.</p>
  </li>
</ul>

<h1 id="대칭행렬-symmetric-matrix">대칭행렬 (symmetric matrix)</h1>

<h2 id="정의-2">정의</h2>

<blockquote>
  <p>$n$ 차 정사각행렬 $A = [a_{ij}]$ 가 있을 때, $A^T = A$ 인 행렬</p>
</blockquote>

<h2 id="예시-2">예시</h2>

<ul>
  <li>
    <p>$A = A^T$</p>
  </li>
  <li>
    <p>$\begin{bmatrix}
  8 &amp; 1 &amp; 4 \\<br />
  1 &amp; 3 &amp; 7 \\<br />
  4 &amp; 7 &amp; 6
  \end{bmatrix} =  $
  $\begin{bmatrix}
  8 &amp; 1 &amp; 4 \\<br />
  1 &amp; 3 &amp; 7 \\<br />
  4 &amp; 7 &amp; 6
  \end{bmatrix}$</p>
  </li>
  <li>대칭행렬의 경우 원래 행렬과 전치행렬이 같은 형태</li>
  <li>정사각행렬인 경우에만 만들어질 수 있다.</li>
</ul>

<p><br /><br /></p>

<h1 id="부울행렬-boolean-matrix">부울행렬 (Boolean matrix)</h1>

<h2 id="정의-3">정의</h2>
<blockquote>
  <p>행렬의 모든 원소가 부울값 <strong>0</strong>과 <strong>1</strong>로만 구성된 행렬</p>
</blockquote>

<h2 id="부울행렬-연산자">부울행렬 연산자</h2>

<ul>
  <li>부울행렬 $A = [a_{ij}]$ 와 $B = [b_{ij}]$ 에 대하여 다음이 성립한다.</li>
</ul>

<ol>
  <li>
    <p>합(join) : $A \lor B = [a_{ij} \lor b_{ij}]$</p>
  </li>
  <li>
    <p>교차(meet) : $A \land B = [a_{ij} \land b_{ij}]$</p>
  </li>
  <li>
    <p>부울곱(Boolean product) : $A \odot B$</p>

    <ul>
      <li>
        <p>$m \times n$ 부울행렬 $A = [a_{ij}]$ 와 $n \times r$ 부울행렬 $B = [b_{ij}]$ 의 부울곱 결과는 $m \times r $ 부울행렬 $A \odot B = [c_{ij}]$</p>
      </li>
      <li>
        <p>$A \odot B = $
 $\begin{bmatrix}
 a_{11} &amp; a_{12} &amp; \cdots &amp; a_{1n} \\<br />
 a_{21} &amp; a_{22} &amp; \cdots &amp; a_{2n} \\<br />
 \cdots &amp; \cdots &amp; \cdots &amp; \cdots \\<br />
 a_{m1} &amp; a_{m2} &amp; \cdots &amp; a_{mn}
 \end{bmatrix} \times $
 $\begin{bmatrix}
 b_{11} &amp; b_{12} &amp; \cdots &amp; b_{1r} \\<br />
 b_{21} &amp; b_{22} &amp; \cdots &amp; b_{2r} \\<br />
 \cdots &amp; \cdots &amp; \cdots &amp; \cdots \\<br />
 b_{n1} &amp; b_{n2} &amp; \cdots &amp; b_{nr}
 \end{bmatrix} = $
 $\begin{bmatrix}
 c_{11} &amp; c_{12} &amp; \cdots &amp; c_{1r} \\<br />
 c_{21} &amp; c_{22} &amp; \cdots &amp; c_{2r} \\<br />
 \cdots &amp; \cdots &amp; \cdots &amp; \cdots \\<br />
 c_{m1} &amp; c_{m2} &amp; \cdots &amp; c_{mr}
 \end{bmatrix}$</p>
      </li>
    </ul>

    <p>$(c_{ij} = (a_{i1} \land b_{1j}) \lor (a_{i2}\land b_{2j}) \lor \cdots \lor (a_{im} \land b_{mj}))$</p>
  </li>
</ol>

<h3 id="합-연산">합 연산</h3>
<blockquote>
  <p>행렬 $A$ 의 원소 $a_{ij}$ 와 행렬 $B$ 의 원소 $b_{ij}$ 중 하나라도 1 이면 1 이고 그 외의 경우는 0 이다.</p>
</blockquote>

<ul>
  <li>행렬의 연산의 덧셈, 뺄셈 연산처럼 행렬의 크기가 같아야한다.</li>
</ul>

<h4 id="예시-3">예시</h4>

<ul>
  <li>
    <p>다음 부울행렬 $A, B$ 가 있다.</p>
  </li>
  <li>
    <p>$A = $
$\begin{bmatrix}
1 &amp; 0 \\<br />
0 &amp; 1
\end{bmatrix} , B = $
$\begin{bmatrix}
1 &amp; 1 \\<br />
0 &amp; 0
\end{bmatrix}$</p>
  </li>
  <li>
    <p>$A \lor B = $
$\begin{bmatrix}
1 &amp; 0 \\<br />
0 &amp; 1
\end{bmatrix} \lor $
$\begin{bmatrix}
1 &amp; 1 \\<br />
0 &amp; 0
\end{bmatrix} = $
$\begin{bmatrix}
1 \lor 1 &amp; 0 \lor 1 \\<br />
0 \lor 0 &amp; 1 \lor 0
\end{bmatrix} = $
$\begin{bmatrix}
1 &amp; 1 \\<br />
0 &amp; 1
\end{bmatrix}$</p>
  </li>
</ul>

<h3 id="교차-연산">교차 연산</h3>
<blockquote>
  <p>행렬 $A$ 의 원소 $a_{ij}$ 와 행렬 $B$ 의 원소 $b_{ij}$ 가 모두 1 인 경우에만 1 이고 그 외의 경우는 0 이다.</p>
</blockquote>

<ul>
  <li>행렬의 연산의 덧셈, 뺄셈 연산처럼 행렬의 크기가 같아야한다.</li>
</ul>

<h4 id="예시-4">예시</h4>

<ul>
  <li>
    <p>다음 부울행렬 $A, B$ 가 있다.</p>
  </li>
  <li>
    <p>$A = $
$\begin{bmatrix}
1 &amp; 0 \\<br />
0 &amp; 1
\end{bmatrix} , B = $
$\begin{bmatrix}
1 &amp; 1 \\<br />
0 &amp; 0
\end{bmatrix}$</p>
  </li>
  <li>
    <p>$A \land B = $
$\begin{bmatrix}
1 &amp; 0 \\<br />
0 &amp; 1
\end{bmatrix} \land $
$\begin{bmatrix}
1 &amp; 1 \\<br />
0 &amp; 0
\end{bmatrix} = $
$\begin{bmatrix}
1 \land 1 &amp; 0 \land 1 \\<br />
0 \land 0 &amp; 1 \land 0
\end{bmatrix} = $
$\begin{bmatrix}
1 &amp; 0 \\<br />
0 &amp; 0
\end{bmatrix}$</p>
  </li>
</ul>

<h3 id="부울곱-연산">부울곱 연산</h3>

<ul>
  <li>행렬의 곱셈처럼 부울행렬의 크기가 $(m \times n) \times (n \times r)$ 을 성립해야 한다.</li>
</ul>

<h4 id="예시-5">예시</h4>

<ul>
  <li>
    <p>다음 부울행렬 $A, B$ 가 있다.</p>
  </li>
  <li>
    <p>$A = $
$\begin{bmatrix}
1 &amp; 0 \\<br />
0 &amp; 1
\end{bmatrix} , B = $
$\begin{bmatrix}
1 &amp; 1 \\<br />
0 &amp; 0
\end{bmatrix}$</p>
  </li>
  <li>
    <p>$A \odot B = $
$\begin{bmatrix}
1 &amp; 0 \\<br />
0 &amp; 1
\end{bmatrix} \odot $
$\begin{bmatrix}
1 &amp; 1 \\<br />
0 &amp; 0
\end{bmatrix} = $
$\begin{bmatrix}
(1 \land 1) \lor (0 \land 0) &amp; (1 \land 1) \lor (0 \land 0) \\ 
(0 \land 1) \lor (1 \land 0) &amp; (0 \land 1) \lor (1 \land 0)
\end{bmatrix} = $
$\begin{bmatrix}
1 &amp; 1 \\ 
0 &amp; 0
\end{bmatrix}$</p>
  </li>
</ul>

<h2 id="부울행렬-연산의-특징">부울행렬 연산의 특징</h2>

<blockquote>
  <p>부울행렬 $A,B,C$ 에 대하여 다음이 성립한다.</p>
</blockquote>

<ol>
  <li>$A \lor A = A$</li>
  <li>$A \land A = A$</li>
  <li>$A \lor B = B \lor A$</li>
  <li>$A \land B = B \land A$</li>
  <li>$(A \lor B) \lor C = A \lor (B \lor C)$</li>
  <li>$(A \land B) \land C = A \land (B \land C)$</li>
  <li>$(A \odot B) \odot C = A \odot (B \odot C)$</li>
  <li>$(A \lor B) \land C = (A \land C) \lor (B \land C)$</li>
  <li>$(A \land B) \land C = (A \lor C) \land (B \lor C)$</li>
</ol>

<hr />

<h1 id="참고-문헌">참고 문헌</h1>
<ul>
  <li>박주미, ⌜컴퓨팅 사고력을 키우는 이산 수학수학 3판⌟ , 2023 , 한빛아카데미 , p214 ~ p219</li>
</ul>]]></content><author><name>지지형</name></author><category term="Discrete Mathematics" /><summary type="html"><![CDATA[행렬의 종류]]></summary></entry><entry><title type="html">[이산수학] 행렬(Matrix) : 02_행렬의 연산</title><link href="http://localhost:4000/discrete%20mathematics/DM-07/" rel="alternate" type="text/html" title="[이산수학] 행렬(Matrix) : 02_행렬의 연산" /><published>2023-11-24T00:00:00+09:00</published><updated>2023-11-24T00:00:00+09:00</updated><id>http://localhost:4000/discrete%20mathematics/DM-07</id><content type="html" xml:base="http://localhost:4000/discrete%20mathematics/DM-07/"><![CDATA[<h1 id="행렬의-연산">행렬의 연산</h1>

<ul>
  <li>행렬에서 가능한 연산은 덧셈, 곱셈, 스칼라곱, 곱셈이 있다.</li>
</ul>

<p><br />
<br /></p>

<h1 id="행렬의-덧셈과-뺄셈">행렬의 덧셈과 뺄셈</h1>

<blockquote>
  <p>행렬의 덧셈과 뺄셈이 가능하려면 두 행렬의 크기가 같아야 한다.</p>
</blockquote>

<ul>
  <li>두 행렬 $A$ 와 $B$ 는 덧셈과 뺄셈이 가능하다.
    <ul>
      <li>$A = 4 \times 4$</li>
      <li>$B = 4 \times 4$</li>
    </ul>
  </li>
</ul>

<h2 id="정의">정의</h2>
<blockquote>
  <p>두 행렬 크기가 $m \times n$인 두 행렬 $A$, $B$ 에서 <strong>같은 위치</strong>에 있는 원소끼리 더하거나 빼는 연산</p>
</blockquote>

<ul>
  <li>$A =$
$\begin{bmatrix}
a_{11} &amp; a_{12} &amp; \cdots &amp; a_{1n} \\<br />
a_{21} &amp; a_{22} &amp; \cdots &amp; a_{2n} \\<br />
\cdots &amp; \cdots &amp; \cdots &amp; \cdots \\<br />
a_{m1} &amp; a_{m2} &amp; \cdots &amp; a_{mn}
\end{bmatrix}$ $B =$
$\begin{bmatrix}
b_{11} &amp; b_{12} &amp; \cdots &amp; b_{1n} \\<br />
b_{21} &amp; b_{22} &amp; \cdots &amp; b_{2n} \\<br />
\cdots &amp; \cdots &amp; \cdots &amp; \cdots \\<br />
b_{m1} &amp; b_{m2} &amp; \cdots &amp; b_{mn}
\end{bmatrix}$</li>
</ul>

<p><br /></p>

<ul>
  <li>$A + B = $
$\begin{bmatrix}
a_{11} + b_{11} &amp; a_{12} + b_{12} &amp; \cdots &amp; a_{1n} +b_{1n} \\<br />
a_{21} + b_{21} &amp; a_{21} +b_{22} &amp; \cdots &amp; a_{21} +b_{2n} \\<br />
\cdots &amp; \cdots &amp; \cdots &amp; \cdots \\<br />
a_{m1} + b_{m1} &amp; a_{m2} + b_{m2} &amp; \cdots &amp; a_{mn} + b_{mn}
\end{bmatrix}$</li>
</ul>

<p><br /></p>

<ul>
  <li>$A - B = $
$\begin{bmatrix}
a_{11} - b_{11} &amp; a_{12} - b_{12} &amp; \cdots &amp; a_{1n} - b_{1n} \\<br />
a_{21} - b_{21} &amp; a_{21} - b_{22} &amp; \cdots &amp; a_{21} - b_{2n} \\<br />
\cdots &amp; \cdots &amp; \cdots &amp; \cdots \\<br />
a_{m1} - b_{m1} &amp; a_{m2} - b_{m2} &amp; \cdots &amp; a_{mn} - b_{mn}
\end{bmatrix}$</li>
</ul>

<h2 id="행렬의-덧셈과-뺄셈의-특징">행렬의 덧셈과 뺄셈의 특징</h2>

<blockquote>
  <p>다음과 같은 행렬 $A, B, C$ 가 있다.</p>
</blockquote>

<ul>
  <li>
    <p>$A =$
$\begin{bmatrix}
1 &amp; 3  &amp; 5 \\<br />
7 &amp; 9  &amp; 11 \\<br />
13 &amp; 15 &amp; 17
\end{bmatrix}$ $B = $
$\begin{bmatrix}
2 &amp; 4  &amp; 6 \\<br />
8 &amp; 10  &amp; 12 \\<br />
14 &amp; 16 &amp; 18
\end{bmatrix}$ $C = $
$\begin{bmatrix}
3 &amp; 6  &amp; 9 \\  <br />
12 &amp; 15 &amp; 18
\end{bmatrix}$</p>
  </li>
  <li>
    <p>행렬 $A, B, C$ 중 크기가 $3 \times 3$ 인 행렬 $A,B$ 는 덧셈이나 뺄셈이 가능하나, 크기가 $2 \times 3$ 인 $C$ 는 불가능하다.</p>
  </li>
  <li>
    <p>$A + B = $
$\begin{bmatrix}
3 &amp; 7  &amp; 11 \\<br />
15 &amp; 19  &amp; 23 \\<br />
27 &amp; 31 &amp; 35
\end{bmatrix}$ $\quad B + A = $
$\begin{bmatrix}
3 &amp; 7  &amp; 11 \\<br />
15 &amp; 19  &amp; 23 \\<br />
27 &amp; 31 &amp; 35
\end{bmatrix}$</p>
  </li>
  <li>
    <p>$A - B = $
$\begin{bmatrix}
-1 &amp; -1  &amp; -1 \\<br />
-1 &amp; -1  &amp; -1 \\<br />
-1 &amp; -1 &amp; -1
\end{bmatrix}$ $\quad B - A = $
$\begin{bmatrix}
1 &amp; 1  &amp; 1 \\<br />
1 &amp; 1  &amp; 1 \\<br />
1 &amp; 1 &amp; 1
\end{bmatrix}$</p>
  </li>
</ul>

<blockquote>
  <p>실수의 덧셈, 뺄셈과 마찬가지로 행렬의 덧셈은 교환법칙이 성립하고, 뺄셈은 교환법칙이 성립하지 않는다.</p>
</blockquote>

<p><br /></p>

<h1 id="행렬의-스칼라-곱">행렬의 스칼라 곱</h1>

<blockquote>
  <p><span style="color:red">스칼라(scalar)</span>는 하나의 수로 표현할 수 있는 값이다. 일반적으로 사용하는 실수는 스칼라에 해당한다.</p>
</blockquote>

<ul>
  <li>행렬과 스칼라 사이에는 곱셈 연산이 가능하다.</li>
</ul>

<h2 id="정의-1">정의</h2>

<blockquote>
  <p>행렬 $A$ 에 실수 $k$ 를 곱하는 연산</p>
</blockquote>

<p>$kA = k \times A = [ka_{ij}] = k$
$\begin{bmatrix}
a_{11} &amp; a_{12} &amp; \cdots &amp; a_{1n} \\<br />
a_{21} &amp; a_{22} &amp; \cdots &amp; a_{2n} \\<br />
\cdots &amp; \cdots &amp; \cdots &amp; \cdots \\<br />
a_{m1} &amp; a_{m2} &amp; \cdots &amp; a_{mn}
\end{bmatrix} = $
$\begin{bmatrix}
ka_{11} &amp; ka_{12} &amp; \cdots &amp; ka_{1n} \\<br />
ka_{21} &amp; ka_{22} &amp; \cdots &amp; ka_{2n} \\<br />
\cdots &amp; \cdots &amp; \cdots &amp; \cdots \\<br />
ka_{m1} &amp; ka_{m2} &amp; \cdots &amp; ka_{mn}
\end{bmatrix}$</p>

<h2 id="예시">예시</h2>

<ul>
  <li>$5A = 5 \times A =  5 \times$
$\begin{bmatrix}
1 &amp; 2 &amp; 3 \\<br />
4 &amp; 5 &amp; 6 \\<br />
7 &amp; 8 &amp; 9
\end{bmatrix} = $
$\begin{bmatrix}
5 &amp; 10 &amp; 15 \\<br />
20 &amp; 25 &amp; 30 \\<br />
35 &amp; 40 &amp; 45
\end{bmatrix}$</li>
</ul>

<p><br /><br /></p>

<h1 id="행렬의-곱셈">행렬의 곱셈</h1>

<h2 id="정의-2">정의</h2>
<blockquote>
  <p>$m \times n$ 행렬 $A$ 와 $n \times r$ 행렬 $B$ 가 있을 때, 다음 연산식을 이용하여 구하는 $m \times r$ 행렬 $C$</p>
  <ul>
    <li>$AB = A \times B = C = [c_{ij}]$</li>
    <li>$c_{ij} = a_{i1}b_{1j} + a_{i2}b_{2j} + \cdots a_{in}b_{nj} = \sum_{k=1}^N a_{ik}b_{kj}$</li>
  </ul>
</blockquote>

<ul>
  <li>$A = [a_{ij}] = $
$\begin{bmatrix}
a_{11} &amp; a_{12} &amp; \cdots &amp; a_{1n} \\<br />
a_{21} &amp; a_{22} &amp; \cdots &amp; a_{2n} \\<br />
\cdots &amp; \cdots &amp; \cdots &amp; \cdots \\<br />
a_{m1} &amp; a_{m2} &amp; \cdots &amp; a_{mn}
\end{bmatrix}$ $,\quad B = [b_{ij}] = $
$\begin{bmatrix}
b_{11} &amp; b_{12} &amp; \cdots &amp; b_{1n} \\<br />
b_{21} &amp; b_{22} &amp; \cdots &amp; b_{2n} \\<br />
\cdots &amp; \cdots &amp; \cdots &amp; \cdots \\<br />
b_{m1} &amp; b_{m2} &amp; \cdots &amp; b_{mn}
\end{bmatrix}$ 일 때,</li>
</ul>

<p><br /></p>

<ul>
  <li>$AB = A \times B = $
$\begin{bmatrix}
a_{11} &amp; a_{12} &amp; \cdots &amp; a_{1n} \\<br />
a_{21} &amp; a_{22} &amp; \cdots &amp; a_{2n} \\<br />
\cdots &amp; \cdots &amp; \cdots &amp; \cdots \\<br />
a_{m1} &amp; a_{m2} &amp; \cdots &amp; a_{mn}
\end{bmatrix} \times $
$\begin{bmatrix}
b_{11} &amp; b_{12} &amp; \cdots &amp; b_{1n} \\<br />
b_{21} &amp; b_{22} &amp; \cdots &amp; b_{2n} \\<br />
\cdots &amp; \cdots &amp; \cdots &amp; \cdots \\<br />
b_{m1} &amp; b_{m2} &amp; \cdots &amp; b_{mn}
\end{bmatrix} = $
$\begin{bmatrix}
c_{11} &amp; c_{12} &amp; \cdots &amp; c_{1n} \\<br />
c_{21} &amp; c_{22} &amp; \cdots &amp; c_{2n} \\<br />
\cdots &amp; \cdots &amp; \cdots &amp; \cdots \\<br />
c_{m1} &amp; c_{m2} &amp; \cdots &amp; c_{mn}
\end{bmatrix}$</li>
</ul>

<p><br /></p>

<ul>
  <li>$\begin{bmatrix}
a_{11}b_{11} + a_{12}b_{21} + \cdots + a_{1n}b_{n1} &amp; a_{11}b_{12} + a_{12}b_{22} + \cdots + a_{1n}b_{n2} &amp; \cdots &amp; a_{11}b_{1r} + a_{12}b_{2r} + \cdots + a_{1n}b_{nr} \\<br />
a_{21}b_{11} + a_{22}b_{21} + \cdots + a_{2n}b_{n1} &amp; a_{21}b_{12} + a_{22}b_{22} + \cdots + a_{2n}b_{n2} &amp; \cdots &amp; a_{21}b_{1r} + a_{22}b_{2r} + \cdots + a_{2n}b_{nr}\\<br />
\cdots &amp; \cdots &amp; \cdots &amp; \cdots \\<br />
a_{m1}b_{11} + a_{m2}b_{21} + \cdots + a_{mn}b_{n1} &amp; a_{m1}b_{12} + a_{m2}b_{22} + \cdots + a_{mn}b_{n2} &amp; \cdots &amp; a_{m1}b_{1r} + a_{m2}b_{2r} + \cdots + a_{mn}b_{nr}
\end{bmatrix}$</li>
</ul>

<p><img src="/assets/images/Math/dm/dm_example_7_1.png" /></p>

<h2 id="예시-1">예시</h2>
<ul>
  <li>다음 행렬 $A,B,C$ 가 있다.</li>
</ul>

<p>$A = $
$\begin{bmatrix}
1 &amp; 2  &amp; 3 \\<br />
4 &amp; 5  &amp; 6
\end{bmatrix}$ $\quad B = $
$\begin{bmatrix}
1 &amp; 1 &amp; 1 \\<br />
2 &amp; 2 &amp; 2 \\<br />
3 &amp; 3 &amp; 3
\end{bmatrix}$ $\quad C = $
$\begin{bmatrix}
1 &amp; 1\\ 
2 &amp; 2
\end{bmatrix}$</p>

<ul>
  <li>각 행렬의 크기는 다음과 같다.
    <ul>
      <li>$A = 2 \times 3$</li>
      <li>$B = 3 \times 3$</li>
      <li>$C = 2 \times 2$</li>
    </ul>
  </li>
  <li>곱셈 연산이 가능한 행렬 $(m \times n) \times (n \times r)$
    <ul>
      <li>
        <p>$A \times B = $
  $\begin{bmatrix}
  14 &amp; 14 &amp; 14 \\<br />
  32 &amp; 32 &amp; 32
  \end{bmatrix}$</p>
      </li>
      <li>
        <p>$C \times A = $
  $\begin{bmatrix}
  5 &amp; 7 &amp; 9 \\<br />
  10 &amp; 14 &amp; 18
  \end{bmatrix}$</p>
      </li>
    </ul>
  </li>
</ul>

<h1 id="행렬-연산의-성질">행렬 연산의 성질</h1>

<blockquote>
  <p>행렬 $A,B,C$, 영행렬 $O$, 단위행렬 $I$ 와 스칼라 $k$ 에 대하여 다음이 성립한다.</p>
</blockquote>

<ol>
  <li>$A + B = B + A$</li>
  <li>$A + O = O + A = A$</li>
  <li>$(-1)A = -A$</li>
  <li>$(k+l)A = kA + lA$</li>
  <li>$kAB = (kA)B = A(kB)$</li>
  <li>$AO = OA = O$</li>
  <li>$A + (B+C) = (A + B) + C$</li>
  <li>$A + (-A) = (-A) + A = O$</li>
  <li>$k(A+B) = kA + kB$</li>
  <li>$(kl)A = k(lA)$</li>
  <li>$AI = IA = A$</li>
</ol>

<hr />

<h1 id="참고-문헌">참고 문헌</h1>
<ul>
  <li>박주미, ⌜컴퓨팅 사고력을 키우는 이산 수학수학 3판⌟ , 2023 , 한빛아카데미 , p205 ~ p213</li>
</ul>]]></content><author><name>지지형</name></author><category term="Discrete Mathematics" /><summary type="html"><![CDATA[행렬의 연산]]></summary></entry><entry><title type="html">[이산수학] 행렬(Matrix) : 01_행렬의 개념</title><link href="http://localhost:4000/discrete%20mathematics/DM-06/" rel="alternate" type="text/html" title="[이산수학] 행렬(Matrix) : 01_행렬의 개념" /><published>2023-11-23T00:00:00+09:00</published><updated>2023-11-23T00:00:00+09:00</updated><id>http://localhost:4000/discrete%20mathematics/DM-06</id><content type="html" xml:base="http://localhost:4000/discrete%20mathematics/DM-06/"><![CDATA[<h1 id="행렬-matrix">행렬 (Matrix)</h1>

<ul>
  <li>
    <p>행렬은 연립일차방적식을 풀기 위해 사용되는 수의 구조이다.</p>
  </li>
  <li>
    <p>2차원 배열 형태인 행렬은 두 개 이상의 집합을 구성하는 원소 간의 관계를 표현하기에 적합하다.</p>
  </li>
  <li>
    <p>행렬은 데이터 연산 구조, 네트워크 모델, 선형 모델등과 같은 수학적 모델을 표현하는데 활용된다.</p>
  </li>
</ul>

<blockquote>
  <p>인공지능 관련해서 Python의 라이브러리 numpy를 활용할 때 행렬에 대한 지식이 필수적이라 느껴 정리했습니다.</p>
</blockquote>

<h1 id="행렬의-개념">행렬의 개념</h1>

<h2 id="정의">정의</h2>
<blockquote>
  <p>하나 이상의 원소를 1차원 또는 2차원의 형태로 나열한 배열<br />
$m$ 행 $n$ 열로 나열한 실수의 2차원 배열 ($m &gt; 0, n &gt; 0$)</p>
</blockquote>

<ul>
  <li>
    <p>$A = [a_{ij}] \quad (1 \le i \le m, \quad 1 \le j \le n)$</p>
  </li>
  <li>
    <p>$\begin{bmatrix}
a_{11} &amp; a_{12} &amp; \cdots &amp; a_{1n} \\<br />
a_{21} &amp; a_{22} &amp; \cdots &amp; a_{2n} \\<br />
\cdots &amp; \cdots &amp; \cdots &amp; \cdots \\<br />
a_{m1} &amp; a_{m2} &amp; \cdots &amp; a_{mn}
\end{bmatrix}$</p>
  </li>
</ul>

<h2 id="행렬의-표현">행렬의 표현</h2>

<ul>
  <li>
    <p>행렬 (matrix : $A = [a_{ij}]$)</p>
  </li>
  <li>가로줄 : 행 (row)
    <ul>
      <li>행 크기 : 한 행을 이루는 원소의 개수</li>
    </ul>
  </li>
  <li>세로줄 : 열(column)
    <ul>
      <li>열 크기 : 한 열을 이루는 원소의 개수</li>
    </ul>
  </li>
</ul>

<ol>
  <li>영어 대문자 : $A, B, C \cdots$</li>
  <li>원소 표기 : $[a_{ij}]$</li>
</ol>

<ul>
  <li>행렬의 크기를 이용하여 나타내기
    <ul>
      <li>행 : $m$행, $\quad$ 열 : $n$열</li>
      <li>$m \times n $ 행렬</li>
    </ul>
  </li>
  <li>행렬의 위치를 이용하여 나타내기
    <ul>
      <li>행 번호($i$), 열번호($j$)</li>
      <li>$a_{ij}$ 는 $i$ 행 $j$ 열에 위치한 원소를 의미한다.</li>
    </ul>
  </li>
</ul>

<h3 id="예시">예시</h3>
<p><br /></p>

<p>$A = \begin{bmatrix}
1 &amp; 2 &amp; 3 &amp; 4 \\<br />
5 &amp; 6 &amp; 7 &amp; 8 \\<br />
8 &amp; 7 &amp; 6 &amp; 5 \\<br />
4 &amp; 3 &amp; 2 &amp; 1
\end{bmatrix}$</p>

<ul>
  <li>
    <p>위 행렬 A는 행 4개와 열 4개로 구성된 행렬이다.</p>
  </li>
  <li>
    <p>크기가 4행 4열인 행렬 또는 $4 \times 4$ (4 - by - 4)로 표현할 수 있다.</p>
  </li>
  <li>
    <p>행렬 A의 1행은 $\begin{bmatrix} 1 &amp; 2 &amp; 3 &amp; 4 \end{bmatrix}$ 이다.</p>
  </li>
  <li>
    <p>행렬 A의 1열은 $\begin{bmatrix}1 \\   5 \\   8 \\   4\end{bmatrix}$ 이다.</p>
  </li>
  <li>
    <p>원소표기법을 이용하면 행렬 $A$의 $a_{11}$ 은 $1$ 이고, $a_{44}$ 도 1이다.</p>
    <ul>
      <li>행렬 $A$ 에서 $a_{11}$ 과 $a_{44}$는 $1$이라는 동일한 값을 가지나, 서로 다른 원소로 구분된다.</li>
    </ul>
  </li>
</ul>

<h1 id="기본적인-행렬">기본적인 행렬</h1>

<h2 id="영행렬-zero-matrix--o">영행렬 (zero matrix : $O$)</h2>

<h3 id="정의-1">정의</h3>

<blockquote>
  <p>$m \times n$ 행렬 $A = [a_{ij}]$가 있을 때 모든 $i, j$ 에 대하여 $a_{ij} = 0$ 인 행렬</p>
</blockquote>

<ul>
  <li>$O =$
$\begin{bmatrix}
0 &amp; 0 &amp; \cdots &amp; 0 \\<br />
0 &amp; 0 &amp; \cdots &amp; 0 \\<br />
\cdots &amp; \cdots &amp; \cdots &amp; \cdots \\<br />
0 &amp; 0 &amp; \cdots &amp; 0 \\<br />
\end{bmatrix}$</li>
</ul>

<h2 id="n차-정사각행렬n-square-matrix">$n$차 정사각행렬(n-square matrix)</h2>

<h3 id="정의-2">정의</h3>

<blockquote>
  <p>$m \times n$ 행렬 $A = [a_{ij}]$ 가 있을 때 $m = n$인 행렬</p>
</blockquote>

<ul>
  <li>$A =$
$\begin{bmatrix}
a_{11} &amp; a_{12} &amp; \cdots &amp; a_{1n} \\<br />
a_{21} &amp; a_{22} &amp; \cdots &amp; a_{2n} \\<br />
\cdots &amp; \cdots &amp; \cdots &amp; \cdots \\<br />
a_{n1} &amp; a_{n2} &amp; \cdots &amp; a_{nn}
\end{bmatrix}$</li>
</ul>

<h3 id="주대각-원소-main-diagonal-element">주대각 원소 (main diagonal element)</h3>
<blockquote>
  <p>정사각형 행렬에서 행렬의 원소 $a_{ij}$ 중 $i = j$ 인 원소를 <strong>주대각 원소(main diagonal element)</strong>라고 한다.</p>
</blockquote>

<h4 id="예시-1">예시</h4>

<ul>
  <li>
    <p>$A =$ 
$\begin{bmatrix}
1 &amp; 3 &amp; 5 &amp; 7 \\<br />
5 &amp; 2 &amp; 7 &amp; 8 \\<br />
8 &amp; 7 &amp; 3 &amp; 5 \\<br />
4 &amp; 3 &amp; 2 &amp; 4
\end{bmatrix}$</p>

    <ul>
      <li>행렬 $A$ 의 원소 $a_{11}, a_{22}, a_{33}, a_{44}$ 에 해당하는 $1, 2, 3, 4$는 행렬 $A$ 의 <strong>주대각 원소</strong>이다.</li>
    </ul>
  </li>
</ul>

<h2 id="단위행렬-unit-matrix--i--항등행렬">단위행렬 (unit matrix : $I$ ), 항등행렬</h2>

<h3 id="정의-3">정의</h3>

<blockquote>
  <p>주대각 원소만 1 이고 나머지 원소는 모두 0 인 행렬</p>
</blockquote>

<ul>
  <li>단위행렬은 정사각행렬인 경우에만 존재하며 행렬의 곱셈에서 항등원 역할을 하기때문에 항등행렬이라고 말한다.</li>
</ul>

<p><br /></p>

<ul>
  <li>$I =$
$\begin{bmatrix}
1 &amp; 0 &amp; \cdots &amp; 0 \\<br />
0 &amp; 1 &amp; \cdots &amp; 0 \\<br />
\cdots &amp; \cdots &amp; \cdots &amp; \cdots \\<br />
0 &amp; 0 &amp; \cdots &amp; 1
\end{bmatrix}$</li>
</ul>

<hr />

<h1 id="참고-문헌">참고 문헌</h1>
<ul>
  <li>박주미, ⌜컴퓨팅 사고력을 키우는 이산 수학수학 3판⌟ , 2023 , 한빛아카데미 , p201 ~ p204</li>
</ul>]]></content><author><name>지지형</name></author><category term="Discrete Mathematics" /><summary type="html"><![CDATA[행렬 (Matrix)]]></summary></entry><entry><title type="html">[백준] 1436 : 영화감독 숌 (파이썬)</title><link href="http://localhost:4000/boj/BOJ-1436/" rel="alternate" type="text/html" title="[백준] 1436 : 영화감독 숌 (파이썬)" /><published>2023-11-23T00:00:00+09:00</published><updated>2023-11-23T00:00:00+09:00</updated><id>http://localhost:4000/boj/BOJ-1436</id><content type="html" xml:base="http://localhost:4000/boj/BOJ-1436/"><![CDATA[<h1 id="-난이도">🔎 난이도</h1>
<blockquote>
  <p>⚪️ <strong>실버 5</strong></p>
</blockquote>

<h1 id="️-문제">✏️ 문제</h1>
<blockquote>
  <p><a href="https://www.acmicpc.net/problem/1436">https://www.acmicpc.net/problem/1436</a></p>
</blockquote>

<p><img src="/assets/images/Coding_test/Boj/BOJ_1436_1.png" />
<br /></p>

<h1 id="-예제-입력-및-출력">🤖 예제 입력 및 출력</h1>

<p><img src="/assets/images/Coding_test/Boj/BOJ_1436_2.png" /></p>

<p><br /></p>

<h1 id="-알고리즘-분류">📑 알고리즘 분류</h1>

<ul>
  <li>브루트포스 알고리즘</li>
</ul>

<p><br /></p>

<h1 id="-아이디어">🧐 아이디어</h1>

<ul>
  <li>처음에 규칙이 있을거라 생각했다.
    <ul>
      <li>666 ${\rightarrow}$ 1666 ${\rightarrow}$ … ${\rightarrow}$ 6660 ${\rightarrow}$ 6661 ${\rightarrow}$ 6662 ${\rightarrow}$ … ${\rightarrow}$ 6669 ${\rightarrow}$ 7666 ${\rightarrow}$ …</li>
    </ul>
  </li>
  <li>위와 같이 666 의 뒤로 0 ~ 9 까지 진행하는 경우와 666 앞으로 진행하는 규칙이 있기 때문에 일관된 규칙을 찾기 어려웠습니다.</li>
  <li>그리고 코드가 복잡해질거라 생각하여 첫 번째 제목인 ‘666’ 부터 1씩 더해가며 666이 들어간 숫자를 찾아내는 완전탐색 방식을 채택하여 풀이했습니다.</li>
</ul>

<p><br /></p>

<h1 id="-내-풀이">📝 내 풀이</h1>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># 입력
</span><span class="n">n</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">input</span><span class="p">())</span>

<span class="c1"># 영화 제목
</span><span class="n">title</span> <span class="o">=</span> <span class="mi">666</span>

<span class="c1"># n과 비교할 숫자
</span><span class="n">cnt</span> <span class="o">=</span> <span class="mi">0</span>

<span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
    <span class="c1"># 666이 영화제목에 들어가면 cnt = cnt + 1
</span>    <span class="k">if</span> <span class="s">'666'</span> <span class="ow">in</span> <span class="nb">str</span><span class="p">(</span><span class="n">title</span><span class="p">):</span>
      <span class="n">cnt</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="c1"># n과 cnt가 같으면 while문 탈출
</span>    <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="n">cnt</span><span class="p">:</span>
        <span class="k">break</span>
    
    <span class="c1"># 영화 제목 + 1
</span>    <span class="n">title</span> <span class="o">+=</span> <span class="mi">1</span>

<span class="c1"># 출력
</span><span class="k">print</span><span class="p">(</span><span class="n">title</span><span class="p">)</span>
</code></pre></div></div>
<p><br /></p>

<h1 id="-풀이-리뷰">😳 풀이 리뷰</h1>

<ul>
  <li>N번째로 큰 영화 제목을 찾을 때 연산의 횟수를 알수없기에 While문을 통해 반복했습니다.</li>
  <li>while문 종료 조건으로 n과 cnt를 비교하여 반복문을 탈출하게 설정했습니다.</li>
  <li>title을 1씩 더해가며 ‘666’이 포함될 때 cnt = cnt + 1</li>
</ul>]]></content><author><name>지지형</name></author><category term="BOJ" /><summary type="html"><![CDATA[🔎 난이도 ⚪️ 실버 5]]></summary></entry><entry><title type="html">[프로그래머스] Lv.01 : 삼총사 (파이썬)</title><link href="http://localhost:4000/programmers/Programmers-%EC%82%BC%EC%B4%9D%EC%82%AC/" rel="alternate" type="text/html" title="[프로그래머스] Lv.01 : 삼총사 (파이썬)" /><published>2023-11-04T00:00:00+09:00</published><updated>2023-11-04T00:00:00+09:00</updated><id>http://localhost:4000/programmers/Programmers-%EC%82%BC%EC%B4%9D%EC%82%AC</id><content type="html" xml:base="http://localhost:4000/programmers/Programmers-%EC%82%BC%EC%B4%9D%EC%82%AC/"><![CDATA[<h1 id="-난이도">🔎 난이도</h1>
<blockquote>
  <p><strong>Lv.01</strong></p>
</blockquote>

<h1 id="️-문제">✏️ 문제</h1>
<blockquote>
  <p><a href="https://school.programmers.co.kr/learn/courses/30/lessons/131705">https://school.programmers.co.kr/learn/courses/30/lessons/131705</a></p>
</blockquote>

<h1 id="️-문제-설명">✒️ 문제 설명</h1>
<p>한국중학교에 다니는 학생들은 각자 정수 번호를 갖고 있습니다.<br />
이 학교 학생 3명의 정수 번호를 더했을 때 0이 되면 3명의 학생은 삼총사라고 합니다.<br />
예를 들어, 5명의 학생이 있고, 각각의 정수 번호가 순서대로 $-2, 3, 0, 2, -5$ 일 때,<br />
첫 번째, 세 번째, 네 번째 학생의 정수 번호를 더하면 $0$ 이므로 세 학생은 삼총사입니다.<br />
또한, 두 번째, 네 번째, 다섯 번째 학생의 정수 번호를 더해도 $0$ 이므로 세 학생도 삼총사입니다.<br />
따라서 이 경우 한국 중학교에서는 두 가지 방법으로 삼총사를 만들 수 있습니다.</p>

<p>한국중학교 학생들의 번호를 나타내는 정수 배열 $number$ 가 매개변수로 주어질 때,<br />
학생들 중 삼총사를 만들 수 있는 방법의 수를 $return$ 하도록 $solution$ 함수를 완성하세요.</p>

<p><br /></p>

<h1 id="️-제한사항">🙅‍♂️ 제한사항</h1>
<ul>
  <li>
    <p>$3$ $\le$ $number$ 의 길이 $\le$ $13$</p>
  </li>
  <li>
    <p>$-1000$ $\le$ $number$ 의 각 원소 $\le$ $1000$</p>
  </li>
  <li>
    <p>서로 다른 학생의 정수 번호가 같을 수 있습니다.</p>
  </li>
</ul>

<h1 id="-입출력-예">🤖 입출력 예</h1>

<table>
  <thead>
    <tr>
      <th style="text-align: center">number</th>
      <th style="text-align: center">result</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">[-2, 3, 0, 2, -5]</td>
      <td style="text-align: center">2</td>
    </tr>
    <tr>
      <td style="text-align: center">[-3, -2, -1, 0, 1, 2, 3]</td>
      <td style="text-align: center">5</td>
    </tr>
    <tr>
      <td style="text-align: center">[-1, 1, -1, 1]</td>
      <td style="text-align: center">0</td>
    </tr>
  </tbody>
</table>

<h1 id="-입출력-예-설명">🤖 입출력 예 설명</h1>
<ul>
  <li>입출력 예 # 1
    <ul>
      <li>문제의 예시와 같습니다.</li>
    </ul>
  </li>
  <li>입출력 예 # 2
    <ul>
      <li>학생들의 정수 번호 쌍 (-3, 0, 3), (-2, 0, 2), (-1, 0, 1), (-2, -1, 3), (-3, 1, 2) 이 삼총사가 될 수 있으므로, 5를 return 합니다.</li>
    </ul>
  </li>
  <li>입출력 예 # 3
    <ul>
      <li>삼총사가 될 수 있는 방법이 없습니다.</li>
    </ul>
  </li>
</ul>

<p><br /></p>

<h1 id="-아이디어">🧐 아이디어</h1>
<blockquote>
  <p>number 리스트에서 3개의 원소를 뽑아 합이 0이되는 경우를 찾아 개수를 세는 문제였다.</p>
</blockquote>

<p><br /></p>

<h1 id="-내-풀이">📝 내 풀이</h1>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="k">def</span> <span class="nf">solution</span><span class="p">(</span><span class="n">number</span><span class="p">):</span>
    <span class="c1"># 출력 및 정답
</span>    <span class="n">answer</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="c1"># 3중 반복문을 통해 number 원소 3개씩 뽑기
</span>    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">number</span><span class="p">)</span><span class="o">-</span><span class="mi">2</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">number</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">number</span><span class="p">)):</span>
                <span class="c1"># 원소 3개의 합이 0이라면, 즉, 삼총사라면 정답 += 1
</span>                <span class="k">if</span> <span class="p">(</span><span class="n">number</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">number</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">+</span> <span class="n">number</span><span class="p">[</span><span class="n">k</span><span class="p">])</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">answer</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="n">answer</span>

</code></pre></div></div>
<p><br /></p>

<h1 id="-풀이-리뷰">😳 풀이 리뷰</h1>
<p>처음에는 DFS로 구현하여 풀었지만, 코드도 직관적이지 못하였고, 다시 보니 이해하기도 어려웠다.<br />
그래서 삼중 반복문을 통해 원소 3개를 뽑는 것을 구현하였다.<br />
삼중 반복문보다 더욱 간단하게 푸는 법은 itertools의 combinations 라이브러리를 활용하는 방법이 있다.</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">itertools</span> <span class="kn">import</span> <span class="n">combinations</span>
</code></pre></div></div>]]></content><author><name>지지형</name></author><category term="Programmers" /><summary type="html"><![CDATA[🔎 난이도 Lv.01 ✏️ 문제 https://school.programmers.co.kr/learn/courses/30/lessons/131705 ✒️ 문제 설명 한국중학교에 다니는 학생들은 각자 정수 번호를 갖고 있습니다. 이 학교 학생 3명의 정수 번호를 더했을 때 0이 되면 3명의 학생은 삼총사라고 합니다. 예를 들어, 5명의 학생이 있고, 각각의 정수 번호가 순서대로 $-2, 3, 0, 2, -5$ 일 때, 첫 번째, 세 번째, 네 번째 학생의 정수 번호를 더하면 $0$ 이므로 세 학생은 삼총사입니다. 또한, 두 번째, 네 번째, 다섯 번째 학생의 정수 번호를 더해도 $0$ 이므로 세 학생도 삼총사입니다. 따라서 이 경우 한국 중학교에서는 두 가지 방법으로 삼총사를 만들 수 있습니다. 한국중학교 학생들의 번호를 나타내는 정수 배열 $number$ 가 매개변수로 주어질 때, 학생들 중 삼총사를 만들 수 있는 방법의 수를 $return$ 하도록 $solution$ 함수를 완성하세요. 🙅‍♂️ 제한사항 $3$ $\le$ $number$ 의 길이 $\le$ $13$ $-1000$ $\le$ $number$ 의 각 원소 $\le$ $1000$ 서로 다른 학생의 정수 번호가 같을 수 있습니다. 🤖 입출력 예 number result [-2, 3, 0, 2, -5] 2 [-3, -2, -1, 0, 1, 2, 3] 5 [-1, 1, -1, 1] 0 🤖 입출력 예 설명 입출력 예 # 1 문제의 예시와 같습니다. 입출력 예 # 2 학생들의 정수 번호 쌍 (-3, 0, 3), (-2, 0, 2), (-1, 0, 1), (-2, -1, 3), (-3, 1, 2) 이 삼총사가 될 수 있으므로, 5를 return 합니다. 입출력 예 # 3 삼총사가 될 수 있는 방법이 없습니다. 🧐 아이디어 number 리스트에서 3개의 원소를 뽑아 합이 0이되는 경우를 찾아 개수를 세는 문제였다. 📝 내 풀이 def solution(number): # 출력 및 정답 answer = 0 # 3중 반복문을 통해 number 원소 3개씩 뽑기 for i in range(0, len(number)-2): for j in range(i+1, len(number)-1): for k in range(j+1, len(number)): # 원소 3개의 합이 0이라면, 즉, 삼총사라면 정답 += 1 if (number[i] + number[j] + number[k]) == 0: answer += 1 return answer 😳 풀이 리뷰 처음에는 DFS로 구현하여 풀었지만, 코드도 직관적이지 못하였고, 다시 보니 이해하기도 어려웠다. 그래서 삼중 반복문을 통해 원소 3개를 뽑는 것을 구현하였다. 삼중 반복문보다 더욱 간단하게 푸는 법은 itertools의 combinations 라이브러리를 활용하는 방법이 있다. from itertools import combinations]]></summary></entry><entry><title type="html">[백준] 1057 : 토너먼트 (파이썬)</title><link href="http://localhost:4000/boj/BOJ-1057/" rel="alternate" type="text/html" title="[백준] 1057 : 토너먼트 (파이썬)" /><published>2023-11-01T00:00:00+09:00</published><updated>2023-11-01T00:00:00+09:00</updated><id>http://localhost:4000/boj/BOJ-1057</id><content type="html" xml:base="http://localhost:4000/boj/BOJ-1057/"><![CDATA[<h1 id="-난이도">🔎 난이도</h1>
<blockquote>
  <p>⚪️ <strong>실버 4</strong></p>
</blockquote>

<h1 id="️-문제">✏️ 문제</h1>
<blockquote>
  <p><a href="https://www.acmicpc.net/problem/1057">https://www.acmicpc.net/problem/1057</a></p>
</blockquote>

<p><img src="/assets/images/Coding_test/Boj/BOJ_1057_1.png" />
<br /></p>

<h1 id="-예제-입력-및-출력">🤖 예제 입력 및 출력</h1>

<p><img src="/assets/images/Coding_test/Boj/BOJ_1057_2.png" /></p>

<p><br /></p>

<h1 id="-알고리즘-분류">📑 알고리즘 분류</h1>

<ul>
  <li>수학</li>
  <li>브루트포스 알고리즘</li>
</ul>

<p><br /></p>

<h1 id="-아이디어">🧐 아이디어</h1>
<p><br /></p>

<p><img src="/assets/images/Coding_test/Boj/BOJ_1057_3.png" width="700" /></p>

<p><br /></p>

<p>고민하다 처음 생각한 아이디어이다.</p>

<ul>
  <li>0으로 이루어진 대진표 리스트와 김지민과 임한수의 인덱스를 1로 표시한다.</li>
  <li>대진표는 n // 2</li>
  <li>step을 2로 둔 for문을 통해 김지민과 임한수가 대결했을 경우의 리스트 합이 2가 나올 것이다.</li>
</ul>

<p>이러한 아이디어를 뼈대로 잡고 코드를 작성했다.</p>

<p><br /></p>

<h1 id="-내-풀이">📝 내 풀이</h1>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># 입력
</span><span class="n">n</span><span class="p">,</span> <span class="n">kim</span><span class="p">,</span> <span class="n">lim</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">input</span><span class="p">().</span><span class="n">split</span><span class="p">())</span>

<span class="c1"># 출력값
</span><span class="nb">round</span> <span class="o">=</span> <span class="mi">0</span>

<span class="c1"># 인덱스
</span><span class="n">kim</span> <span class="o">-=</span> <span class="mi">1</span>
<span class="n">lim</span> <span class="o">-=</span> <span class="mi">1</span>

<span class="k">if</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span> <span class="c1"># 서로 대결하지 않을 경우
</span>    <span class="k">print</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<span class="k">else</span><span class="p">:</span>
    <span class="k">while</span> <span class="n">n</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="nb">round</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="n">table</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">n</span> <span class="c1"># 대진표 생성
</span>
        <span class="n">table</span><span class="p">[</span><span class="n">kim</span><span class="p">],</span> <span class="n">table</span><span class="p">[</span><span class="n">lim</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span><span class="mi">1</span> <span class="c1"># 김, 임 대진 자리 표시
</span>
        <span class="c1"># 출력 (김지민과 임한수가 만났을 경우 break)
</span>        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="mi">2</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">sum</span><span class="p">(</span><span class="n">table</span><span class="p">[</span><span class="n">i</span> <span class="p">:</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">2</span><span class="p">])</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="k">print</span><span class="p">(</span><span class="nb">round</span><span class="p">)</span>
                <span class="k">break</span>
    
        <span class="c1"># n이 홀수 일 경우
</span>        <span class="k">if</span> <span class="n">n</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span> <span class="n">n</span> <span class="o">=</span> <span class="n">n</span> <span class="o">//</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span> <span class="n">n</span> <span class="o">//=</span> <span class="mi">2</span>

        <span class="n">kim</span> <span class="o">//=</span> <span class="mi">2</span>
        <span class="n">lim</span> <span class="o">//=</span> <span class="mi">2</span>
</code></pre></div></div>
<p><br /></p>

<h1 id="-풀이-리뷰">😳 풀이 리뷰</h1>

<blockquote>
  <p>생각한 아이디어를 충실히(?) 이행하며, 코드를 짜다보니 많이 복잡해졌다.<br />
while문이 한 번 돌 때마다 round(정답), 대진표, 인덱스 표시를 갱신 한다. <br />
for 문을 통해 김지민과 임한수가 대결 유무를 판단한다.<br />
대결을 했을 경우 탈출, 대결하지 않았을 경우 n과 kim.lim 를 // 2를 해준다.</p>
</blockquote>

<h1 id="-다른-사람-풀이">😳 다른 사람 풀이</h1>

<blockquote>
  <p>사실 이 문제는 수학적으로 해결이 가능한 문제였다. 필자는 n 길이의 리스트에 직접 김지민과 임한수의 위치를 표시하며 n,김지민,임한수의 2로 나누며 문제를 해결했다.</p>
</blockquote>

<blockquote>
  <p>이 문제의 핵심은 김지민과 임한수의 인덱스가 8,9 라고 할 때, 예시의 식을 이용하는 것이었다.</p>
</blockquote>

<ul>
  <li>김지민 : 8 $\rightarrow$ 4 $\rightarrow$ 2 $\rightarrow$ 1 $\rightarrow$ 1</li>
  <li>임한수 : 9 $\rightarrow$ 5 $\rightarrow$ 3 $\rightarrow$ 2 $\rightarrow$ 1</li>
</ul>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># 입력
</span><span class="n">n</span><span class="p">,</span> <span class="n">kim</span> <span class="p">,</span><span class="n">lim</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">input</span><span class="p">().</span><span class="n">split</span><span class="p">())</span>

<span class="c1"># 출력
</span><span class="nb">round</span> <span class="o">=</span> <span class="mi">0</span>

<span class="k">while</span> <span class="n">kim</span> <span class="o">!=</span> <span class="n">lim</span><span class="p">:</span>
  
    <span class="n">kim</span> <span class="o">-=</span> <span class="n">kim</span> <span class="o">//</span> <span class="mi">2</span>
  
    <span class="n">lim</span> <span class="o">-=</span> <span class="n">lim</span> <span class="o">//</span> <span class="mi">2</span>
  
    <span class="nb">round</span> <span class="o">+=</span> <span class="mi">1</span>

<span class="k">print</span><span class="p">(</span><span class="nb">round</span><span class="p">)</span>
</code></pre></div></div>]]></content><author><name>지지형</name></author><category term="BOJ" /><summary type="html"><![CDATA[🔎 난이도 ⚪️ 실버 4 ✏️ 문제 https://www.acmicpc.net/problem/1057 🤖 예제 입력 및 출력 📑 알고리즘 분류 수학 브루트포스 알고리즘 🧐 아이디어 고민하다 처음 생각한 아이디어이다. 0으로 이루어진 대진표 리스트와 김지민과 임한수의 인덱스를 1로 표시한다. 대진표는 n // 2 step을 2로 둔 for문을 통해 김지민과 임한수가 대결했을 경우의 리스트 합이 2가 나올 것이다. 이러한 아이디어를 뼈대로 잡고 코드를 작성했다. 📝 내 풀이 # 입력 n, kim, lim = map(int, input().split()) # 출력값 round = 0 # 인덱스 kim -= 1 lim -= 1 if n &lt; 2: # 서로 대결하지 않을 경우 print(-1) else: while n != 1: round += 1 table = [0] * n # 대진표 생성 table[kim], table[lim] = 1,1 # 김, 임 대진 자리 표시 # 출력 (김지민과 임한수가 만났을 경우 break) for i in range(0, n, 2): if sum(table[i : i + 2]) == 2: print(round) break # n이 홀수 일 경우 if n % 2 == 1: n = n // 2 + 1 else: n //= 2 kim //= 2 lim //= 2 😳 풀이 리뷰 생각한 아이디어를 충실히(?) 이행하며, 코드를 짜다보니 많이 복잡해졌다. while문이 한 번 돌 때마다 round(정답), 대진표, 인덱스 표시를 갱신 한다. for 문을 통해 김지민과 임한수가 대결 유무를 판단한다. 대결을 했을 경우 탈출, 대결하지 않았을 경우 n과 kim.lim 를 // 2를 해준다. 😳 다른 사람 풀이 사실 이 문제는 수학적으로 해결이 가능한 문제였다. 필자는 n 길이의 리스트에 직접 김지민과 임한수의 위치를 표시하며 n,김지민,임한수의 2로 나누며 문제를 해결했다. 이 문제의 핵심은 김지민과 임한수의 인덱스가 8,9 라고 할 때, 예시의 식을 이용하는 것이었다. 김지민 : 8 $\rightarrow$ 4 $\rightarrow$ 2 $\rightarrow$ 1 $\rightarrow$ 1 임한수 : 9 $\rightarrow$ 5 $\rightarrow$ 3 $\rightarrow$ 2 $\rightarrow$ 1 # 입력 n, kim ,lim = map(int, input().split()) # 출력 round = 0 while kim != lim: kim -= kim // 2 lim -= lim // 2 round += 1 print(round)]]></summary></entry><entry><title type="html">[프로그래머스] Lv.01 : 같은 숫자는 싫어 (파이썬)</title><link href="http://localhost:4000/programmers/Programmers-%EA%B0%99%EC%9D%80-%EC%88%AB%EC%9E%90%EB%8A%94-%EC%8B%AB%EC%96%B4/" rel="alternate" type="text/html" title="[프로그래머스] Lv.01 : 같은 숫자는 싫어 (파이썬)" /><published>2023-10-27T00:00:00+09:00</published><updated>2023-10-27T00:00:00+09:00</updated><id>http://localhost:4000/programmers/Programmers-%EA%B0%99%EC%9D%80%20%EC%88%AB%EC%9E%90%EB%8A%94%20%EC%8B%AB%EC%96%B4</id><content type="html" xml:base="http://localhost:4000/programmers/Programmers-%EA%B0%99%EC%9D%80-%EC%88%AB%EC%9E%90%EB%8A%94-%EC%8B%AB%EC%96%B4/"><![CDATA[<h1 id="-난이도">🔎 난이도</h1>
<blockquote>
  <p><strong>Lv.01</strong></p>
</blockquote>

<h1 id="️-문제">✏️ 문제</h1>
<blockquote>
  <p><a href="https://school.programmers.co.kr/learn/courses/30/lessons/12906">https://school.programmers.co.kr/learn/courses/30/lessons/12906</a></p>
</blockquote>

<h1 id="️-문제-설명">✒️ 문제 설명</h1>
<p>배열 arr가 주어집니다. 배열 arr의 각 원소는 숫자 0부터 9까지로 이루어져있습니다.<br />
이때, 배열 arr에서 연속적으로 나타나는 숫자는 하나만 남기고 전부 제거하려고 합니다.<br />
단, 제거 된 후 남은 수들을 반환할 때는 배열 arr의 원소들의 순서를 유지해야 합니다.</p>

<ul>
  <li>arr = [1, 1, 3, 3, 0, 1, 1] 이면 [1, 3, 0, 1] 을 return 합니다.</li>
  <li>arr = [4, 4, 4, 3, 3] 이면 [4, 3]을 return 합니다.</li>
</ul>

<p>배열 arr 에서 연속적으로 나타나는 숫자는 제거하고 남은 수들을 return 하는 solution 함수를 완성해 주세요.</p>

<p><br /></p>

<h1 id="️-제한사항">🙅‍♂️ 제한사항</h1>
<ul>
  <li>배열 arr의 크기 : 1,000,000 이하의 자연수</li>
  <li>배열 arr의 원소의 크기 : 0보다 크거나 같고 9보다 작거나 같은 정수</li>
</ul>

<h1 id="-입출력-예">🤖 입출력 예</h1>

<table>
  <thead>
    <tr>
      <th>arr</th>
      <th>answer</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>[1, 1, 3, 3, 0, 1 ,1]</td>
      <td>[1, 3, 0, 1]</td>
    </tr>
    <tr>
      <td>[4, 4, 4, 3, 3]</td>
      <td>[4, 3]</td>
    </tr>
  </tbody>
</table>

<h1 id="-입출력-예-설명">🤖 입출력 예 설명</h1>
<ul>
  <li>입출력 예 # 1,2 문제의 예시와 같습니다.</li>
</ul>

<p><br /></p>

<h1 id="-아이디어">🧐 아이디어</h1>
<p>단순히 연속된 숫자의 중복을 제거하는 문제였다면, Set 자료형을 통해 손 쉽게 풀 수 있었을 겁니다. 하지만 기존에 제시한 배열 arr의 순서를 보장해야하기 때문에 Set 자료형을 쓸 수 없습니다.</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">example</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">5</span><span class="p">]</span>

<span class="n">set_example</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">example</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">set_example</span><span class="p">)</span>
<span class="c1"># {1, 2, 3, 4, 5, 6}
</span></code></pre></div></div>

<p>순서 보장을 위해 원래 배열 그대로 탐색을 하며 answer 리스트에 arr 배열의 첫 번째 값(인덱스 = 0)을 넣어 준 후, 1부터 마지막 인덱스까지 전 후 값을 비교하여 다르다면 answer의 append 해주는 방법으로 풀었습니다.</p>

<p><br /></p>

<h1 id="-내-풀이">📝 내 풀이</h1>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">solution</span><span class="p">(</span><span class="n">arr</span><span class="p">):</span>
    <span class="n">answer</span> <span class="o">=</span> <span class="p">[</span><span class="n">arr</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="c1"># arr의 첫 번째 원소
</span>    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">arr</span><span class="p">)):</span> <span class="c1"># 1 ~ arr의 길이 만큼 반복 (길이가 n이라면 n-1 반복)
</span>        <span class="k">if</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span> <span class="c1"># arr배열의 전,후 값 비교 (1,0) (2,1) (3,2) ...
</span>            <span class="n">answer</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="c1"># 같지 않다면 answer 리스트에 원소 추가
</span>    <span class="k">return</span> <span class="n">answer</span>
</code></pre></div></div>
<p><br /></p>

<h1 id="-다른-풀이">😳 다른 풀이</h1>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">diff_solution</span><span class="p">(</span><span class="n">arr</span><span class="p">):</span>
    <span class="n">answer</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">arr</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">answer</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">:]</span> <span class="o">!=</span> <span class="p">[</span><span class="n">i</span><span class="p">]:</span>
            <span class="n">answer</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">answer</span>
</code></pre></div></div>

<p>answer의 마지막 원소와 현재 i와 비교를 하며 같지 않을 경우, 즉, 중복되지 않을 경우 answer 리스트에 원소를 추가하는 방법입니다.</p>]]></content><author><name>지지형</name></author><category term="Programmers" /><summary type="html"><![CDATA[🔎 난이도 Lv.01 ✏️ 문제 https://school.programmers.co.kr/learn/courses/30/lessons/12906 ✒️ 문제 설명 배열 arr가 주어집니다. 배열 arr의 각 원소는 숫자 0부터 9까지로 이루어져있습니다. 이때, 배열 arr에서 연속적으로 나타나는 숫자는 하나만 남기고 전부 제거하려고 합니다. 단, 제거 된 후 남은 수들을 반환할 때는 배열 arr의 원소들의 순서를 유지해야 합니다. arr = [1, 1, 3, 3, 0, 1, 1] 이면 [1, 3, 0, 1] 을 return 합니다. arr = [4, 4, 4, 3, 3] 이면 [4, 3]을 return 합니다. 배열 arr 에서 연속적으로 나타나는 숫자는 제거하고 남은 수들을 return 하는 solution 함수를 완성해 주세요. 🙅‍♂️ 제한사항 배열 arr의 크기 : 1,000,000 이하의 자연수 배열 arr의 원소의 크기 : 0보다 크거나 같고 9보다 작거나 같은 정수 🤖 입출력 예 arr answer [1, 1, 3, 3, 0, 1 ,1] [1, 3, 0, 1] [4, 4, 4, 3, 3] [4, 3] 🤖 입출력 예 설명 입출력 예 # 1,2 문제의 예시와 같습니다. 🧐 아이디어 단순히 연속된 숫자의 중복을 제거하는 문제였다면, Set 자료형을 통해 손 쉽게 풀 수 있었을 겁니다. 하지만 기존에 제시한 배열 arr의 순서를 보장해야하기 때문에 Set 자료형을 쓸 수 없습니다. example = [1,1,6,6,2,2,3,3,3,4,5,5] set_example = set(example) print(set_example) # {1, 2, 3, 4, 5, 6} 순서 보장을 위해 원래 배열 그대로 탐색을 하며 answer 리스트에 arr 배열의 첫 번째 값(인덱스 = 0)을 넣어 준 후, 1부터 마지막 인덱스까지 전 후 값을 비교하여 다르다면 answer의 append 해주는 방법으로 풀었습니다. 📝 내 풀이 def solution(arr): answer = [arr[0]] # arr의 첫 번째 원소 for i in range(1,len(arr)): # 1 ~ arr의 길이 만큼 반복 (길이가 n이라면 n-1 반복) if arr[i] != arr[i-1]: # arr배열의 전,후 값 비교 (1,0) (2,1) (3,2) ... answer.append(arr[i]) # 같지 않다면 answer 리스트에 원소 추가 return answer 😳 다른 풀이 def diff_solution(arr): answer = [] for i in arr: if answer[-1:] != [i]: answer.append(i) return answer answer의 마지막 원소와 현재 i와 비교를 하며 같지 않을 경우, 즉, 중복되지 않을 경우 answer 리스트에 원소를 추가하는 방법입니다.]]></summary></entry><entry><title type="html">[백준] 4673 : 셀프 넘버 (파이썬)</title><link href="http://localhost:4000/boj/BOJ-4673/" rel="alternate" type="text/html" title="[백준] 4673 : 셀프 넘버 (파이썬)" /><published>2023-10-20T00:00:00+09:00</published><updated>2023-10-20T00:00:00+09:00</updated><id>http://localhost:4000/boj/BOJ-4673</id><content type="html" xml:base="http://localhost:4000/boj/BOJ-4673/"><![CDATA[<h1 id="-난이도">🔎 난이도</h1>
<blockquote>
  <p>⚪️ <strong>실버 5</strong></p>
</blockquote>

<h1 id="️-문제">✏️ 문제</h1>
<blockquote>
  <p><a href="https://www.acmicpc.net/problem/4673">https://www.acmicpc.net/problem/4673</a></p>
</blockquote>

<p><img src="/assets/images/Coding_test/Boj/BOJ_4673_1.png" /></p>

<p><br /></p>

<h1 id="-예제-입력-및-출력">🤖 예제 입력 및 출력</h1>

<p><img src="/assets/images/Coding_test/Boj/BOJ_4673_2.png" /></p>

<p><br /></p>

<h1 id="-알고리즘-분류">📑 알고리즘 분류</h1>

<ul>
  <li>수학</li>
  <li>구현</li>
  <li>브루트포스 알고리즘</li>
</ul>

<p><br /></p>

<h1 id="-아이디어">🧐 아이디어</h1>

<blockquote>
  <p>10,000 보다 작거나 같은 <strong>셀프 넘버</strong> 를 출력하는 문제이다.</p>
  <ul>
    <li>생성자 : 양의 정수 $n$ 에 대해서 $n$ 과 $n$ 의 각 자리수를 더하는 함수라고 정의해보면 $d(75) = 75 + 7 + 5 = 87$
      <ul>
        <li>$75$ 는 $d(75) = 87$ 의 생성자이다.</li>
      </ul>
    </li>
    <li>셀프넘버 : 위의 경우처럼 생성자가 있는 것이 아니라 생성자가 없을 경우 셀프 넘버라고 한다.
      <ul>
        <li>각 자리수를 더하여 $31$ 을 만들 수 있는 숫자는 없기에, $31$ 은 셀프 넘버이다.</li>
      </ul>
    </li>
  </ul>
</blockquote>

<p><br /></p>

<h1 id="-내-풀이">📝 내 풀이</h1>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># 생성자 함수
</span><span class="k">def</span> <span class="nf">d</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">:</span> <span class="c1"># 한 자리 수일 경우
</span>        <span class="k">return</span> <span class="n">n</span> <span class="o">+</span> <span class="n">n</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">n</span> <span class="o">+</span> <span class="nb">sum</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">n</span><span class="p">)))</span> <span class="c1"># n과 각 자리수의 합 더하기
</span>
<span class="n">self_num</span> <span class="o">=</span> <span class="p">[</span><span class="bp">True</span><span class="p">]</span> <span class="o">*</span> <span class="mi">10001</span> <span class="c1"># 셀프넘버 리스트
</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">self_num</span><span class="p">)):</span> <span class="c1"># 1 ~ 10000
</span>    <span class="k">if</span> <span class="n">d</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">10000</span><span class="p">:</span> <span class="c1"># 10000보다 작거나 같을 경우
</span>        <span class="n">self_num</span><span class="p">[</span><span class="n">d</span><span class="p">(</span><span class="n">i</span><span class="p">)]</span> <span class="o">=</span> <span class="bp">False</span> <span class="c1"># 생성자일 경우 False 처리 (셀프넘버가 아닐 경우)
</span>
<span class="c1"># 출력
</span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">self_num</span><span class="p">)):</span>
    <span class="k">if</span> <span class="n">self_num</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="bp">True</span><span class="p">:</span> <span class="k">print</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="c1"># 셀프넘버(True)일 경우 출력
</span></code></pre></div></div>
<p><br /></p>

<h1 id="-풀이-리뷰">😳 풀이 리뷰</h1>
<blockquote>
  <p>위 아이디어에서 정리한 개념을 이해 한 후</p>
</blockquote>

<ol>
  <li>인덱스를 통해 문제를 풀어야겠다고 생각했다.</li>
  <li>True로 이루어진 10001개의 셀프넘버 리스트</li>
  <li>반복문을 통해 생성자가 있을 경우 False 처리를 해주는 함수 정의.</li>
  <li>셀프넘버 리스트 True로 남아있는 원소(셀프넘버)의 인덱스를 출력해줌으로써 문제를 해결하였다.</li>
</ol>]]></content><author><name>지지형</name></author><category term="BOJ" /><summary type="html"><![CDATA[🔎 난이도 ⚪️ 실버 5 ✏️ 문제 https://www.acmicpc.net/problem/4673 🤖 예제 입력 및 출력 📑 알고리즘 분류 수학 구현 브루트포스 알고리즘 🧐 아이디어 10,000 보다 작거나 같은 셀프 넘버 를 출력하는 문제이다. 생성자 : 양의 정수 $n$ 에 대해서 $n$ 과 $n$ 의 각 자리수를 더하는 함수라고 정의해보면 $d(75) = 75 + 7 + 5 = 87$ $75$ 는 $d(75) = 87$ 의 생성자이다. 셀프넘버 : 위의 경우처럼 생성자가 있는 것이 아니라 생성자가 없을 경우 셀프 넘버라고 한다. 각 자리수를 더하여 $31$ 을 만들 수 있는 숫자는 없기에, $31$ 은 셀프 넘버이다. 📝 내 풀이 # 생성자 함수 def d(n): if n &lt; 10: # 한 자리 수일 경우 return n + n else: return n + sum(map(int, str(n))) # n과 각 자리수의 합 더하기 self_num = [True] * 10001 # 셀프넘버 리스트 for i in range(1,len(self_num)): # 1 ~ 10000 if d(i) &lt;= 10000: # 10000보다 작거나 같을 경우 self_num[d(i)] = False # 생성자일 경우 False 처리 (셀프넘버가 아닐 경우) # 출력 for i in range(1,len(self_num)): if self_num[i] == True: print(i) # 셀프넘버(True)일 경우 출력 😳 풀이 리뷰 위 아이디어에서 정리한 개념을 이해 한 후 인덱스를 통해 문제를 풀어야겠다고 생각했다. True로 이루어진 10001개의 셀프넘버 리스트 반복문을 통해 생성자가 있을 경우 False 처리를 해주는 함수 정의. 셀프넘버 리스트 True로 남아있는 원소(셀프넘버)의 인덱스를 출력해줌으로써 문제를 해결하였다.]]></summary></entry></feed>